(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.rtc = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2

/**
 * Core functionality
 * @module rtc
 * @main rtc
 */


/**
 * Signaling and signaling channels
 * @module rtc.signaling
 * @main rtc.signaling
 */


/**
 * Internal helpers
 * @module rtc.internal
 * @main rtc.internal
 */

(function() {
  var bindHelper, compat;

  bindHelper = function(obj, fun) {
    if (fun == null) {
      return;
    }
    return fun.bind(obj);
  };

  exports.compat = compat = {
    PeerConnection: window.PeerConnection || window.webkitPeerConnection00 || window.webkitRTCPeerConnection || window.mozRTCPeerConnection,
    IceCandidate: window.RTCIceCandidate || window.mozRTCIceCandidate,
    SessionDescription: window.mozRTCSessionDescription || window.RTCSessionDescription,
    MediaStream: window.MediaStream || window.mozMediaStream || window.webkitMediaStream,
    getUserMedia: bindHelper(navigator, navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia),
    supported: function() {
      return (compat.PeerConnection != null) && (compat.IceCandidate != null) && (compat.SessionDescription != null) && (compat.getUserMedia != null);
    }
  };

}).call(this);

},{}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var Deferred, EventEmitter, Promise, ref,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = require('./internal/promise'), Deferred = ref.Deferred, Promise = ref.Promise;

  EventEmitter = require('events').EventEmitter;


  /**
   * @module rtc
   */


  /**
   * A wrapper for RTCDataChannel. Used to transfer custom data between peers.
   * @class rtc.DataChannel
  #
   * @constructor
   * @param {RTCDataChannel} channel The wrapped native data channel
   * @param {Number} [max_buffer] The size of the send buffer after which we will delay sending
   */

  exports.DataChannel = (function(superClass) {
    extend(DataChannel, superClass);


    /**
     * A new messages was received. Triggers only after `connect()` was called
     * @event message
     * @param {ArrayBuffer} data The data received
     */


    /**
     * The channel was closed
     * @event closed
     */

    function DataChannel(channel, max_buffer) {
      this.channel = channel;
      this.max_buffer = max_buffer != null ? max_buffer : 1024 * 10;
      this._connected = false;
      this._connect_queue = [];
      this._send_buffer = [];
      this.channel.binaryType = 'arraybuffer';
      this.channel.onmessage = (function(_this) {
        return function(event) {
          if (!_this._connected) {
            return _this._connect_queue.push(event.data);
          } else {
            return _this.emit('message', event.data);
          }
        };
      })(this);
      this.channel.onclose = (function(_this) {
        return function() {
          return _this.emit('closed');
        };
      })(this);
      this.channel.onerror = (function(_this) {
        return function(err) {
          return _this.emit('error', err);
        };
      })(this);
    }


    /**
     * Connect to the DataChannel. You will receive messages and will be able to send after calling this.
     * @method connect
     * @return {Promise} Promise which resolves as soon as the DataChannel is open
     */

    DataChannel.prototype.connect = function() {
      var data, i, len, ref1;
      this._connected = true;
      ref1 = this._connect_queue;
      for (i = 0, len = ref1.length; i < len; i++) {
        data = ref1[i];
        this.emit('message', data);
      }
      delete this._connect_queue;
      return Promise.resolve();
    };

    DataChannel.prototype.close = function() {
      this.channel.close();
      return Promise.resolve();
    };


    /**
     * The label of the DataChannel used to distinguish multiple channels
     * @method label
     * @return {String} The label
     */

    DataChannel.prototype.label = function() {
      return this.channel.label;
    };


    /**
     * Send data to the peer through the DataChannel
     * @method send
     * @param data The data to be transferred
     * @return {Promise} Promise which will be resolved when the data was passed to the native data channel
     */

    DataChannel.prototype.send = function(data) {
      var defer;
      if (!this._connected) {
        this.connect();
        console.log("Sending without being connected. Please call connect() on the data channel to start using it.");
      }
      defer = new Deferred();
      this._send_buffer.push([data, defer]);
      if (this._send_buffer.length === 1) {
        this._actualSend();
      }
      return defer.promise;
    };


    /**
     * Method which actually sends the data. Implements buffering
     * @method _actualSend
     * @private
     */

    DataChannel.prototype._actualSend = function() {
      var data, defer, ref1, ref2, results;
      if (this.channel.readyState === 'open') {
        while (this._send_buffer.length) {
          if (this.channel.bufferedAmount >= this.max_buffer) {
            setTimeout(this._actualSend.bind(this), 1);
            return;
          }
          ref1 = this._send_buffer[0], data = ref1[0], defer = ref1[1];
          try {
            this.channel.send(data);
          } catch (_error) {
            setTimeout(this._actualSend.bind(this), 1);
            return;
          }
          defer.resolve();
          this._send_buffer.shift();
        }
      } else {
        results = [];
        while (this._send_buffer.length) {
          ref2 = this._send_buffer.shift(), data = ref2[0], defer = ref2[1];
          results.push(defer.reject(new Error("DataChannel closed")));
        }
        return results;
      }
    };

    return DataChannel;

  })(EventEmitter);

}).call(this);

},{"./internal/promise":4,"events":undefined}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var Deferred, EventEmitter, Promise, ref,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = require('./promise'), Deferred = ref.Deferred, Promise = ref.Promise;

  EventEmitter = require('events').EventEmitter;


  /**
   * @module rtc.internal
   */


  /**
   * Helper which handles DataChannel negotiation for RemotePeer
   * @class rtc.internal.ChannelCollection
   */

  exports.ChannelCollection = (function(superClass) {
    extend(ChannelCollection, superClass);


    /**
     * A new data channel is available
     * @event data_channel_added
     * @param {String} name Name of the channel
     * @param {Promise -> rtc.Stream} stream Promise of the channel
     */

    function ChannelCollection() {
      this.channels = {};
      this.defers = {};
      this.pending = {};
      this.wait_d = new Deferred();
      this.wait_p = this.wait_d.promise;
    }


    /**
     * Set the local channel description.
     * @method setLocal
     * @param {Object} data Object describing each offered DataChannel
     */

    ChannelCollection.prototype.setLocal = function(data) {
      this.local = data;
      if (this.remote != null) {
        return this._update();
      }
    };


    /**
     * Set the remote channel description.
     * @method setRemote
     * @param {Object} data Object describing each offered DataChannel
     */

    ChannelCollection.prototype.setRemote = function(data) {
      this.remote = data;
      if (this.local != null) {
        return this._update();
      }
    };


    /**
     * Matches remote and local descriptions and creates promises common DataChannels
     * @method _update
     * @private
     */

    ChannelCollection.prototype._update = function() {
      var channel, config, defer, name, ref1;
      ref1 = this.remote;
      for (name in ref1) {
        config = ref1[name];
        if (this.local[name] != null) {
          if (this.channels[name] != null) {

          } else if (this.pending[name] != null) {
            channel = this.pending[name];
            delete this.pending[name];
            this.channels[name] = Promise.resolve(channel);
            this.emit('data_channel_added', name, this.channels[name]);
          } else {
            defer = new Deferred();
            this.channels[name] = defer.promise;
            this.defers[name] = defer;
            this.emit('data_channel_added', name, this.channels[name]);
          }
        } else {
          console.log("DataChannel offered by remote but not by local");
        }
      }
      for (name in this.local) {
        if (this.remote[name] == null) {
          console.log("DataChannel offered by local but not by remote");
        }
      }
      return this.wait_d.resolve();
    };


    /**
     * Resolves promises waiting for the given DataChannel
     * @method resolve
     * @param {DataChannel} channel The new channel
     */

    ChannelCollection.prototype.resolve = function(channel) {
      var label;
      label = channel.label();
      if (this.defers[label] != null) {
        this.defers[label].resolve(channel);
        return delete this.defers[label];
      } else {
        return this.pending[label] = channel;
      }
    };


    /**
     * Get a promise to a DataChannel. Will resolve if DataChannel was offered and gets initiated. Might reject after remote and local description are processed.
     * @method get
     * @param {String} name The label of the channel to get
     * @return {Promise -> DataChannel} Promise for the DataChannel
     */

    ChannelCollection.prototype.get = function(name) {
      return this.wait_p.then((function(_this) {
        return function() {
          if (_this.channels[name] != null) {
            return _this.channels[name];
          } else {
            throw new Error("DataChannel not negotiated");
          }
        };
      })(this));
    };

    return ChannelCollection;

  })(EventEmitter);

}).call(this);

},{"./promise":4,"events":undefined}],4:[function(require,module,exports){
(function (global){
// Generated by CoffeeScript 1.9.2

/**
 * @module rtc.internal
 */


/**
 * Alias for native promises or a polyfill if not supported
 * @class rtc.internal.Promise
 */

(function() {
  exports.Promise = global.Promise || require('es6-promise').Promise;


  /**
   * Helper to implement deferred execution with promises
   * @class rtc.internal.Deferred
   */


  /**
   * Resolves the promise
   * @method resolve
   * @param [data] The payload to which the promise will resolve
  #
   * @example
   *     var defer = new Deferred()
   *     defer.resolve(42);
   *     defer.promise.then(function(res) {
   *       console.log(res);   // 42
   *     }
   */


  /**
   * Reject the promise
   * @method reject
   * @param {Error} error The payload to which the promise will resolve
  #
   * @example
   *     var defer = new Deferred()
   *     defer.reject(new Error("Reject because we can!"));
   *     defer.promise.then(function(data) {
   *       // wont happen
   *     }).catch(function(err) {
   *       // will happen
   *     }
   */


  /**
   * The promise which will get resolved or rejected by this deferred
   * @property {Promise} promise
   */

  exports.Deferred = (function() {
    function Deferred() {
      this.promise = new exports.Promise((function(_this) {
        return function(resolve, reject) {
          _this.resolve = resolve;
          return _this.reject = reject;
        };
      })(this));
    }

    return Deferred;

  })();


  /**
   * Adds a timeout to a promise. The promise will be rejected if timeout is
   * reached. It will act like the underlying promise if it is resolved or
   * rejected before the timeout is reached.
   * @param {Promse} promise The underlying promise
   * @param {number} time Timeout in ms
   * @return {Promise} Promise acting like the underlying promise or timeout
   */

  exports.timeout = function(promise, time) {
    return new Promise(function(resolve, reject) {
      promise.then(resolve, reject);
      return setTimeout(function() {
        return reject(new Error('Operation timed out'));
      }, time);
    });
  };

}).call(this);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"es6-promise":undefined}],5:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var Deferred, EventEmitter,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Deferred = require('./promise').Deferred;

  EventEmitter = require('events').EventEmitter;


  /**
   * @module rtc.internal
   */


  /**
   * Helper handling the mapping of streams for RemotePeer
   * @class rtc.internal.StreamCollection
  #
   * @constructor
   */

  exports.StreamCollection = (function(superClass) {
    extend(StreamCollection, superClass);


    /**
     * A new stream was added to the collection
     * @event steam_added
     * @param {String} name The user defined name of the stream
     * @param {Promise -> rtc.Stream} stream Promise to the stream
     */

    function StreamCollection() {

      /**
       * Contains the promises which will resolve to the streams
       * @property {Object} streams
       */
      this.streams = {};
      this._defers = {};
      this._waiting = {};
      this._pending = {};
      this.wait_d = new Deferred();
      this.wait_p = this.wait_d.promise;
    }


    /**
     * Set stream description and generate promises
     * @method update
     * @param data {Object} An object mapping the stream ids to stream names
     */

    StreamCollection.prototype.update = function(data) {
      var defer, i, id, len, members, name, ref, stream, stream_p;
      members = [];
      this._waiting = {};
      ref = this.streams;
      for (stream_p = i = 0, len = ref.length; i < len; stream_p = ++i) {
        name = ref[stream_p];
        if (data[name] == null) {
          delete this.streams[name];
          this.emit('stream_removed', name);
          if (stream_p.isFullfilled()) {
            stream_p.then(function(stream) {
              return stream.close();
            });
          } else if (stream_p.isPending()) {
            stream_p.reject(new Error("Stream removed before being established"));
          }
        }
      }
      for (name in data) {
        id = data[name];
        if (this.streams[name] == null) {
          defer = new Deferred();
          this.streams[name] = defer.promise;
          this._defers[name] = defer;
          this.emit('stream_added', name, defer.promise);
        }
        if (this._defers[name] != null) {
          if (this._pending[id] != null) {
            stream = this._pending[id];
            delete this._pending[id];
            this._defers[name].resolve(stream);
            delete this._defers[name];
          } else {
            this._waiting[id] = name;
          }
        }
      }
      return this.wait_d.resolve();
    };


    /**
     * Add stream to the collection and resolve promises waiting for it
     * @method resolve
     * @param {rtc.Stream} stream
     */

    StreamCollection.prototype.resolve = function(stream) {
      var id, name;
      id = stream.id();
      if (id === 'default') {
        if (Object.keys(this.streams).length === 1 && Object.keys(this._waiting).length === 1) {
          console.log("Working around incompatibility between Firefox and Chrome concerning stream identification");
          id = Object.keys(this._waiting)[0];
        } else {
          console.log("Unable to work around incompatibility between Firefox and Chrome concerning stream identification");
        }
      }
      if (this._waiting[id] != null) {
        name = this._waiting[id];
        delete this._waiting[id];
        this._defers[name].resolve(stream);
        return delete this._defers[name];
      } else {
        return this._pending[id] = stream;
      }
    };


    /**
     * Gets a promise for a stream with the given name. Might be rejected after `update()`
    #
     * @method get
     * @param {String} name
     * @return {Promise} The promise for the `rtc.Stream`
     */

    StreamCollection.prototype.get = function(name) {
      return this.wait_p.then((function(_this) {
        return function() {
          if (_this.streams[name] != null) {
            return _this.streams[name];
          } else {
            throw new Error("Stream not offered");
          }
        };
      })(this));
    };

    return StreamCollection;

  })(EventEmitter);

}).call(this);

},{"./promise":4,"events":undefined}],6:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var exports, extend;

  extend = function(root, obj) {
    var key, value;
    for (key in obj) {
      value = obj[key];
      root[key] = value;
    }
    return exports;
  };

  module.exports = exports = {
    internal: {},
    signaling: {}
  };

  extend(exports, require('./peer'));

  extend(exports, require('./remote_peer'));

  extend(exports, require('./local_peer'));

  extend(exports, require('./peer_connection'));

  extend(exports, require('./stream'));

  extend(exports, require('./compat'));

  extend(exports, require('./room'));

  extend(exports, require('./video_element'));

  extend(exports.internal, require('./internal/stream_collection'));

  extend(exports.internal, require('./internal/channel_collection'));

  extend(exports.internal, require('./internal/promise'));

  extend(exports.signaling, require('./signaling/web_socket_channel'));

  extend(exports.signaling, require('./signaling/palava_signaling'));

  extend(exports.signaling, require('./signaling/calling_signaling'));

  extend(exports.signaling, require('./signaling/muc_signaling'));

}).call(this);

},{"./compat":1,"./internal/channel_collection":3,"./internal/promise":4,"./internal/stream_collection":5,"./local_peer":7,"./peer":8,"./peer_connection":9,"./remote_peer":10,"./room":11,"./signaling/calling_signaling":12,"./signaling/muc_signaling":13,"./signaling/palava_signaling":14,"./signaling/web_socket_channel":16,"./stream":17,"./video_element":18}],7:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var Peer, Stream,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Peer = require('./peer').Peer;

  Stream = require('./stream').Stream;


  /**
   * @module rtc
   */


  /**
   * Represents the local user of the room
   * @class rtc.LocalPeer
   * @extends rtc.Peer
  #
   * @constructor
   */

  exports.LocalPeer = (function(superClass) {
    extend(LocalPeer, superClass);

    function LocalPeer() {

      /**
       * Contains promises of the local streams offered to all remote peers
       * @property streams
       * @type Object
       */
      this.streams = {};

      /**
       * Contains all DataChannel configurations negotiated with all remote peers
       * @property channels
       * @type Object
       */
      this.channels = {};
      this._status = {};
    }


    /**
     * Get an item of the status transferred to all remote peers
     * @method status
     * @param {String} key The key of the value. Will return
     * @return The value associated with the key
     */


    /**
     * Set an item of the status transferred to all remote peers
     * @method status
     * @param {String} key The key of the value. Will return
     * @param value The value to store
     */

    LocalPeer.prototype.status = function(key, value) {
      if (value != null) {
        this._status[key] = value;
        this.emit('status_changed', this._status);
      } else {
        return this._status[key];
      }
    };


    /**
     * Add data channel which will be negotiated with all remote peers
     * @method addDataChannel
     * @param {String} [name='data'] Name of the data channel
     * @param {Object} [desc={ordered: true}] Options passed to `RTCDataChannel.createDataChannel()`
     */

    LocalPeer.prototype.addDataChannel = function(name, desc) {
      if (typeof name !== 'string') {
        desc = name;
        name = this.DEFAULT_CHANNEL;
      }
      if (desc == null) {
        desc = {
          ordered: true
        };
      }
      this.channels[name] = desc;
      this.emit('configuration_changed');
    };


    /**
     * Add local stream to be sent to all remote peers
     * @method addStream
     * @param {String} [name='stream'] Name of the stream
     * @param {Promise -> rtc.Stream | rtc.Stream | Object} stream The stream, a promise to the stream or the configuration to create a stream with `rtc.Stream.createStream()`
     * @return {Promise -> rtc.Stream} Promise of the stream which was added
     */

    LocalPeer.prototype.addStream = function(name, obj) {
      var saveStream, stream_p;
      saveStream = (function(_this) {
        return function(stream_p) {
          _this.streams[name] = stream_p;
          _this.emit('configuration_changed');
          return stream_p;
        };
      })(this);
      if (typeof name !== 'string') {
        obj = name;
        name = this.DEFAULT_STREAM;
      }
      if ((obj != null ? obj.then : void 0) != null) {
        return saveStream(obj);
      } else if (obj instanceof Stream) {
        return saveStream(Promise.resolve(obj));
      } else {
        stream_p = Stream.createStream(obj);
        return saveStream(stream_p);
      }
    };


    /**
     * Get local stream
     * @method stream
     * @param {String} [name='stream'] Name of the stream
     * @return {Promise -> rtc.Stream} Promise of the stream
     */

    LocalPeer.prototype.stream = function(name) {
      if (name == null) {
        name = this.DEFAULT_STREAM;
      }
      return this.streams[name];
    };


    /**
     * Checks whether the peer is the local peer. Returns always `true` on this
     * class.
     * @method isLocal
     * @return {Boolean} Returns `true`
     */

    LocalPeer.prototype.isLocal = function() {
      return true;
    };

    return LocalPeer;

  })(Peer);

}).call(this);

},{"./peer":8,"./stream":17}],8:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var EventEmitter,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  EventEmitter = require('events').EventEmitter;


  /**
   * @module rtc
   */


  /**
   * A user in the room
   * @class rtc.Peer
   */

  exports.Peer = (function(superClass) {
    extend(Peer, superClass);

    function Peer() {
      return Peer.__super__.constructor.apply(this, arguments);
    }


    /**
     * The status of the peer has changed
     * @event status_changed
     * @param {Object} status The new status object
     */

    Peer.prototype.DEFAULT_CHANNEL = 'data';

    Peer.prototype.DEFAULT_STREAM = 'stream';


    /**
     * Get a value of the status object
     * @method status
     * @param {String} key The key 
     * @return The value
     */

    Peer.prototype.status = function(key) {
      throw new Error("Not implemented");
    };

    return Peer;

  })(EventEmitter);

}).call(this);

},{"events":undefined}],9:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var DataChannel, Deferred, EventEmitter, Promise, Stream, compat, ref,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = require('./internal/promise'), Deferred = ref.Deferred, Promise = ref.Promise;

  EventEmitter = require('events').EventEmitter;

  Stream = require('./stream').Stream;

  DataChannel = require('./data_channel').DataChannel;

  compat = require('./compat').compat;


  /**
   * @module rtc
   */


  /**
   * Wrapper around native RTCPeerConnection
  #
   * Provides events for new streams and data channels. Signaling information has
   * to be forwarded from events emitted by this object to the remote
   * PeerConnection.
  #
   * @class rtc.PeerConnection
   * @extends events.EventEmitter
  #
   * @constructor
   * @param {Boolean} offering True if the local peer should initiate the connection
   * @param {Object} options Options object passed on from `Room`
   */

  exports.PeerConnection = (function(superClass) {
    extend(PeerConnection, superClass);


    /**
     * New local ICE candidate which should be signaled to remote peer
     * @event ice_candiate
     * @param {Object} candidate The ice candidate
     */


    /**
     * New remote stream was added to the PeerConnection
     * @event stream_added
     * @param {rtc.Stream} stream The stream
     */


    /**
     * New DataChannel to the remote peer is ready to be used
     * @event data_channel_ready
     * @param {rtc.DataChannel} channel The data channel
     */


    /**
     * New offer or answer which should be signaled to the remote peer
     * @event signaling
     * @param {Object} obj The signaling message
     */


    /**
     * The PeerConnection was closed
     * @event closed
     */

    function PeerConnection(offering, options1) {
      var ice_servers;
      this.offering = offering;
      this.options = options1;
      ice_servers = [];
      this.no_gc_bugfix = [];
      if (this.options.stun != null) {
        ice_servers.push({
          url: this.options.stun
        });
      }
      if (this.options.turn != null) {
        ice_servers.push(this.options.turn);
      }
      this.pc = new compat.PeerConnection({
        iceServers: ice_servers
      });
      this.connect_d = new Deferred();
      this.connected = false;
      this.connect_d.promise["catch"](function() {});
      this.signaling_pending = [];
      this.pc.onicecandidate = (function(_this) {
        return function(event) {
          return _this.emit('ice_candidate', event.candidate);
        };
      })(this);
      this.pc.onaddstream = (function(_this) {
        return function(event) {
          return _this.emit('stream_added', new Stream(event.stream));
        };
      })(this);
      this.pc.ondatachannel = (function(_this) {
        return function(event) {
          return _this.emit('data_channel_ready', new DataChannel(event.channel));
        };
      })(this);
      this.pc.onremovestream = function(event) {};
      this.pc.onnegotiationneeded = (function(_this) {
        return function(event) {
          return console.log('onnegotiationneeded called');
        };
      })(this);
      this.pc.oniceconnectionstatechange = (function(_this) {
        return function() {
          var ref1;
          if (_this.pc.iceConnectionState === 'failed') {
            return _this._connectError(new Error("Unable to establish ICE connection"));
          } else if (_this.pc.iceConnectionState === 'closed') {
            return _this.connect_d.reject(new Error('Connection was closed'));
          } else if ((ref1 = _this.pc.iceConnectionState) === 'connected' || ref1 === 'completed') {
            return _this.connect_d.resolve();
          }
        };
      })(this);
      this.pc.onsignalingstatechange = function(event) {};
    }


    /**
     * Add new signaling information received from remote peer
     * @method signaling
     * @param {Object} data The signaling information
     */

    PeerConnection.prototype.signaling = function(data) {
      var sdp;
      sdp = new compat.SessionDescription(data);
      return this._setRemoteDescription(sdp).then((function(_this) {
        return function() {
          if (data.type === 'offer' && _this.connected) {
            return _this._answer();
          }
        };
      })(this))["catch"]((function(_this) {
        return function(err) {
          return _this._connectError(err);
        };
      })(this));
    };


    /**
     * Add a remote ICE candidate
     * @method addIceCandidate
     * @param {Object} desc The candidate
     */

    PeerConnection.prototype.addIceCandidate = function(desc) {
      var candidate;
      if ((desc != null ? desc.candidate : void 0) != null) {
        candidate = new compat.IceCandidate(desc);
        return this.pc.addIceCandidate(candidate);
      } else {
        return console.log("ICE trickling stopped");
      }
    };


    /**
     * Returns the options for the offer/answer
     * @method _oaOptions
     * @private
     * @return {Object}
     */

    PeerConnection.prototype._oaOptions = function() {
      return {
        optional: [],
        mandatory: {
          OfferToReceiveAudio: true,
          OfferToReceiveVideo: true
        }
      };
    };


    /**
     * Set the remote description
     * @method _setRemoteDescription
     * @private
     * @param {Object} sdp The remote SDP
     * @return {Promise} Promise which will be resolved once the remote description was set successfully
     */

    PeerConnection.prototype._setRemoteDescription = function(sdp) {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          var description;
          description = new compat.SessionDescription(sdp);
          return _this.pc.setRemoteDescription(sdp, resolve, reject);
        };
      })(this));
    };


    /**
     * Create offer, set it on local description and emit it
     * @method _offer
     * @private
     */

    PeerConnection.prototype._offer = function() {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          return _this.pc.createOffer(resolve, reject, _this._oaOptions());
        };
      })(this)).then((function(_this) {
        return function(sdp) {
          return _this._processLocalSdp(sdp);
        };
      })(this))["catch"]((function(_this) {
        return function(err) {
          return _this._connectError(err);
        };
      })(this));
    };


    /**
     * Create answer, set it on local description and emit it
     * @method _offer
     * @private
     */

    PeerConnection.prototype._answer = function() {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          return _this.pc.createAnswer(resolve, reject, _this._oaOptions());
        };
      })(this)).then((function(_this) {
        return function(sdp) {
          return _this._processLocalSdp(sdp);
        };
      })(this))["catch"]((function(_this) {
        return function(err) {
          return _this._connectError(err);
        };
      })(this));
    };


    /**
     * Set local description and emit it
     * @method _processLocalSdp
     * @private
     * @param {Object} sdp The local SDP
     * @return {Promise} Promise which will be resolved once the local description was set successfully
     */

    PeerConnection.prototype._processLocalSdp = function(sdp) {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          var success;
          success = function() {
            var data;
            data = {
              sdp: sdp.sdp,
              type: sdp.type
            };
            _this.emit('signaling', data);
            return resolve(sdp);
          };
          return _this.pc.setLocalDescription(sdp, success, reject);
        };
      })(this));
    };


    /**
     * Mark connection attempt as failed
     * @method _connectError
     * @private
     * @param {Error} err Error causing connection to fail
     */

    PeerConnection.prototype._connectError = function(err) {
      this.connect_d.reject(err);
      console.log(err);
      return this.emit('error', err);
    };


    /**
     * Add local stream
     * @method addStream
     * @param {rtc.Stream} stream The local stream
     */

    PeerConnection.prototype.addStream = function(stream) {
      return this.pc.addStream(stream.stream);
    };


    /**
     * Remove local stream
     * @method removeStream
     * @param {rtc.Stream} stream The local stream
     */

    PeerConnection.prototype.removeSream = function(stream) {
      return this.pc.removeStream(stream.stream);
    };


    /**
     * Add DataChannel. Will only actually do something if `offering` is `true`.
     * @method addDataChannel
     * @param {String} name Name of the data channel
     * @param {Object} desc Options passed to `RTCPeerConnection.createDataChannel()`
     */

    PeerConnection.prototype.addDataChannel = function(name, options) {
      var channel;
      if (this.offering) {
        channel = this.pc.createDataChannel(name, options);
        this.no_gc_bugfix.push(channel);
        return channel.onopen = (function(_this) {
          return function() {
            return _this.emit('data_channel_ready', new DataChannel(channel));
          };
        })(this);
      }
    };


    /**
     * Establish connection with remote peer. Connection will be established once both peers have called this functio
     * @method connect
     * @return {Promise} Promise which will be resolved once the connection is established
     */

    PeerConnection.prototype.connect = function() {
      if (!this.connected) {
        if (this.offering) {
          this._offer();
        } else if (this.pc.signalingState === 'have-remote-offer') {
          this._answer();
        }
        this.connected = true;
      }
      return Promise.resolve(this.connect_d.promise);
    };


    /**
     * Close the connection to the remote peer
     * @method close
     */

    PeerConnection.prototype.close = function() {
      this.pc.close();
      return this.emit('closed');
    };

    return PeerConnection;

  })(EventEmitter);

}).call(this);

},{"./compat":1,"./data_channel":2,"./internal/promise":4,"./stream":17,"events":undefined}],10:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var ChannelCollection, Peer, Promise, StreamCollection, merge,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Promise = require('./internal/promise').Promise;

  Peer = require('./peer').Peer;

  StreamCollection = require('./internal/stream_collection').StreamCollection;

  ChannelCollection = require('./internal/channel_collection').ChannelCollection;

  merge = function() {
    var array, i, key, len, res, value;
    res = {};
    for (i = 0, len = arguments.length; i < len; i++) {
      array = arguments[i];
      for (key in array) {
        value = array[key];
        res[key] = value;
      }
    }
    return res;
  };


  /**
   * @module rtc
   */


  /**
   * Represents a remote user of the room
   * @class rtc.RemotePeer
   * @extends rtc.Peer
  #
   * @constructor
   * @param {rtc.PeerConnection} peer_connection The underlying peer connection
   * @param {rtc.SignalingPeer} signaling The signaling connection to the peer
   * @param {rtc.LocalPeer} local The local peer
   * @param {Object} options The options object as passed to `Room`
   */

  exports.RemotePeer = (function(superClass) {
    extend(RemotePeer, superClass);


    /**
     * Message received from peer through signaling
     * @event message
     * @param data The payload of the message
     */


    /**
     * The remote peer left or signaling closed
     * @event left
     */


    /**
     * A new stream is available from the peer
     * @event stream_added
     * @param {String} name Name of the stream
     * @param {Promise -> rtc.Stream} stream Promise of the stream
     */


    /**
     * A new data channel is available from the peer
     * @event data_channel_added
     * @param {String} name Name of the channel
     * @param {Promise -> rtc.DataChannel} channel Promise of the channel
     */


    /**
     * The connection to the peer supplied by the signaling implementation
     * @property signaling
     * @type rtc.signaling.SignalingPeer
     */

    function RemotePeer(peer_connection, signaling, local, options1) {
      this.peer_connection = peer_connection;
      this.signaling = signaling;
      this.local = local;
      this.options = options1;
      this.private_streams = {};
      this.private_channels = {};
      this.stream_collection = new StreamCollection();
      this.streams = this.stream_collection.streams;
      this.streams_desc = {};
      this.stream_collection.on('stream_added', (function(_this) {
        return function(name, stream) {
          return _this.emit('stream_added', name, stream);
        };
      })(this));
      this.channel_collection = new ChannelCollection();
      this.channels = this.channel_collection.channels;
      this.channels_desc = {};
      this.channel_collection.on('data_channel_added', (function(_this) {
        return function(name, channel) {
          return _this.emit('data_channel_added', name, channel);
        };
      })(this));
      this.peer_connection.on('stream_added', (function(_this) {
        return function(stream) {
          return _this.stream_collection.resolve(stream);
        };
      })(this));
      this.peer_connection.on('data_channel_ready', (function(_this) {
        return function(channel) {
          return _this.channel_collection.resolve(channel);
        };
      })(this));
      this.peer_connection.on('signaling', (function(_this) {
        return function(data) {
          data.streams = _this.streams_desc;
          data.channels = _this.channels_desc;
          return _this.signaling.send('signaling', data);
        };
      })(this));
      this.signaling.on('signaling', (function(_this) {
        return function(data) {
          _this.stream_collection.update(data.streams);
          _this.channel_collection.setRemote(data.channels);
          return _this.peer_connection.signaling(data);
        };
      })(this));
      this.peer_connection.on('ice_candidate', (function(_this) {
        return function(candidate) {
          return _this.signaling.send('ice_candidate', candidate);
        };
      })(this));
      this.signaling.on('ice_candidate', (function(_this) {
        return function(candidate) {
          return _this.peer_connection.addIceCandidate(candidate);
        };
      })(this));
      this.signaling.on('status_changed', (function(_this) {
        return function(status) {
          return _this.emit('status_changed', status);
        };
      })(this));
      this.signaling.on('message', (function(_this) {
        return function(data) {
          return _this.emit('message', data);
        };
      })(this));
      this.signaling.on('left', (function(_this) {
        return function() {
          _this.peer_connection.close();
          return _this.emit('left');
        };
      })(this));
      this.peer_connection.on('connected', (function(_this) {
        return function() {};
      })(this));
      this.peer_connection.on('closed', (function(_this) {
        return function() {};
      })(this));
      if ((this.options.auto_connect == null) || this.options.auto_connect) {
        this.connect();
      }
    }

    RemotePeer.prototype.status = function(key) {
      return this.signaling.status[key];
    };


    /**
     * Send a message to the peer through signaling
     * @method message
     * @param data The payload
     * @return {Promise} Promise which is resolved when the data was sent
     */

    RemotePeer.prototype.message = function(data) {
      return this.signaling.send('message', data);
    };


    /**
     * Connect to the remote peer to exchange streams and create data channels
     * @method connect
     * @return {Promise} Promise which will resolved when the connection is established
     */

    RemotePeer.prototype.connect = function() {
      var name, promise, ref, stream, stream_promises;
      if (this.connect_p == null) {
        stream_promises = [];
        ref = merge(this.local.streams, this.private_streams);
        for (name in ref) {
          stream = ref[name];
          promise = stream.then(function(stream) {
            return [name, stream];
          });
          stream_promises.push(promise);
        }
        this.connect_p = Promise.all(stream_promises).then((function(_this) {
          return function(streams) {
            var i, len, options, ref1, ref2;
            for (i = 0, len = streams.length; i < len; i++) {
              ref1 = streams[i], name = ref1[0], stream = ref1[1];
              _this.peer_connection.addStream(stream);
              _this.streams_desc[name] = stream.id();
            }
            ref2 = merge(_this.local.channels, _this.private_channels);
            for (name in ref2) {
              options = ref2[name];
              _this.peer_connection.addDataChannel(name, options);
              _this.channels_desc[name] = options;
            }
            _this.channel_collection.setLocal(_this.channels_desc);
            return _this.peer_connection.connect();
          };
        })(this));
      }
      return this.connect_p;
    };


    /**
     * Closes the connection to the peer
     * @method close
     */

    RemotePeer.prototype.close = function() {
      this.peer_connection.close();
    };


    /**
     * Get a stream from the peer. Has to be sent by the remote peer to succeed.
     * @method stream
     * @param {String} [name='stream'] Name of the stream
     * @return {Promise -> rtc.Stream} Promise of the stream
     */

    RemotePeer.prototype.stream = function(name) {
      if (name == null) {
        name = this.DEFAULT_STREAM;
      }
      return this.stream_collection.get(name);
    };


    /**
     * Add local stream to be sent to this remote peer
    #
     * If you use this method you have to set `auto_connect` to `false` in the options object and call `connect()` manually on all remote peers.
    #
     * @method addStream
     * @param {String} [name='stream'] Name of the stream
     * @param {Promise -> rtc.Stream | rtc.Stream | Object} stream The stream, a promise to the stream or the configuration to create a stream with `rtc.Stream.createStream()`
     * @return {Promise -> rtc.Stream} Promise of the stream which was added
     */

    RemotePeer.prototype.addStream = function(name, obj) {
      var saveStream, stream_p;
      if (!(this.options.auto_connect === false)) {
        return Promise.reject("Unable to add streams directly to remote peers without 'auto_connect' option set to 'false'");
      }
      saveStream = (function(_this) {
        return function(stream_p) {
          _this.private_streams[name] = stream_p;
          return stream_p;
        };
      })(this);
      if (typeof name !== 'string') {
        obj = name;
        name = this.DEFAULT_STREAM;
      }
      if ((obj != null ? obj.then : void 0) != null) {
        return saveStream(obj);
      } else if (obj instanceof Stream) {
        return saveStream(Promise.resolve(obj));
      } else {
        stream_p = Stream.createStream(obj);
        return saveStream(stream_p);
      }
    };


    /**
     * Get a data channel to the remote peer. Has to be added by local and remote side to succeed.
     * @method channel
     * @param {String} [name='data'] Name of the data channel
     * @return {Promise -> rtc.DataChannel} Promise of the data channel
     */

    RemotePeer.prototype.channel = function(name) {
      if (name == null) {
        name = this.DEFAULT_CHANNEL;
      }
      return this.channel_collection.get(name);
    };


    /**
     * Add data channel which will be negotiated with this remote peer
    #
     * If you use this method you have to set `auto_connect` to `false` in the options object and call `connect()` manually on all remote peers.
    #
     * @method addDataChannel
     * @param {String} [name='data'] Name of the data channel
     * @param {Object} [desc={ordered: true}] Options passed to `RTCDataChannel.createDataChannel()`
     */

    RemotePeer.prototype.addDataChannel = function(name, desc) {
      if (!(this.options.auto_connect === false)) {
        return Promise.reject("Unable to add channels directly to remote peers without 'auto_connect' option set to 'false'");
      }
      if (typeof name !== 'string') {
        desc = name;
        name = this.DEFAULT_CHANNEL;
      }
      if (desc == null) {
        desc = {
          ordered: true
        };
      }
      this.private_channels[name] = desc;
      return this.channel(name);
    };


    /**
     * Checks whether the peer is the local peer. Returns always `false` on this
     * class.
     * @method isLocal
     * @return {Boolean} Returns `false`
     */

    RemotePeer.prototype.isLocal = function() {
      return false;
    };

    return RemotePeer;

  })(Peer);

}).call(this);

},{"./internal/channel_collection":3,"./internal/promise":4,"./internal/stream_collection":5,"./peer":8}],11:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var EventEmitter, LocalPeer, MucSignaling, PeerConnection, RemotePeer, WebSocketChannel,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  EventEmitter = require('events').EventEmitter;

  WebSocketChannel = require('./signaling/web_socket_channel').WebSocketChannel;

  MucSignaling = require('./signaling/muc_signaling').MucSignaling;

  RemotePeer = require('./remote_peer').RemotePeer;

  LocalPeer = require('./local_peer').LocalPeer;

  PeerConnection = require('./peer_connection').PeerConnection;


  /**
   * @module rtc
   */


  /**
   * A virtual room which connects multiple Peers
   * @class rtc.Room
  #
   * @constructor
   * @param {String} name The name of the room. Will be passed on to signaling
   * @param {rtc.Signaling | String} signaling The signaling to be used. If you pass a string it will be interpreted as a websocket address and a palava signaling connection will be established with it.
   * @param {Object} [options] Various options to be used in connections created by this room
   * @param {Boolean} [options.auto_connect=true] Whether remote peers are connected automatically or an explicit `RemotePeer.connect()` call is needed
   * @param {String} [options.stun] The URI of the STUN server to use
   * @param {rtc.LocalPeer} [options.local] The local user
   */

  exports.Room = (function(superClass) {
    extend(Room, superClass);


    /**
     * A new peer is encountered in the room. Fires on new remote peers after joining and for all peers in the room when joining.
     * @event peer_jopined
     * @param {rtc.RemotePeer} peer The new peer
     */


    /**
     * A peer left the room.
     * @event peer_left
     * @param {rtc.RemotePeer} peer The peer which left
     */


    /**
     * A peer changed its status.
     * @event peer_status_changed
     * @param {rtc.RemotePeer} peer The peer which changed its status
     * @param {Object} status The new status
     */


    /**
     * The connection to the room was closed
     * @event closed
     */


    /**
     * The underlying signaling implementation as provided in constructor
     * @property signaling
     * @type rtc.signaling.Signaling
     */


    /**
     * The local peer
     * @property local
     * @type rtc.LocalPeer
     */

    function Room(signaling, options) {
      var channel;
      this.signaling = signaling;
      this.options = options != null ? options : {};
      if (typeof this.signaling === 'string' || this.signaling instanceof String) {
        channel = new WebSocketChannel(this.signaling);
        this.signaling = new MucSignaling(channel);
      }
      this.local = this.options.local || new LocalPeer();
      this.signaling.setStatus(this.local._status);
      this.local.on('status_changed', (function(_this) {
        return function() {
          return _this.signaling.setStatus(_this.local._status);
        };
      })(this));
      this.signaling.on('peer_joined', (function(_this) {
        return function(signaling_peer) {
          var pc, peer;
          pc = new PeerConnection(signaling_peer.first, _this.options);
          peer = _this.createPeer(pc, signaling_peer);
          peer.on('status_changed', function(status) {
            return _this.emit('peer_status_changed', peer, status);
          });
          peer.on('left', function() {
            delete _this.peers[signaling_peer.id];
            return _this.emit('peer_left', peer);
          });
          _this.peers[signaling_peer.id] = peer;
          _this.emit('peer_joined', peer);
          return peer.on('closed', function() {
            return delete _this.peers[signaling_peer.id];
          });
        };
      })(this));
      this.peers = {};
    }


    /**
     * Joins the room. Initiates connection to signaling server if not done before.
     * @method join
     * @return {Promise} A promise which will be resolved once the room was joined
     */

    Room.prototype.connect = function() {
      if (this.join_p == null) {
        this.join_p = this.signaling.connect();
      }
      return this.join_p;
    };


    /**
     * Leaves the room and closes all established peer connections
     * @method leave
     */

    Room.prototype.leave = function() {
      return this.signaling.leave();
    };


    /**
     * Cleans up all resources used by the room.
     * @method leave
     */

    Room.prototype.destroy = function() {
      return this.signaling.leave();
    };


    /**
     * Creates a remote peer. Overwrite to use your own class for peers.
     * @private
     * @method create_peer
     * @param {rtc.PeerConnection} pc The PeerConnection to the peer
     * @param {rtc.SignalingPeer} signaling_peer The signaling connection to the peer
     */

    Room.prototype.createPeer = function(pc, signaling_peer) {
      return new RemotePeer(pc, signaling_peer, this.local, this.options);
    };

    return Room;

  })(EventEmitter);

}).call(this);

},{"./local_peer":7,"./peer_connection":9,"./remote_peer":10,"./signaling/muc_signaling":13,"./signaling/web_socket_channel":16,"events":undefined}],12:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var Calling, CallingInInvitation, CallingInvitationRoom, CallingNamespace, CallingNamespaceRoom, CallingNamespaceRoomPeer, CallingNamespaceUser, CallingOutInvitation, CallingPeer, CallingRoom, CallingSignaling, CallingSignalingPeer, Deferred, EventEmitter, Promise, RemotePeer, Room, extend, ref,
    extend1 = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  EventEmitter = require('events').EventEmitter;

  ref = require('../internal/promise'), Promise = ref.Promise, Deferred = ref.Deferred;

  extend = require('extend');

  Room = require('../room').Room;

  RemotePeer = require('../remote_peer').RemotePeer;

  Calling = (function(superClass) {
    extend1(Calling, superClass);

    function Calling(channel, room_options) {
      var hello_d;
      this.channel = channel;
      this.room_options = room_options;
      this.next_tid = 0;
      this.answers = {};
      hello_d = new Deferred();
      this.hello_p = hello_d.promise;
      this.channel.on('message', (function(_this) {
        return function(msg) {
          var answer, invitation, room;
          _this.resetPing();
          switch (msg.type) {
            case 'hello':
              _this.id = msg.id;
              return hello_d.resolve(msg.server);
            case 'answer':
              if (msg.tid == null) {
                console.log('Missing transaction id in answer');
                return;
              }
              answer = _this.answers[msg.tid];
              delete _this.answers[msg.tid];
              if (answer == null) {
                console.log('Answer without expecting it');
                return;
              }
              if (answer.resolve != null) {
                if (msg.error != null) {
                  return answer.reject(new Error(msg.error));
                } else {
                  return answer.resolve(msg.data);
                }
              } else {
                if (msg.error != null) {
                  return answer(new Error(msg.error));
                } else {
                  return answer(void 0, msg.data);
                }
              }
              break;
            case 'invite_incoming':
              if ((msg.handle == null) || (msg.sender == null) || !msg.room || (msg.status == null) || (msg.peers == null) || (msg.data == null)) {
                console.log("Invalid message");
                return;
              }
              invitation = new CallingInInvitation(_this, msg.handle);
              room = new CallingInvitationRoom(invitation, _this.room_options, msg.sender, msg.data);
              room.signaling.init(msg);
              return _this.emit('invitation', room);
          }
        };
      })(this));
      this.channel.on('closed', (function(_this) {
        return function() {
          _this.emit('closed');
          if (_this.ping_interval) {
            clearInterval(_this.ping_interval);
            return delete _this.ping_interval;
          }
        };
      })(this));
    }

    Calling.prototype.connect = function() {
      return this.channel.connect().then((function(_this) {
        return function() {
          _this.resetPing();
          return _this.hello_p;
        };
      })(this));
    };

    Calling.prototype.request = function(msg, cb) {
      var defer;
      msg.tid = this.next_tid++;
      this.channel.send(msg);
      this.resetPing();
      if (cb != null) {
        this.answers[msg.tid] = cb;
      } else {
        defer = new Deferred();
        this.answers[msg.tid] = defer;
        return defer.promise;
      }
    };

    Calling.prototype.ping = function() {
      return this.request({
        type: 'ping'
      });
    };

    Calling.prototype.resetPing = function() {
      if (this.ping_timeout) {
        clearTimeout(this.ping_timeout);
      }
      return this.ping_timeout = setTimeout((function(_this) {
        return function() {
          _this.ping();
          return _this.resetPing();
        };
      })(this), 2 * 60 * 1000);
    };

    Calling.prototype.subscribe = function(nsid) {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          return _this.request({
            type: 'ns_subscribe',
            namespace: nsid
          }, function(err, data) {
            var id, namespace, ref1, ref2, room, status;
            if (err != null) {
              return reject(err);
            } else {
              namespace = new CallingNamespace(_this, nsid);
              ref1 = data.users;
              for (id in ref1) {
                status = ref1[id];
                namespace.addUser(id, status);
              }
              ref2 = data.rooms;
              for (id in ref2) {
                room = ref2[id];
                namespace.addRoom(id, room.status, room.peers);
              }
              return resolve(namespace);
            }
          });
        };
      })(this));
    };

    Calling.prototype.register = function(namespace) {
      return this.request({
        type: 'ns_user_register',
        namespace: namespace
      });
    };

    Calling.prototype.unregister = function(namespace) {
      return this.request({
        type: 'ns_user_unregister',
        namespace: namespace
      });
    };

    Calling.prototype.room = function(room, options) {
      var signaling;
      signaling = this.room_signaling(room);
      return new CallingRoom(signaling, options || this.room_options);
    };

    Calling.prototype.room_signaling = function(room) {
      return new CallingSignaling(this, (function(_this) {
        return function(status, cb) {
          return _this.request({
            type: 'room_join',
            room: room,
            status: status
          }, cb);
        };
      })(this));
    };

    Calling.prototype.setStatus = function(status) {
      return this.request({
        type: 'status',
        status: status
      });
    };

    Calling.prototype.close = function() {
      return this.channel.close();
    };

    return Calling;

  })(EventEmitter);

  CallingNamespace = (function(superClass) {
    extend1(CallingNamespace, superClass);

    function CallingNamespace(calling, id1) {
      var message_handler;
      this.calling = calling;
      this.id = id1;
      this.users = {};
      this.rooms = {};
      message_handler = (function(_this) {
        return function(msg) {
          var peer, room, user;
          if (msg.namespace !== _this.id) {
            return;
          }
          switch (msg.type) {
            case 'ns_user_add':
              if ((msg.user == null) || (msg.status == null)) {
                console.log('Invalid message');
                return;
              }
              return _this.addUser(msg.user, msg.status);
            case 'ns_user_update':
              if ((msg.user == null) || (msg.status == null)) {
                console.log('Invalid message');
                return;
              }
              user = _this.users[msg.user];
              if (user == null) {
                console.log('Unknown user in status change');
                return;
              }
              user.status = msg.status;
              _this.emit('user_changed', user);
              _this.emit('user_status_changed', user, user.status);
              return user.emit('status_changed', user.status);
            case 'ns_user_rm':
              if (msg.user == null) {
                console.log('Invalid message');
                return;
              }
              user = _this.users[msg.user];
              if (user == null) {
                console.log('Unknown user leaving');
                return;
              }
              delete _this.users[msg.user];
              _this.emit('user_changed', user);
              _this.emit('user_left', user);
              return user.emit('left');
            case 'ns_room_add':
              if ((msg.room == null) || (msg.status == null) || (msg.peers == null)) {
                console.log('Invalid message');
                return;
              }
              return _this.addRoom(msg.room, msg.status, msg.peers);
            case 'ns_room_update':
              if ((msg.room == null) || (msg.status == null)) {
                console.log('Invalid message');
                return;
              }
              room = _this.rooms[msg.room];
              if (room == null) {
                console.log('Invalid room');
                return;
              }
              room.status = msg.status;
              _this.emit('room_changed', room);
              _this.emit('room_status_changed', room, room.status);
              return room.emit('status_changed', room.status);
            case 'ns_room_rm':
              if (msg.room == null) {
                console.log('Invalid message');
                return;
              }
              room = _this.rooms[msg.room];
              if (room == null) {
                console.log('Invalid room');
                return;
              }
              delete _this.rooms[msg.room];
              _this.emit('room_changed', room);
              _this.emit('room_closed');
              return room.emit('closed');
            case 'ns_room_peer_add':
              if ((msg.room == null) || (msg.user == null) || (msg.status == null) || (msg.pending == null)) {
                console.log('Invalid message');
                return;
              }
              room = _this.rooms[msg.room];
              if (room == null) {
                console.log('Invalid room');
                return;
              }
              peer = room.addPeer(msg.user, msg.status, msg.pending);
              _this.emit('room_changed', room);
              return _this.emit('room_peer_joined', room, peer);
            case 'ns_room_peer_update':
              if ((msg.room == null) || (msg.user == null)) {
                console.log('Invalid message');
                return;
              }
              room = _this.rooms[msg.room];
              peer = room != null ? room.peers[msg.user] : void 0;
              if (peer == null) {
                console.log('Invalid peer');
                return;
              }
              if (msg.status != null) {
                peer.status = msg.status;
                _this.emit('room_changed', room);
                _this.emit('room_peer_status_changed', room, peer, peer.status);
                peer.emit('status_changed', peer.status);
              }
              if ((msg.pending != null) && msg.pending === false) {
                peer.pending = false;
                peer.accepted_d.resolve();
                _this.emit('room_changed', room);
                _this.emit('peer_accepted', peer);
                return peer.emit('accepted');
              }
              break;
            case 'ns_room_peer_rm':
              if ((msg.room == null) || (msg.user == null)) {
                console.log('Invalid message');
                return;
              }
              room = _this.rooms[msg.room];
              peer = room != null ? room.peers[msg.user] : void 0;
              if (peer == null) {
                console.log('Invalid peer');
                return;
              }
              delete _this.rooms[msg.room].peers[msg.user];
              _this.emit('room_changed', room);
              _this.emit('room_peer_left', room, peer);
              return peer.emit('left');
          }
        };
      })(this);
      this.calling.channel.on('message', message_handler);
      this.on('unsubscribed', (function(_this) {
        return function() {
          return _this.calling.channel.removeListener('message', message_handler);
        };
      })(this));
    }

    CallingNamespace.prototype.addUser = function(id, status) {
      var user;
      user = new CallingNamespaceUser(id, status);
      this.users[id] = user;
      this.emit('user_changed', user);
      this.emit('user_registered', user);
      return user;
    };

    CallingNamespace.prototype.addRoom = function(id, status, peers) {
      var peer, peer_id, room;
      room = new CallingNamespaceRoom(id, status);
      for (peer_id in peers) {
        peer = peers[peer_id];
        room.addPeer(peer_id, peer.status, peer.pending);
      }
      this.rooms[id] = room;
      this.emit('room_changed', room);
      this.emit('room_registered', room);
      return room;
    };

    CallingNamespace.prototype.unsubscribe = function() {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          return _this.calling.request({
            type: 'ns_unsubscribe',
            namespace: _this.id
          }, function(err) {
            var _, ref1, user;
            if (err != null) {
              return reject(err);
            } else {
              ref1 = _this.users;
              for (_ in ref1) {
                user = ref1[_];
                user.emit('left');
              }
              _this.users = {};
              _this.emit('unsubscribed');
              return resolve();
            }
          });
        };
      })(this));
    };

    return CallingNamespace;

  })(EventEmitter);

  CallingNamespaceUser = (function(superClass) {
    extend1(CallingNamespaceUser, superClass);

    function CallingNamespaceUser(id1, status1, pending1) {
      this.id = id1;
      this.status = status1;
      this.pending = pending1;
    }

    return CallingNamespaceUser;

  })(EventEmitter);

  CallingNamespaceRoom = (function(superClass) {
    extend1(CallingNamespaceRoom, superClass);

    function CallingNamespaceRoom(id1, status1) {
      this.id = id1;
      this.status = status1;
      this.peers = {};
    }

    CallingNamespaceRoom.prototype.addPeer = function(id, status, pending) {
      var peer;
      peer = new CallingNamespaceRoomPeer(id, status, pending);
      this.peers[id] = peer;
      this.emit('peer_joined', peer);
      return peer;
    };

    return CallingNamespaceRoom;

  })(EventEmitter);

  CallingNamespaceRoomPeer = (function(superClass) {
    extend1(CallingNamespaceRoomPeer, superClass);

    function CallingNamespaceRoomPeer(id1, status1, pending1) {
      this.id = id1;
      this.status = status1;
      this.pending = pending1;
      this.accepted_d = new Deferred();
      if (!this.pending) {
        this.accepted_d.resolve();
      }
      this.on('left', (function(_this) {
        return function() {
          return _this.accepted_d.reject("Peer left");
        };
      })(this));
    }

    CallingNamespaceRoomPeer.prototype.accepted = function() {
      return this.accepted_d.promise;
    };

    return CallingNamespaceRoomPeer;

  })(EventEmitter);

  CallingSignaling = (function(superClass) {
    extend1(CallingSignaling, superClass);

    function CallingSignaling(calling, connect_fun) {
      var message_handler;
      this.calling = calling;
      this.connect_fun = connect_fun;
      this.peer_status = {};
      this.peers = {};
      this.initialized = false;
      message_handler = (function(_this) {
        return function(msg) {
          var peer;
          if (msg.room !== _this.id) {
            return;
          }
          switch (msg.type) {
            case 'room_update':
              if (msg.status == null) {
                console.log("Invalid message");
                return;
              }
              _this.status = msg.status;
              return _this.emit('status_changed', _this.status);
            case 'room_peer_add':
              if ((msg.user == null) || (msg.pending == null) || (msg.status == null)) {
                console.log("Invalid message");
                return;
              }
              return _this.addPeer(msg.user, msg.status, msg.pending, true);
            case 'room_peer_rm':
              console.log('removing');
              if (msg.user == null) {
                console.log("Invalid message");
                return;
              }
              peer = _this.peers[msg.user];
              if (peer == null) {
                console.log("Unknown peer accepted");
                return;
              }
              delete _this.peers[msg.user];
              peer.accepted_d.reject("User left");
              console.log('removed', _this.peers);
              _this.emit('peer_left', peer);
              return peer.emit('left');
            case 'room_peer_update':
              if (msg.user == null) {
                console.log("Invalid message");
                return;
              }
              peer = _this.peers[msg.user];
              if (peer == null) {
                console.log("Unknown peer accepted");
                return;
              }
              if (msg.status != null) {
                peer.status = msg.status;
                _this.emit('peer_status_changed', peer, peer.status);
                peer.emit('status_changed', peer.status);
              }
              if ((msg.pending != null) && msg.pending === false) {
                peer.pending = false;
                peer.accepted_d.resolve();
                _this.emit('peer_accepted');
                return peer.emit('accepted');
              }
              break;
            case 'room_peer_from':
              if ((msg.user == null) || (msg.event == null)) {
                console.log("Invalid message", msg);
                return;
              }
              peer = _this.peers[msg.user];
              if (peer == null) {
                console.log("Unknown peer accepted");
                return;
              }
              _this.emit('peer_left');
              return peer.emit(msg.event, msg.data);
          }
        };
      })(this);
      this.calling.channel.on('message', message_handler);
      this.on('left', (function(_this) {
        return function() {
          return _this.calling.channel.removeListener('message', message_handler);
        };
      })(this));
    }

    CallingSignaling.prototype.init = function(data) {
      var entry, ref1, user;
      if (this.initialized) {
        throw new Error("Room is already initialized");
      }
      if ((data.room == null) || (data.peers == null) || (data.status == null)) {
        console.log(data);
        throw new Error("Invalid initialization data");
      }
      this.id = data.room;
      this.status = data.status;
      ref1 = data.peers;
      for (user in ref1) {
        entry = ref1[user];
        this.addPeer(user, entry.status, entry.pending, false);
      }
      return this.initialized = true;
    };

    CallingSignaling.prototype.connect = function() {
      if (this.connect_p == null) {
        this.connect_p = new Promise((function(_this) {
          return function(resolve, reject) {
            return _this.connect_fun(_this.peer_status, function(err, res) {
              if (err != null) {
                return reject(err);
              } else {
                if (res != null) {
                  _this.init(res);
                }
                if (!_this.initialized) {
                  reject(new Error("Missing information from connect response"));
                  return;
                }
                return resolve();
              }
            });
          };
        })(this));
      }
      return this.connect_p;
    };

    CallingSignaling.prototype.addPeer = function(id, status, pending, first) {
      var peer;
      peer = new CallingSignalingPeer(this, id, status, pending, first);
      this.peers[id] = peer;
      this.emit('peer_joined', peer);
      return peer;
    };

    CallingSignaling.prototype.leave = function() {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          return _this.calling.request({
            type: 'room_leave',
            room: _this.id
          }, function(err) {
            var _, peer, ref1;
            _this.emit('left');
            ref1 = _this.peers;
            for (_ in ref1) {
              peer = ref1[_];
              peer.emit('left');
              peer.accepted_d.reject("You left the room");
            }
            return resolve();
          });
        };
      })(this));
    };

    CallingSignaling.prototype.setStatus = function(status) {
      this.peer_status = status;
      if (this.connect_p != null) {
        return this.calling.request({
          type: 'room_peer_status',
          room: this.id,
          status: status
        });
      } else {
        return Promise.resolve();
      }
    };

    CallingSignaling.prototype.invite = function(user, data) {
      if (data == null) {
        data = {};
      }
      return new Promise((function(_this) {
        return function(resolve, reject) {
          return _this.calling.request({
            type: 'invite_send',
            room: _this.id,
            user: user.id,
            data: data
          }, function(err, res) {
            var invitation;
            if (err != null) {
              return reject(err);
            } else {
              if (res.handle == null) {
                reject(new Error("Invalid response"));
                return;
              }
              invitation = new CallingOutInvitation(_this.calling, res.handle, user);
              return resolve(invitation);
            }
          });
        };
      })(this));
    };

    CallingSignaling.prototype.setRoomStatusSafe = function(key, value, previous) {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          return _this.calling.request({
            type: 'room_status',
            room: _this.id,
            key: key,
            value: value,
            check: true,
            previous: previous
          }, function(err) {
            if (err) {
              reject(err);
              return;
            }
            _this.status[key] = value;
            _this.emit('status_changed', _this.status);
            return resolve();
          });
        };
      })(this));
    };

    CallingSignaling.prototype.setRoomStatus = function(key, value) {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          return _this.calling.request({
            type: 'room_status',
            room: _this.id,
            key: key,
            value: value
          }, function(err) {
            if (err) {
              reject(err);
              return;
            }
            _this.status[key] = value;
            _this.emit('status_changed', _this.status);
            return resolve();
          });
        };
      })(this));
    };

    CallingSignaling.prototype.register = function(namespace) {
      return this.calling.request({
        type: 'ns_room_register',
        namespace: namespace,
        room: this.id
      });
    };

    CallingSignaling.prototype.unregister = function(namespace) {
      return this.calling.request({
        type: 'ns_room_unregister',
        namespace: namespace,
        room: this.id
      });
    };

    return CallingSignaling;

  })(EventEmitter);

  CallingSignalingPeer = (function(superClass) {
    extend1(CallingSignalingPeer, superClass);

    function CallingSignalingPeer(room1, id1, status1, pending1, first1) {
      this.room = room1;
      this.id = id1;
      this.status = status1;
      this.pending = pending1;
      this.first = first1;
      this.accepted_d = new Deferred();
      if (!this.pending) {
        this.accepted_d.resolve();
      }
      return;
    }

    CallingSignalingPeer.prototype.accepted = function() {
      return this.accepted_d.promise;
    };

    CallingSignalingPeer.prototype.send = function(event, data) {
      return this.room.calling.request({
        type: 'room_peer_to',
        room: this.room.id,
        user: this.id,
        event: event,
        data: data
      });
    };

    return CallingSignalingPeer;

  })(EventEmitter);

  CallingInInvitation = (function(superClass) {
    extend1(CallingInInvitation, superClass);

    function CallingInInvitation(calling, handle, sender, data1) {
      var message_handler;
      this.calling = calling;
      this.handle = handle;
      this.sender = sender;
      this.data = data1;
      this.cancelled = false;
      message_handler = (function(_this) {
        return function(msg) {
          if (msg.handle !== _this.handle) {
            return;
          }
          switch (msg.type) {
            case 'invite_cancelled':
              _this.cancelled = true;
              _this.emit('cancelled');
              return _this.emit('handled', false);
          }
        };
      })(this);
      this.calling.channel.on('message', message_handler);
      this.on('handled', (function(_this) {
        return function() {
          return _this.calling.channel.removeListener('message', message_handler);
        };
      })(this));
      return;
    }

    CallingInInvitation.prototype.signaling = function() {
      return new CallingSignaling(this.calling, (function(_this) {
        return function(status, cb) {
          _this.emit('handled', true);
          return _this.calling.request({
            type: 'invite_accept',
            handle: _this.handle,
            status: status
          }, cb);
        };
      })(this));
    };

    CallingInInvitation.prototype.deny = function() {
      this.emit('handled', false);
      return this.calling.request({
        type: 'invite_deny',
        handle: this.handle
      });
    };

    return CallingInInvitation;

  })(EventEmitter);

  CallingOutInvitation = (function() {
    function CallingOutInvitation(calling, handle, user1) {
      var cleanup, message_handler;
      this.calling = calling;
      this.handle = handle;
      this.user = user1;
      this.defer = new Deferred();
      this.pending = true;
      message_handler = (function(_this) {
        return function(msg) {
          if (msg.handle !== _this.handle) {
            return;
          }
          switch (msg.type) {
            case 'invite_response':
              if (msg.accepted == null) {
                console.log("Invalid message");
                return;
              }
              _this.pending = false;
              return _this.defer.resolve(msg.accepted);
          }
        };
      })(this);
      this.calling.channel.on('message', message_handler);
      cleanup = (function(_this) {
        return function() {
          return _this.calling.channel.removeListener('message', message_handler);
        };
      })(this);
      this.defer.promise.then(cleanup, cleanup);
      return;
    }

    CallingOutInvitation.prototype.response = function() {
      return this.defer.promise;
    };

    CallingOutInvitation.prototype.cancel = function() {
      this.pending = false;
      return this.calling.request({
        type: 'invite_cancel',
        handle: this.handle
      }).then((function(_this) {
        return function() {
          _this.defer.reject(new Error("Invitation cancelled"));
        };
      })(this));
    };

    return CallingOutInvitation;

  })();

  CallingRoom = (function(superClass) {
    extend1(CallingRoom, superClass);

    function CallingRoom(signaling, options) {
      options = extend({
        auto_connect: false
      }, options);
      CallingRoom.__super__.constructor.call(this, signaling, options);
    }

    CallingRoom.prototype.createPeer = function(pc, signaling) {
      return new CallingPeer(pc, signaling, this.local, this.options);
    };

    CallingRoom.prototype.invite = function(user) {
      return this.signaling.invite(user);
    };

    CallingRoom.prototype.register = function(nsid) {
      return this.signaling.register(nsid);
    };

    CallingRoom.prototype.unregister = function(nsid) {
      return this.signaling.unregister(nsid);
    };

    return CallingRoom;

  })(Room);

  CallingInvitationRoom = (function(superClass) {
    extend1(CallingInvitationRoom, superClass);

    function CallingInvitationRoom(invitation1, options, sender_id, data1) {
      this.invitation = invitation1;
      this.sender_id = sender_id;
      this.data = data1;
      CallingInvitationRoom.__super__.constructor.call(this, this.invitation.signaling(), options);
      this.invitation.on('cancelled', (function(_this) {
        return function() {
          return _this.emit('cancelled');
        };
      })(this));
      this.invitation.on('handled', (function(_this) {
        return function(accepted) {
          return _this.emit('handled', accepted);
        };
      })(this));
    }

    CallingInvitationRoom.prototype.sender = function() {
      return this.peers[this.sender_id];
    };

    CallingInvitationRoom.prototype.deny = function() {
      return this.invitation.deny();
    };

    return CallingInvitationRoom;

  })(CallingRoom);

  CallingPeer = (function(superClass) {
    extend1(CallingPeer, superClass);

    function CallingPeer(pc, signaling, local, options) {
      CallingPeer.__super__.constructor.call(this, pc, signaling, local, options);
    }

    CallingPeer.prototype.connect = function() {
      return this.signaling.accepted().then((function(_this) {
        return function() {
          return CallingPeer.__super__.connect.call(_this);
        };
      })(this));
    };

    return CallingPeer;

  })(RemotePeer);

  module.exports = {
    Calling: Calling,
    CallingNamespace: CallingNamespace,
    CallingNamespaceUser: CallingNamespaceUser,
    CallingNamespaceRoom: CallingNamespaceRoom,
    CallingNamespaceRoomPeer: CallingNamespaceRoomPeer,
    CallingSignaling: CallingSignaling,
    CallingSignalingPeer: CallingSignalingPeer,
    CallingInInvitation: CallingInInvitation,
    CallingOutInvitation: CallingOutInvitation
  };

}).call(this);

},{"../internal/promise":4,"../remote_peer":10,"../room":11,"events":undefined,"extend":undefined}],13:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var Deferred, EventEmitter, Signaling, SignalingPeer, ref,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Deferred = require('../internal/promise').Deferred;

  ref = require('./signaling'), Signaling = ref.Signaling, SignalingPeer = ref.SignalingPeer;

  EventEmitter = require('events').EventEmitter;


  /**
   * @module rtc.signaling
   */


  /**
   * Signaling peer for multi user chats.
  #
   * For a detailed description of the signaling protocol see `rtc.signaling.MucSignaling`
  #
   * @extends rtc.signaling.SignalingPeer
   * @class rtc.signaling.MucSignalingPeer
  #
   * @constructor
   * @param {rtc.signaling.Channel} channel The channel to the siganling server
   * @param {String} peer_id The id of the remote peer
   * @param {Object} status The status of the remote peer
   * @param {Boolean} first Whether the local peer was in the room before the remote peer
   */

  exports.MucSignalingPeer = (function(superClass) {
    extend(MucSignalingPeer, superClass);


    /**
     * The id of the remote peer
     * @property id
     * @type String
     */

    function MucSignalingPeer(channel, id, status1, first) {
      var recv_msg;
      this.channel = channel;
      this.id = id;
      this.status = status1;
      this.first = first;
      recv_msg = (function(_this) {
        return function(data) {
          if (data.peer !== _this.id) {
            return;
          }
          if (data.type == null) {
            return;
          }
          switch (data.type) {
            case 'from':
              if ((data.event == null) || (data.data == null)) {
                return;
              }
              return _this.emit(data.event, data.data);
            case 'peer_left':
              _this.emit('left');
              return _this.channel.removeListener('message', recv_msg);
            case 'peer_status':
              _this.status = data.status;
              return _this.emit('status_changed', _this.status);
          }
        };
      })(this);
      this.channel.on('message', recv_msg);
    }

    MucSignalingPeer.prototype.send = function(event, data) {
      if (data == null) {
        data = {};
      }
      return this.channel.send({
        type: 'to',
        peer: this.id,
        event: event,
        data: data
      });
    };

    return MucSignalingPeer;

  })(SignalingPeer);


  /**
   * Signaling for multi user chats
  #
   * The following messages are sent to the server:
  #
   *     // join the room. has to be sent before any other message.
   *     // response will be 'joined' on success
   *     // other peers in the room will get 'peer_joined'
   *     {
   *       "type": "join",
   *       "status": { .. status .. }
   *     }
  #
   *     // leave the room. server will close the connectino.
   *     {
   *       "type": "leave"
   *     }
  #
   *     // update status object
   *     // other peers will get 'peer_status'
   *     {
   *       "type": "status",
   *       "status": { .. status .. }
   *     }
  #
   *     // send message to a peer. will be received as 'from'
   *     {
   *       "type": "to",
   *       "peer": "peer_id",
   *       "event": "event_id",
   *       "data": { .. custom data .. }
   *     }
  #
   * The following messages are received form the server:
  #
   *     // joined the room. is the response to 'join'
   *     {
   *       "type": "joined",
   *       "id": "own_id",
   *       "peers": {
   *         "peer_id": { .. status .. }
   *       }
   *     }
  #
   *     // another peer joined the room.
   *     {
   *       "type": "peer_joined",
   *       "peer": "peer_id",
   *       "status": { .. status .. }
   *     }
  #
   *     // anosther peer updated its status object using 'status'
   *     {
   *       "type": "peer_status",
   *       "peer": "peer_id",
   *       "status": { .. status .. }
   *     }
  #
   *     // another peer left the room
   *     {
   *       "type": "peer_left",
   *       "peer": "peer_id"
   *     }
  #
   *     // message from another peer sent by 'to'
   *     {
   *       "type": "from",
   *       "peer": "peer_id",
   *       "event": "event_id",
   *       "data": { .. custom data .. }
   *     }
  #
   * The messages transmitted in the `to`/`from` messages are emitted as events in `MucSignalingPeer`
  #
   * @extends rtc.signaling.Signaling
   * @class rtc.signaling.MucSignaling
  #
   * @constructor
   * @param {rtc.signaling.Channel} channel The channel to the signaling server
   */

  exports.MucSignaling = (function(superClass) {
    extend(MucSignaling, superClass);


    /**
     * The id of the local peer. Only available after joining.
     * @property id
     * @type String
     */

    function MucSignaling(channel) {
      var join_d;
      this.channel = channel;
      this.status = {};
      join_d = new Deferred();
      this.join_p = join_d.promise;
      this.channel.on('closed', (function(_this) {
        return function() {
          return _this.emit('closed');
        };
      })(this));
      this.channel.on('message', (function(_this) {
        return function(data) {
          var peer, peer_id, ref1, status;
          if (data.type == null) {
            return;
          }
          switch (data.type) {
            case 'joined':
              if (data.peers == null) {
                return;
              }
              ref1 = data.peers;
              for (peer_id in ref1) {
                status = ref1[peer_id];
                peer = new exports.MucSignalingPeer(_this.channel, peer_id, status, false);
                _this.emit('peer_joined', peer);
              }
              _this.id = data.id;
              return join_d.resolve();
            case 'peer_joined':
              if (data.peer == null) {
                return;
              }
              peer = new exports.MucSignalingPeer(_this.channel, data.peer, data.status, true);
              return _this.emit('peer_joined', peer);
          }
        };
      })(this));
    }

    MucSignaling.prototype.connect = function() {
      if (this.connect_p == null) {
        this.connect_p = this.channel.connect().then((function(_this) {
          return function() {
            return _this.channel.send({
              type: 'join',
              status: _this.status
            });
          };
        })(this)).then((function(_this) {
          return function() {
            return _this.join_d;
          };
        })(this));
      }
      return this.connect_p;
    };

    MucSignaling.prototype.setStatus = function(status) {
      this.status = status;
      if (this.connect_p) {
        return this.connect_p.then((function(_this) {
          return function() {
            return _this.channel.send({
              type: 'status',
              status: status
            });
          };
        })(this));
      }
    };

    MucSignaling.prototype.leave = function() {
      return this.channel.send({
        type: 'leave'
      }).then(function() {
        return this.channel.close();
      });
    };

    return MucSignaling;

  })(Signaling);

}).call(this);

},{"../internal/promise":4,"./signaling":15,"events":undefined}],14:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var Deferred, Signaling, SignalingPeer, ref,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Deferred = require('../internal/promise').Deferred;

  ref = require('./signaling'), Signaling = ref.Signaling, SignalingPeer = ref.SignalingPeer;


  /**
   * @module rtc.signaling
   */


  /**
   * Signaling peer compatible with the framing of palava signaling
   * @class rtc.signaling.PalavaSignalingPeer
   * @extends rtc.signaling.SignalingPeer
   */

  exports.PalavaSignalingPeer = (function(superClass) {
    extend(PalavaSignalingPeer, superClass);

    function PalavaSignalingPeer(channel, id, status1, first) {
      var recv_msg;
      this.channel = channel;
      this.id = id;
      this.status = status1;
      this.first = first;
      recv_msg = (function(_this) {
        return function(data) {
          if (data.sender_id !== _this.id) {
            return;
          }
          if (data.event == null) {
            _this.send('error', "Invalid message");
            return;
          }
          return _this.emit(data.event, data.data);
        };
      })(this);
      this.channel.on('message', recv_msg);
      this.on('peer_updated_status', (function(_this) {
        return function(status) {
          return _this.emit('status_changed', status);
        };
      })(this));
      this.on('peer_left', (function(_this) {
        return function() {
          _this.emit('closed');
          return _this.channel.removeListener('message', recv_msg);
        };
      })(this));
    }

    PalavaSignalingPeer.prototype.send = function(event, data) {
      if (data == null) {
        data = {};
      }
      return this.channel.send({
        event: 'send_to_peer',
        peer_id: this.id,
        data: {
          event: event,
          data: data
        }
      });
    };

    return PalavaSignalingPeer;

  })(SignalingPeer);


  /**
   * Signaling implementation compatible with the framing of palava signaling
   * @class rtc.signaling.PalavaSignaling
   * @extends rtc.signaling.Signaling
   */

  exports.PalavaSignaling = (function(superClass) {
    extend(PalavaSignaling, superClass);

    function PalavaSignaling(channel, room1, status1) {
      var join_d;
      this.channel = channel;
      this.room = room1;
      this.status = status1;
      this.peers = {};
      this.joined = false;
      join_d = new Deferred();
      this.join_p = join_d.promise;
      this.channel.on('closed', (function(_this) {
        return function() {
          return _this.emit('closed');
        };
      })(this));
      this.channel.on('message', (function(_this) {
        return function(data) {
          var i, peer, ref1;
          if (data.event == null) {
            return;
          }
          switch (data.event) {
            case 'joined_room':
              if ((data.peers == null) || (data.own_id == null)) {
                return;
              }
              ref1 = data.peers;
              for (i in ref1) {
                data = ref1[i];
                peer = new exports.PalavaSignalingPeer(_this.channel, data.peer_id, data.status, false);
                _this.peers[data.peer_id] = peer;
                _this.emit('peer_joined', peer);
              }
              return join_d.resolve();
            case 'new_peer':
              if (data.peer_id == null) {
                return;
              }
              peer = new exports.PalavaSignalingPeer(_this.channel, data.peer_id, data.status, true);
              _this.peers[data.peer] = peer;
              return _this.emit('peer_joined', peer);
          }
        };
      })(this));
    }

    PalavaSignaling.prototype.connect = function() {
      if (this.connect_p == null) {
        this.connect_p = this.channel.connect().then((function(_this) {
          return function() {
            return _this.channel.send({
              event: 'join_room',
              room_id: room,
              status: status
            });
          };
        })(this));
      }
      return this.connect_p;
    };

    PalavaSignaling.prototype.set_status = function(status) {
      return this.channel.send({
        event: 'update_status',
        status: status
      });
    };

    PalavaSignaling.prototype.leave = function() {
      return this.channel.close();
    };

    return PalavaSignaling;

  })(Signaling);

}).call(this);

},{"../internal/promise":4,"./signaling":15}],15:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var EventEmitter,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  EventEmitter = require('events').EventEmitter;


  /**
   * @module rtc.signaling
   */


  /**
   * Concept of a class implementing signaling. Might use a `rtc.signaling.Channel` to abstract the connection to the server.
  #
   * You do not have to extend this claass, just implement the functionality.
  #
   * @extends events.EventEmitter
   * @class rtc.signaling.Signaling
   */

  exports.Signaling = (function(superClass) {
    extend(Signaling, superClass);

    function Signaling() {
      return Signaling.__super__.constructor.apply(this, arguments);
    }


    /**
     * A new peer joined the room
     * @event peer_joined
     * @param {rtc.signaling.SignalingPeer} peer The new peer
     */


    /**
     * The connection to the signaling server was closed
     * @event closed
     */


    /**
     * Establishes the connection with the signaling server
     * @method connect
     * @return {Promise} Promise which is resolved when the connection is established
     */

    Signaling.prototype.connect = function() {
      throw new Error("Not implemented");
    };


    /**
     * Closes the connection to the signaling server
     * @method close
     */

    Signaling.prototype.close = function() {
      throw new Error("Not implemented");
    };


    /**
     * Sets the local status object and broadcasts the change to the peers
     * @method setStatus
     * @param {Object} obj New status object
     */

    Signaling.prototype.setStatus = function(obj) {
      throw new Error("Not implemented");
    };

    return Signaling;

  })(EventEmitter);


  /**
   * Concept of a class implementing a signaling connection to a peer.
  #
   * You do not have to extend this class, just implement the functionality.
  #
   * @extends events.EventEmitter
   * @class rtc.signaling.SignalingPeer
   */

  exports.SignalingPeer = (function(superClass) {
    extend(SignalingPeer, superClass);

    function SignalingPeer() {
      return SignalingPeer.__super__.constructor.apply(this, arguments);
    }


    /**
     * The remote peer left the room
     * @event left
     */


    /**
     * Received a message from the remote peer
     * @event message
     * @param {String} event ID of the event
     * @param {Obejct} data Payload of the event
     */


    /**
     * The status object of the remote peer was updated
     * @event status_changed
     * @param {Object} status The new status
     */


    /**
     * The status object of the remote peer
     * @property status
     * @type Object
     * @readonly
     */


    /**
     * Whether the local user was in the room before the remote user (used to determine which peer will initiate the connection)
     * @property first
     * @type Boolean
     * @readonly
     */


    /**
     * Sends the event with the given payload to the remote peer
     * @method send
     * @param {String} event The id of the event
     * @param {Object} data The payload of the event
     * @return {Promise} Promise which will be resolved once the message is sent
     */

    SignalingPeer.prototype.send = function(event, data) {
      if (data == null) {
        data = {};
      }
      throw new Error("Not implemented");
    };

    return SignalingPeer;

  })(EventEmitter);


  /**
   * Concept of a class implementing a signaling channel. Might be used by signaling implementations to connect to a signaling server.
  #
   * You do not have to extend this class, just implement the functionality.
  #
   * @extends events.EventEmitter
   * @class rtc.signaling.Channel
   */

  exports.Channel = (function(superClass) {
    extend(Channel, superClass);

    function Channel() {
      return Channel.__super__.constructor.apply(this, arguments);
    }


    /**
     * A message was received from the signaling server
     * @event message
     * @param {Object} msg The received message
     */


    /**
     * The connection to the signaling server was closed
     * @event closed
     */


    /**
     * Establishes the connection with the signaling server
     * @method connect
     * @return {Promise} Promise which is resolved when the connection is established
     */

    Channel.prototype.connect = function() {
      throw new Error("Not implemented");
    };


    /**
     * Sends a message to the signaling server
     * @method send
     * @param {Object} msg The message to send
     * @return {Promise} Promise which is resolved when the message is sent
     */

    Channel.prototype.send = function(msg) {
      throw new Error("Not implemented");
    };


    /**
     * Closes the connection to the signaling server
     * @method close
     */

    Channel.prototype.close = function() {
      throw new Error("Not implemented");
    };

    return Channel;

  })(EventEmitter);

}).call(this);

},{"events":undefined}],16:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var Channel, Promise,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  Promise = require('../internal/promise').Promise;

  Channel = require('./signaling').Channel;


  /**
   * @module rtc.signaling
   */


  /**
   * @class rtc.signaling.WebSocketChannel
   * @extends rtc.signaling.Channel
   */

  exports.WebSocketChannel = (function(superClass) {
    extend(WebSocketChannel, superClass);

    function WebSocketChannel() {
      var address, i, len, part, parts;
      address = arguments[0], parts = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      this.address = address;
      if (parts.length > 0) {
        while (this.address.endsWith('/')) {
          this.address = this.address.substr(0, this.address.length - 1);
        }
        for (i = 0, len = parts.length; i < len; i++) {
          part = parts[i];
          this.address += '/' + encodeUriComponent(part);
        }
      }
    }

    WebSocketChannel.prototype.connect = function() {
      if (this.connect_p == null) {
        this.connect_p = new Promise((function(_this) {
          return function(resolve, reject) {
            var socket;
            socket = new WebSocket(_this.address);
            socket.onopen = function() {
              _this.socket = socket;
              return resolve();
            };
            socket.onerror = function(err) {
              delete _this.socket;
              _this.emit('error', err);
              return reject(new Error("Unable to connect to socket"));
            };
            socket.onmessage = function(event) {
              var data;
              try {
                data = JSON.parse(event.data);
              } catch (_error) {
                _this.emit('error', "Unable to parse incoming message");
                return;
              }
              return _this.emit('message', data);
            };
            return socket.onclose = function() {
              return _this.emit('closed');
            };
          };
        })(this));
      }
      return this.connect_p;
    };

    WebSocketChannel.prototype.send = function(msg) {
      var err;
      if (this.socket != null) {
        try {
          this.socket.send(JSON.stringify(msg));
          return Promise.resolve();
        } catch (_error) {
          err = _error;
          return Promise.reject(err);
        }
      } else {
        return Promise.reject(new Error("Trying to send on WebSocket without being connected"));
      }
    };

    WebSocketChannel.prototype.close = function() {
      var err;
      if (this.socket != null) {
        try {
          this.socket.close();
          return Promise.resolve();
        } catch (_error) {
          err = _error;
          return Promise.reject(err);
        }
      } else {
        return Promise.reject(new Error("Trying to close WebSocket without being connected"));
      }
    };

    return WebSocketChannel;

  })(Channel);

}).call(this);

},{"../internal/promise":4,"./signaling":15}],17:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var EventEmitter, compat,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  compat = require('./compat').compat;

  EventEmitter = require('events').EventEmitter;


  /**
   * @module rtc
   */


  /**
   * A wrapper around an HTML5 MediaStream
   * @class rtc.Stream
  #
   * @constructor
   * @param {RTCDataStream} stream The native stream
   */

  exports.Stream = (function(superClass) {
    extend(Stream, superClass);


    /**
     * Emitted when tracks are muted or unmuted. Only triggered when changes are
     * made through this objects mute functions.
     * @event mute_changed
     * @param {'audio' | 'video' | 'both'} type The type of tracks which changed
     * @param {Boolean} muted `true` if tracks were muted, `false` if they were unmuted
     */

    function Stream(stream) {
      this.stream = stream;
    }


    /**
     * Get the id of the stream. This is neither user defined nor human readable.
     * @method id
     * @return {String} The id of the underlying stream
     */

    Stream.prototype.id = function() {
      return this.stream.id;
    };


    /**
     * Checks whether the stream has any tracks of the given type
     * @method hasTracks
     * @param {'audio' | 'video' | 'both'} [type='both'] The type of track to check for
     * @return {Number} The amount of tracks of the given type
     */

    Stream.prototype.hasTracks = function(type) {
      return this.getTracks(type).length;
    };


    /**
     * Gets the tracks of the given type
     * @method getTracks
     * @param {'audio' | 'video' | 'both'} [type='both'] The type of tracks to get
     * @return {Array} An Array of the tracks
     */

    Stream.prototype.getTracks = function(type) {
      var vaudio, video;
      type = type.toLowerCase();
      if (type === 'audio') {
        return this.stream.getAudioTracks();
      } else if (type === 'video') {
        return this.stream.getVideoTracks();
      } else if (type === 'both') {
        video = this.stream.getVideoTracks();
        vaudio = this.stream.getAudioTracks();
        return video.concat(audio);
      } else {
        throw new Error("Invalid stream part '" + type + "'");
      }
    };


    /**
     * Checks whether a type of track is muted. If there are no tracks of the
     * specified type they will be considered muted
     * @param {'audio' | 'video' | 'both'} [type='audio'] The type of tracks
     * @return {Boolean} Whether the tracks are muted
     */

    Stream.prototype.muted = function(type) {
      var ref, tracks;
      if (type == null) {
        type = 'audio';
      }
      tracks = this.getTracks(type);
      if (tracks.length < 1) {
        return true;
      }
      return !((ref = tracks[0]) != null ? ref.enabled : void 0);
    };


    /**
     * Mutes or unmutes tracks of the stream
     * @method mute
     * @param {Boolean} [muted=true] Mute on `true` and unmute on `false`
     * @param {'audio' | 'video' | 'both'} [type='audio'] The type of tracks to mute or unmute
     * @return {Boolean} Whether the tracks were muted or unmuted
     */

    Stream.prototype.mute = function(muted, type) {
      var i, len, ref, track;
      if (muted == null) {
        muted = true;
      }
      if (type == null) {
        type = 'audio';
      }
      ref = this.getTracks(type);
      for (i = 0, len = ref.length; i < len; i++) {
        track = ref[i];
        track.enabled = !muted;
      }
      this.emit('mute_changed', type, muted);
      return muted;
    };


    /**
     * Toggles the mute state of tracks of the stream
     * @method toggleMute
     * @param {'audio' | 'video' | 'both'} [type='audio'] The type of tracks to mute or unmute
     * @return {Boolean} Whether the tracks were muted or unmuted
     */

    Stream.prototype.toggleMute = function(type) {
      var i, len, muted, ref, track, tracks;
      if (type == null) {
        type = 'audio';
      }
      tracks = this.getTracks(type);
      if (tracks.length < 1) {
        return true;
      }
      muted = !((ref = tracks[0]) != null ? ref.enabled : void 0);
      for (i = 0, len = tracks.length; i < len; i++) {
        track = tracks[i];
        track.enabled = !muted;
      }
      this.emit('mute_changed', type, muted);
      return muted;
    };


    /**
     * Stops the stream
     * @method stop
     */

    Stream.prototype.stop = function() {
      var i, len, ref, results, track;
      if (this.stream.getTracks != null) {
        ref = this.stream.getTracks();
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          track = ref[i];
          results.push(track.stop());
        }
        return results;
      } else {
        return this.stream.stop();
      }
    };


    /**
     * Clones the stream. You can change both streams independently, for example
     * mute tracks. You will have to `stop()` both streams individually when you
     * are done.
    #
     * This is currently not supported in Firefox and expected to be implemented
     * in version 47. Use `Stream.canClone()` to check whether cloning is supported by
     * your browser.
    #
     * @method clone
     * @return {rtc.Stream} A clone of the stream
     */

    Stream.prototype.clone = function() {
      if (this.stream.clone == null) {
        throw new Error("Your browser does not support stream cloning. Firefox is expected to implement it in version 47.");
      }
      return new Stream(this.stream.clone());
    };


    /**
     * Checks whether cloning stream is supported by the browser. See `clone()`
     * for details
     * @static
     * @method canClone
     * @return {Boolean} `true` if cloning is supported, `false` otherwise
     */

    Stream.canClone = function() {
      return compat.MediaStream.prototype.clone != null;
    };


    /**
     * Creates a stream using `getUserMedia()`
     * @method createStream
     * @static
     * @param {Object} [config={audio: true, video: true}] The configuration to pass to `getUserMedia()`
     * @return {Promise -> rtc.Stream} Promise to the stream
    #
     * @example
     *     var stream = rtc.Stream.createStream({audio: true, video: false});
     *     rtc.MediaDomElement($('video'), stream);
     */

    Stream.createStream = function(config) {
      if (config == null) {
        config = {
          audio: true,
          video: true
        };
      }
      return new Promise(function(resolve, reject) {
        var success;
        success = function(native_stream) {
          return resolve(new Stream(native_stream));
        };
        return compat.getUserMedia(config, success, reject);
      });
    };

    return Stream;

  })(EventEmitter);

}).call(this);

},{"./compat":1,"events":undefined}],18:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var Peer, Stream;

  Stream = require('./stream').Stream;

  Peer = require('./peer').Peer;


  /**
   * @module rtc
   */


  /**
   * @class rtc.MediaDomElement
   */

  exports.MediaDomElement = (function() {
    function MediaDomElement(dom, data) {
      this.dom = dom;
      if (this.dom.jquery != null) {
        this.dom = this.dom[0];
      }
      this.attach(data);
    }

    MediaDomElement.prototype.attach = function(data) {
      if (data == null) {
        delete this.stream;
        this.dom.pause();
        return this.dom.src = null;
      } else if (data instanceof Stream) {
        this.stream = data;
        if (typeof mozGetUserMedia !== "undefined" && mozGetUserMedia !== null) {
          this.dom.mozSrcObject = data.stream;
        } else {
          this.dom.src = URL.createObjectURL(data.stream);
        }
        return this.dom.play();
      } else if (data instanceof Peer) {
        if (data.isLocal()) {
          this.mute();
        }
        return this.attach(data.stream());
      } else if ((data != null ? data.then : void 0) != null) {
        return data.then((function(_this) {
          return function(res) {
            return _this.attach(res);
          };
        })(this))["catch"]((function(_this) {
          return function(err) {
            return _this.error(err);
          };
        })(this));
      } else {
        return this.error("Tried to attach invalid data");
      }
    };

    MediaDomElement.prototype.error = function(err) {
      return console.log(err);
    };

    MediaDomElement.prototype.clear = function() {
      return this.attach();
    };

    MediaDomElement.prototype.mute = function(muted) {
      if (muted == null) {
        muted = true;
      }
      return this.dom.muted = muted;
    };

    MediaDomElement.prototype.toggleMute = function() {
      return this.dom.muted = !this.dom.muted;
    };

    return MediaDomElement;

  })();

}).call(this);

},{"./peer":8,"./stream":17}]},{},[6])(6)
});
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvY29tcGF0LmNvZmZlZSIsInNyYy9kYXRhX2NoYW5uZWwuY29mZmVlIiwic3JjL2ludGVybmFsL2NoYW5uZWxfY29sbGVjdGlvbi5jb2ZmZWUiLCJzcmMvaW50ZXJuYWwvcHJvbWlzZS5jb2ZmZWUiLCJzcmMvaW50ZXJuYWwvc3RyZWFtX2NvbGxlY3Rpb24uY29mZmVlIiwic3JjL2xpYi5jb2ZmZWUiLCJzcmMvbG9jYWxfcGVlci5jb2ZmZWUiLCJzcmMvcGVlci5jb2ZmZWUiLCJzcmMvcGVlcl9jb25uZWN0aW9uLmNvZmZlZSIsInNyYy9yZW1vdGVfcGVlci5jb2ZmZWUiLCJzcmMvcm9vbS5jb2ZmZWUiLCJzcmMvc2lnbmFsaW5nL2NhbGxpbmdfc2lnbmFsaW5nLmNvZmZlZSIsInNyYy9zaWduYWxpbmcvbXVjX3NpZ25hbGluZy5jb2ZmZWUiLCJzcmMvc2lnbmFsaW5nL3BhbGF2YV9zaWduYWxpbmcuY29mZmVlIiwic3JjL3NpZ25hbGluZy9zaWduYWxpbmcuY29mZmVlIiwic3JjL3NpZ25hbGluZy93ZWJfc29ja2V0X2NoYW5uZWwuY29mZmVlIiwic3JjL3N0cmVhbS5jb2ZmZWUiLCJzcmMvdmlkZW9fZWxlbWVudC5jb2ZmZWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDckpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdDhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS45LjJcblxuLyoqXG4gKiBDb3JlIGZ1bmN0aW9uYWxpdHlcbiAqIEBtb2R1bGUgcnRjXG4gKiBAbWFpbiBydGNcbiAqL1xuXG5cbi8qKlxuICogU2lnbmFsaW5nIGFuZCBzaWduYWxpbmcgY2hhbm5lbHNcbiAqIEBtb2R1bGUgcnRjLnNpZ25hbGluZ1xuICogQG1haW4gcnRjLnNpZ25hbGluZ1xuICovXG5cblxuLyoqXG4gKiBJbnRlcm5hbCBoZWxwZXJzXG4gKiBAbW9kdWxlIHJ0Yy5pbnRlcm5hbFxuICogQG1haW4gcnRjLmludGVybmFsXG4gKi9cblxuKGZ1bmN0aW9uKCkge1xuICB2YXIgYmluZEhlbHBlciwgY29tcGF0O1xuXG4gIGJpbmRIZWxwZXIgPSBmdW5jdGlvbihvYmosIGZ1bikge1xuICAgIGlmIChmdW4gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gZnVuLmJpbmQob2JqKTtcbiAgfTtcblxuICBleHBvcnRzLmNvbXBhdCA9IGNvbXBhdCA9IHtcbiAgICBQZWVyQ29ubmVjdGlvbjogd2luZG93LlBlZXJDb25uZWN0aW9uIHx8IHdpbmRvdy53ZWJraXRQZWVyQ29ubmVjdGlvbjAwIHx8IHdpbmRvdy53ZWJraXRSVENQZWVyQ29ubmVjdGlvbiB8fCB3aW5kb3cubW96UlRDUGVlckNvbm5lY3Rpb24sXG4gICAgSWNlQ2FuZGlkYXRlOiB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlIHx8IHdpbmRvdy5tb3pSVENJY2VDYW5kaWRhdGUsXG4gICAgU2Vzc2lvbkRlc2NyaXB0aW9uOiB3aW5kb3cubW96UlRDU2Vzc2lvbkRlc2NyaXB0aW9uIHx8IHdpbmRvdy5SVENTZXNzaW9uRGVzY3JpcHRpb24sXG4gICAgTWVkaWFTdHJlYW06IHdpbmRvdy5NZWRpYVN0cmVhbSB8fCB3aW5kb3cubW96TWVkaWFTdHJlYW0gfHwgd2luZG93LndlYmtpdE1lZGlhU3RyZWFtLFxuICAgIGdldFVzZXJNZWRpYTogYmluZEhlbHBlcihuYXZpZ2F0b3IsIG5hdmlnYXRvci5nZXRVc2VyTWVkaWEgfHwgbmF2aWdhdG9yLndlYmtpdEdldFVzZXJNZWRpYSB8fCBuYXZpZ2F0b3IubW96R2V0VXNlck1lZGlhIHx8IG5hdmlnYXRvci5tc0dldFVzZXJNZWRpYSksXG4gICAgc3VwcG9ydGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAoY29tcGF0LlBlZXJDb25uZWN0aW9uICE9IG51bGwpICYmIChjb21wYXQuSWNlQ2FuZGlkYXRlICE9IG51bGwpICYmIChjb21wYXQuU2Vzc2lvbkRlc2NyaXB0aW9uICE9IG51bGwpICYmIChjb21wYXQuZ2V0VXNlck1lZGlhICE9IG51bGwpO1xuICAgIH1cbiAgfTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS45LjJcbihmdW5jdGlvbigpIHtcbiAgdmFyIERlZmVycmVkLCBFdmVudEVtaXR0ZXIsIFByb21pc2UsIHJlZixcbiAgICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG4gICAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gIHJlZiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvcHJvbWlzZScpLCBEZWZlcnJlZCA9IHJlZi5EZWZlcnJlZCwgUHJvbWlzZSA9IHJlZi5Qcm9taXNlO1xuXG4gIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxuXG4gIC8qKlxuICAgKiBAbW9kdWxlIHJ0Y1xuICAgKi9cblxuXG4gIC8qKlxuICAgKiBBIHdyYXBwZXIgZm9yIFJUQ0RhdGFDaGFubmVsLiBVc2VkIHRvIHRyYW5zZmVyIGN1c3RvbSBkYXRhIGJldHdlZW4gcGVlcnMuXG4gICAqIEBjbGFzcyBydGMuRGF0YUNoYW5uZWxcbiAgI1xuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtSVENEYXRhQ2hhbm5lbH0gY2hhbm5lbCBUaGUgd3JhcHBlZCBuYXRpdmUgZGF0YSBjaGFubmVsXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbbWF4X2J1ZmZlcl0gVGhlIHNpemUgb2YgdGhlIHNlbmQgYnVmZmVyIGFmdGVyIHdoaWNoIHdlIHdpbGwgZGVsYXkgc2VuZGluZ1xuICAgKi9cblxuICBleHBvcnRzLkRhdGFDaGFubmVsID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoRGF0YUNoYW5uZWwsIHN1cGVyQ2xhc3MpO1xuXG5cbiAgICAvKipcbiAgICAgKiBBIG5ldyBtZXNzYWdlcyB3YXMgcmVjZWl2ZWQuIFRyaWdnZXJzIG9ubHkgYWZ0ZXIgYGNvbm5lY3QoKWAgd2FzIGNhbGxlZFxuICAgICAqIEBldmVudCBtZXNzYWdlXG4gICAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gZGF0YSBUaGUgZGF0YSByZWNlaXZlZFxuICAgICAqL1xuXG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2hhbm5lbCB3YXMgY2xvc2VkXG4gICAgICogQGV2ZW50IGNsb3NlZFxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gRGF0YUNoYW5uZWwoY2hhbm5lbCwgbWF4X2J1ZmZlcikge1xuICAgICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbDtcbiAgICAgIHRoaXMubWF4X2J1ZmZlciA9IG1heF9idWZmZXIgIT0gbnVsbCA/IG1heF9idWZmZXIgOiAxMDI0ICogMTA7XG4gICAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2Nvbm5lY3RfcXVldWUgPSBbXTtcbiAgICAgIHRoaXMuX3NlbmRfYnVmZmVyID0gW107XG4gICAgICB0aGlzLmNoYW5uZWwuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICB0aGlzLmNoYW5uZWwub25tZXNzYWdlID0gKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgIGlmICghX3RoaXMuX2Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9jb25uZWN0X3F1ZXVlLnB1c2goZXZlbnQuZGF0YSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5lbWl0KCdtZXNzYWdlJywgZXZlbnQuZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSkodGhpcyk7XG4gICAgICB0aGlzLmNoYW5uZWwub25jbG9zZSA9IChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLmVtaXQoJ2Nsb3NlZCcpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcyk7XG4gICAgICB0aGlzLmNoYW5uZWwub25lcnJvciA9IChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQ29ubmVjdCB0byB0aGUgRGF0YUNoYW5uZWwuIFlvdSB3aWxsIHJlY2VpdmUgbWVzc2FnZXMgYW5kIHdpbGwgYmUgYWJsZSB0byBzZW5kIGFmdGVyIGNhbGxpbmcgdGhpcy5cbiAgICAgKiBAbWV0aG9kIGNvbm5lY3RcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBQcm9taXNlIHdoaWNoIHJlc29sdmVzIGFzIHNvb24gYXMgdGhlIERhdGFDaGFubmVsIGlzIG9wZW5cbiAgICAgKi9cblxuICAgIERhdGFDaGFubmVsLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZGF0YSwgaSwgbGVuLCByZWYxO1xuICAgICAgdGhpcy5fY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgIHJlZjEgPSB0aGlzLl9jb25uZWN0X3F1ZXVlO1xuICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmMS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBkYXRhID0gcmVmMVtpXTtcbiAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgZGF0YSk7XG4gICAgICB9XG4gICAgICBkZWxldGUgdGhpcy5fY29ubmVjdF9xdWV1ZTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9O1xuXG4gICAgRGF0YUNoYW5uZWwucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmNoYW5uZWwuY2xvc2UoKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGFiZWwgb2YgdGhlIERhdGFDaGFubmVsIHVzZWQgdG8gZGlzdGluZ3Vpc2ggbXVsdGlwbGUgY2hhbm5lbHNcbiAgICAgKiBAbWV0aG9kIGxhYmVsXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgbGFiZWxcbiAgICAgKi9cblxuICAgIERhdGFDaGFubmVsLnByb3RvdHlwZS5sYWJlbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5sYWJlbDtcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGRhdGEgdG8gdGhlIHBlZXIgdGhyb3VnaCB0aGUgRGF0YUNoYW5uZWxcbiAgICAgKiBAbWV0aG9kIHNlbmRcbiAgICAgKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBiZSB0cmFuc2ZlcnJlZFxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFByb21pc2Ugd2hpY2ggd2lsbCBiZSByZXNvbHZlZCB3aGVuIHRoZSBkYXRhIHdhcyBwYXNzZWQgdG8gdGhlIG5hdGl2ZSBkYXRhIGNoYW5uZWxcbiAgICAgKi9cblxuICAgIERhdGFDaGFubmVsLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgdmFyIGRlZmVyO1xuICAgICAgaWYgKCF0aGlzLl9jb25uZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0KCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiU2VuZGluZyB3aXRob3V0IGJlaW5nIGNvbm5lY3RlZC4gUGxlYXNlIGNhbGwgY29ubmVjdCgpIG9uIHRoZSBkYXRhIGNoYW5uZWwgdG8gc3RhcnQgdXNpbmcgaXQuXCIpO1xuICAgICAgfVxuICAgICAgZGVmZXIgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICAgIHRoaXMuX3NlbmRfYnVmZmVyLnB1c2goW2RhdGEsIGRlZmVyXSk7XG4gICAgICBpZiAodGhpcy5fc2VuZF9idWZmZXIubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHRoaXMuX2FjdHVhbFNlbmQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWZlci5wcm9taXNlO1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB3aGljaCBhY3R1YWxseSBzZW5kcyB0aGUgZGF0YS4gSW1wbGVtZW50cyBidWZmZXJpbmdcbiAgICAgKiBAbWV0aG9kIF9hY3R1YWxTZW5kXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICAgIERhdGFDaGFubmVsLnByb3RvdHlwZS5fYWN0dWFsU2VuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGRhdGEsIGRlZmVyLCByZWYxLCByZWYyLCByZXN1bHRzO1xuICAgICAgaWYgKHRoaXMuY2hhbm5lbC5yZWFkeVN0YXRlID09PSAnb3BlbicpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuX3NlbmRfYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWwuYnVmZmVyZWRBbW91bnQgPj0gdGhpcy5tYXhfYnVmZmVyKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHRoaXMuX2FjdHVhbFNlbmQuYmluZCh0aGlzKSwgMSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlZjEgPSB0aGlzLl9zZW5kX2J1ZmZlclswXSwgZGF0YSA9IHJlZjFbMF0sIGRlZmVyID0gcmVmMVsxXTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsLnNlbmQoZGF0YSk7XG4gICAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHRoaXMuX2FjdHVhbFNlbmQuYmluZCh0aGlzKSwgMSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmVyLnJlc29sdmUoKTtcbiAgICAgICAgICB0aGlzLl9zZW5kX2J1ZmZlci5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgIHdoaWxlICh0aGlzLl9zZW5kX2J1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICByZWYyID0gdGhpcy5fc2VuZF9idWZmZXIuc2hpZnQoKSwgZGF0YSA9IHJlZjJbMF0sIGRlZmVyID0gcmVmMlsxXTtcbiAgICAgICAgICByZXN1bHRzLnB1c2goZGVmZXIucmVqZWN0KG5ldyBFcnJvcihcIkRhdGFDaGFubmVsIGNsb3NlZFwiKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gRGF0YUNoYW5uZWw7XG5cbiAgfSkoRXZlbnRFbWl0dGVyKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS45LjJcbihmdW5jdGlvbigpIHtcbiAgdmFyIERlZmVycmVkLCBFdmVudEVtaXR0ZXIsIFByb21pc2UsIHJlZixcbiAgICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG4gICAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gIHJlZiA9IHJlcXVpcmUoJy4vcHJvbWlzZScpLCBEZWZlcnJlZCA9IHJlZi5EZWZlcnJlZCwgUHJvbWlzZSA9IHJlZi5Qcm9taXNlO1xuXG4gIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxuXG4gIC8qKlxuICAgKiBAbW9kdWxlIHJ0Yy5pbnRlcm5hbFxuICAgKi9cblxuXG4gIC8qKlxuICAgKiBIZWxwZXIgd2hpY2ggaGFuZGxlcyBEYXRhQ2hhbm5lbCBuZWdvdGlhdGlvbiBmb3IgUmVtb3RlUGVlclxuICAgKiBAY2xhc3MgcnRjLmludGVybmFsLkNoYW5uZWxDb2xsZWN0aW9uXG4gICAqL1xuXG4gIGV4cG9ydHMuQ2hhbm5lbENvbGxlY3Rpb24gPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChDaGFubmVsQ29sbGVjdGlvbiwgc3VwZXJDbGFzcyk7XG5cblxuICAgIC8qKlxuICAgICAqIEEgbmV3IGRhdGEgY2hhbm5lbCBpcyBhdmFpbGFibGVcbiAgICAgKiBAZXZlbnQgZGF0YV9jaGFubmVsX2FkZGVkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgY2hhbm5lbFxuICAgICAqIEBwYXJhbSB7UHJvbWlzZSAtPiBydGMuU3RyZWFtfSBzdHJlYW0gUHJvbWlzZSBvZiB0aGUgY2hhbm5lbFxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gQ2hhbm5lbENvbGxlY3Rpb24oKSB7XG4gICAgICB0aGlzLmNoYW5uZWxzID0ge307XG4gICAgICB0aGlzLmRlZmVycyA9IHt9O1xuICAgICAgdGhpcy5wZW5kaW5nID0ge307XG4gICAgICB0aGlzLndhaXRfZCA9IG5ldyBEZWZlcnJlZCgpO1xuICAgICAgdGhpcy53YWl0X3AgPSB0aGlzLndhaXRfZC5wcm9taXNlO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBsb2NhbCBjaGFubmVsIGRlc2NyaXB0aW9uLlxuICAgICAqIEBtZXRob2Qgc2V0TG9jYWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBPYmplY3QgZGVzY3JpYmluZyBlYWNoIG9mZmVyZWQgRGF0YUNoYW5uZWxcbiAgICAgKi9cblxuICAgIENoYW5uZWxDb2xsZWN0aW9uLnByb3RvdHlwZS5zZXRMb2NhbCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHRoaXMubG9jYWwgPSBkYXRhO1xuICAgICAgaWYgKHRoaXMucmVtb3RlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgfVxuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgcmVtb3RlIGNoYW5uZWwgZGVzY3JpcHRpb24uXG4gICAgICogQG1ldGhvZCBzZXRSZW1vdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSBPYmplY3QgZGVzY3JpYmluZyBlYWNoIG9mZmVyZWQgRGF0YUNoYW5uZWxcbiAgICAgKi9cblxuICAgIENoYW5uZWxDb2xsZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICB0aGlzLnJlbW90ZSA9IGRhdGE7XG4gICAgICBpZiAodGhpcy5sb2NhbCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBNYXRjaGVzIHJlbW90ZSBhbmQgbG9jYWwgZGVzY3JpcHRpb25zIGFuZCBjcmVhdGVzIHByb21pc2VzIGNvbW1vbiBEYXRhQ2hhbm5lbHNcbiAgICAgKiBAbWV0aG9kIF91cGRhdGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuXG4gICAgQ2hhbm5lbENvbGxlY3Rpb24ucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjaGFubmVsLCBjb25maWcsIGRlZmVyLCBuYW1lLCByZWYxO1xuICAgICAgcmVmMSA9IHRoaXMucmVtb3RlO1xuICAgICAgZm9yIChuYW1lIGluIHJlZjEpIHtcbiAgICAgICAgY29uZmlnID0gcmVmMVtuYW1lXTtcbiAgICAgICAgaWYgKHRoaXMubG9jYWxbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWxzW25hbWVdICE9IG51bGwpIHtcblxuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wZW5kaW5nW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNoYW5uZWwgPSB0aGlzLnBlbmRpbmdbbmFtZV07XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5wZW5kaW5nW25hbWVdO1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsc1tuYW1lXSA9IFByb21pc2UucmVzb2x2ZShjaGFubmVsKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZGF0YV9jaGFubmVsX2FkZGVkJywgbmFtZSwgdGhpcy5jaGFubmVsc1tuYW1lXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlZmVyID0gbmV3IERlZmVycmVkKCk7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxzW25hbWVdID0gZGVmZXIucHJvbWlzZTtcbiAgICAgICAgICAgIHRoaXMuZGVmZXJzW25hbWVdID0gZGVmZXI7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2RhdGFfY2hhbm5lbF9hZGRlZCcsIG5hbWUsIHRoaXMuY2hhbm5lbHNbbmFtZV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIkRhdGFDaGFubmVsIG9mZmVyZWQgYnkgcmVtb3RlIGJ1dCBub3QgYnkgbG9jYWxcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAobmFtZSBpbiB0aGlzLmxvY2FsKSB7XG4gICAgICAgIGlmICh0aGlzLnJlbW90ZVtuYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJEYXRhQ2hhbm5lbCBvZmZlcmVkIGJ5IGxvY2FsIGJ1dCBub3QgYnkgcmVtb3RlXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy53YWl0X2QucmVzb2x2ZSgpO1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIHByb21pc2VzIHdhaXRpbmcgZm9yIHRoZSBnaXZlbiBEYXRhQ2hhbm5lbFxuICAgICAqIEBtZXRob2QgcmVzb2x2ZVxuICAgICAqIEBwYXJhbSB7RGF0YUNoYW5uZWx9IGNoYW5uZWwgVGhlIG5ldyBjaGFubmVsXG4gICAgICovXG5cbiAgICBDaGFubmVsQ29sbGVjdGlvbi5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uKGNoYW5uZWwpIHtcbiAgICAgIHZhciBsYWJlbDtcbiAgICAgIGxhYmVsID0gY2hhbm5lbC5sYWJlbCgpO1xuICAgICAgaWYgKHRoaXMuZGVmZXJzW2xhYmVsXSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuZGVmZXJzW2xhYmVsXS5yZXNvbHZlKGNoYW5uZWwpO1xuICAgICAgICByZXR1cm4gZGVsZXRlIHRoaXMuZGVmZXJzW2xhYmVsXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBlbmRpbmdbbGFiZWxdID0gY2hhbm5lbDtcbiAgICAgIH1cbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBwcm9taXNlIHRvIGEgRGF0YUNoYW5uZWwuIFdpbGwgcmVzb2x2ZSBpZiBEYXRhQ2hhbm5lbCB3YXMgb2ZmZXJlZCBhbmQgZ2V0cyBpbml0aWF0ZWQuIE1pZ2h0IHJlamVjdCBhZnRlciByZW1vdGUgYW5kIGxvY2FsIGRlc2NyaXB0aW9uIGFyZSBwcm9jZXNzZWQuXG4gICAgICogQG1ldGhvZCBnZXRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbGFiZWwgb2YgdGhlIGNoYW5uZWwgdG8gZ2V0XG4gICAgICogQHJldHVybiB7UHJvbWlzZSAtPiBEYXRhQ2hhbm5lbH0gUHJvbWlzZSBmb3IgdGhlIERhdGFDaGFubmVsXG4gICAgICovXG5cbiAgICBDaGFubmVsQ29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMud2FpdF9wLnRoZW4oKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoX3RoaXMuY2hhbm5lbHNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNoYW5uZWxzW25hbWVdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhQ2hhbm5lbCBub3QgbmVnb3RpYXRlZFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBDaGFubmVsQ29sbGVjdGlvbjtcblxuICB9KShFdmVudEVtaXR0ZXIpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjkuMlxuXG4vKipcbiAqIEBtb2R1bGUgcnRjLmludGVybmFsXG4gKi9cblxuXG4vKipcbiAqIEFsaWFzIGZvciBuYXRpdmUgcHJvbWlzZXMgb3IgYSBwb2x5ZmlsbCBpZiBub3Qgc3VwcG9ydGVkXG4gKiBAY2xhc3MgcnRjLmludGVybmFsLlByb21pc2VcbiAqL1xuXG4oZnVuY3Rpb24oKSB7XG4gIGV4cG9ydHMuUHJvbWlzZSA9IGdsb2JhbC5Qcm9taXNlIHx8IHJlcXVpcmUoJ2VzNi1wcm9taXNlJykuUHJvbWlzZTtcblxuXG4gIC8qKlxuICAgKiBIZWxwZXIgdG8gaW1wbGVtZW50IGRlZmVycmVkIGV4ZWN1dGlvbiB3aXRoIHByb21pc2VzXG4gICAqIEBjbGFzcyBydGMuaW50ZXJuYWwuRGVmZXJyZWRcbiAgICovXG5cblxuICAvKipcbiAgICogUmVzb2x2ZXMgdGhlIHByb21pc2VcbiAgICogQG1ldGhvZCByZXNvbHZlXG4gICAqIEBwYXJhbSBbZGF0YV0gVGhlIHBheWxvYWQgdG8gd2hpY2ggdGhlIHByb21pc2Ugd2lsbCByZXNvbHZlXG4gICNcbiAgICogQGV4YW1wbGVcbiAgICogICAgIHZhciBkZWZlciA9IG5ldyBEZWZlcnJlZCgpXG4gICAqICAgICBkZWZlci5yZXNvbHZlKDQyKTtcbiAgICogICAgIGRlZmVyLnByb21pc2UudGhlbihmdW5jdGlvbihyZXMpIHtcbiAgICogICAgICAgY29uc29sZS5sb2cocmVzKTsgICAvLyA0MlxuICAgKiAgICAgfVxuICAgKi9cblxuXG4gIC8qKlxuICAgKiBSZWplY3QgdGhlIHByb21pc2VcbiAgICogQG1ldGhvZCByZWplY3RcbiAgICogQHBhcmFtIHtFcnJvcn0gZXJyb3IgVGhlIHBheWxvYWQgdG8gd2hpY2ggdGhlIHByb21pc2Ugd2lsbCByZXNvbHZlXG4gICNcbiAgICogQGV4YW1wbGVcbiAgICogICAgIHZhciBkZWZlciA9IG5ldyBEZWZlcnJlZCgpXG4gICAqICAgICBkZWZlci5yZWplY3QobmV3IEVycm9yKFwiUmVqZWN0IGJlY2F1c2Ugd2UgY2FuIVwiKSk7XG4gICAqICAgICBkZWZlci5wcm9taXNlLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgKiAgICAgICAvLyB3b250IGhhcHBlblxuICAgKiAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAqICAgICAgIC8vIHdpbGwgaGFwcGVuXG4gICAqICAgICB9XG4gICAqL1xuXG5cbiAgLyoqXG4gICAqIFRoZSBwcm9taXNlIHdoaWNoIHdpbGwgZ2V0IHJlc29sdmVkIG9yIHJlamVjdGVkIGJ5IHRoaXMgZGVmZXJyZWRcbiAgICogQHByb3BlcnR5IHtQcm9taXNlfSBwcm9taXNlXG4gICAqL1xuXG4gIGV4cG9ydHMuRGVmZXJyZWQgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gRGVmZXJyZWQoKSB7XG4gICAgICB0aGlzLnByb21pc2UgPSBuZXcgZXhwb3J0cy5Qcm9taXNlKChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgX3RoaXMucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLnJlamVjdCA9IHJlamVjdDtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gRGVmZXJyZWQ7XG5cbiAgfSkoKTtcblxuXG4gIC8qKlxuICAgKiBBZGRzIGEgdGltZW91dCB0byBhIHByb21pc2UuIFRoZSBwcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWQgaWYgdGltZW91dCBpc1xuICAgKiByZWFjaGVkLiBJdCB3aWxsIGFjdCBsaWtlIHRoZSB1bmRlcmx5aW5nIHByb21pc2UgaWYgaXQgaXMgcmVzb2x2ZWQgb3JcbiAgICogcmVqZWN0ZWQgYmVmb3JlIHRoZSB0aW1lb3V0IGlzIHJlYWNoZWQuXG4gICAqIEBwYXJhbSB7UHJvbXNlfSBwcm9taXNlIFRoZSB1bmRlcmx5aW5nIHByb21pc2VcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWUgVGltZW91dCBpbiBtc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBQcm9taXNlIGFjdGluZyBsaWtlIHRoZSB1bmRlcmx5aW5nIHByb21pc2Ugb3IgdGltZW91dFxuICAgKi9cblxuICBleHBvcnRzLnRpbWVvdXQgPSBmdW5jdGlvbihwcm9taXNlLCB0aW1lKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcHJvbWlzZS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ09wZXJhdGlvbiB0aW1lZCBvdXQnKSk7XG4gICAgICB9LCB0aW1lKTtcbiAgICB9KTtcbiAgfTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS45LjJcbihmdW5jdGlvbigpIHtcbiAgdmFyIERlZmVycmVkLCBFdmVudEVtaXR0ZXIsXG4gICAgZXh0ZW5kID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuICAgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuICBEZWZlcnJlZCA9IHJlcXVpcmUoJy4vcHJvbWlzZScpLkRlZmVycmVkO1xuXG4gIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxuXG4gIC8qKlxuICAgKiBAbW9kdWxlIHJ0Yy5pbnRlcm5hbFxuICAgKi9cblxuXG4gIC8qKlxuICAgKiBIZWxwZXIgaGFuZGxpbmcgdGhlIG1hcHBpbmcgb2Ygc3RyZWFtcyBmb3IgUmVtb3RlUGVlclxuICAgKiBAY2xhc3MgcnRjLmludGVybmFsLlN0cmVhbUNvbGxlY3Rpb25cbiAgI1xuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG5cbiAgZXhwb3J0cy5TdHJlYW1Db2xsZWN0aW9uID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoU3RyZWFtQ29sbGVjdGlvbiwgc3VwZXJDbGFzcyk7XG5cblxuICAgIC8qKlxuICAgICAqIEEgbmV3IHN0cmVhbSB3YXMgYWRkZWQgdG8gdGhlIGNvbGxlY3Rpb25cbiAgICAgKiBAZXZlbnQgc3RlYW1fYWRkZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgdXNlciBkZWZpbmVkIG5hbWUgb2YgdGhlIHN0cmVhbVxuICAgICAqIEBwYXJhbSB7UHJvbWlzZSAtPiBydGMuU3RyZWFtfSBzdHJlYW0gUHJvbWlzZSB0byB0aGUgc3RyZWFtXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBTdHJlYW1Db2xsZWN0aW9uKCkge1xuXG4gICAgICAvKipcbiAgICAgICAqIENvbnRhaW5zIHRoZSBwcm9taXNlcyB3aGljaCB3aWxsIHJlc29sdmUgdG8gdGhlIHN0cmVhbXNcbiAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBzdHJlYW1zXG4gICAgICAgKi9cbiAgICAgIHRoaXMuc3RyZWFtcyA9IHt9O1xuICAgICAgdGhpcy5fZGVmZXJzID0ge307XG4gICAgICB0aGlzLl93YWl0aW5nID0ge307XG4gICAgICB0aGlzLl9wZW5kaW5nID0ge307XG4gICAgICB0aGlzLndhaXRfZCA9IG5ldyBEZWZlcnJlZCgpO1xuICAgICAgdGhpcy53YWl0X3AgPSB0aGlzLndhaXRfZC5wcm9taXNlO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogU2V0IHN0cmVhbSBkZXNjcmlwdGlvbiBhbmQgZ2VuZXJhdGUgcHJvbWlzZXNcbiAgICAgKiBAbWV0aG9kIHVwZGF0ZVxuICAgICAqIEBwYXJhbSBkYXRhIHtPYmplY3R9IEFuIG9iamVjdCBtYXBwaW5nIHRoZSBzdHJlYW0gaWRzIHRvIHN0cmVhbSBuYW1lc1xuICAgICAqL1xuXG4gICAgU3RyZWFtQ29sbGVjdGlvbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgdmFyIGRlZmVyLCBpLCBpZCwgbGVuLCBtZW1iZXJzLCBuYW1lLCByZWYsIHN0cmVhbSwgc3RyZWFtX3A7XG4gICAgICBtZW1iZXJzID0gW107XG4gICAgICB0aGlzLl93YWl0aW5nID0ge307XG4gICAgICByZWYgPSB0aGlzLnN0cmVhbXM7XG4gICAgICBmb3IgKHN0cmVhbV9wID0gaSA9IDAsIGxlbiA9IHJlZi5sZW5ndGg7IGkgPCBsZW47IHN0cmVhbV9wID0gKytpKSB7XG4gICAgICAgIG5hbWUgPSByZWZbc3RyZWFtX3BdO1xuICAgICAgICBpZiAoZGF0YVtuYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuc3RyZWFtc1tuYW1lXTtcbiAgICAgICAgICB0aGlzLmVtaXQoJ3N0cmVhbV9yZW1vdmVkJywgbmFtZSk7XG4gICAgICAgICAgaWYgKHN0cmVhbV9wLmlzRnVsbGZpbGxlZCgpKSB7XG4gICAgICAgICAgICBzdHJlYW1fcC50aGVuKGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgICAgICAgICByZXR1cm4gc3RyZWFtLmNsb3NlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbV9wLmlzUGVuZGluZygpKSB7XG4gICAgICAgICAgICBzdHJlYW1fcC5yZWplY3QobmV3IEVycm9yKFwiU3RyZWFtIHJlbW92ZWQgYmVmb3JlIGJlaW5nIGVzdGFibGlzaGVkXCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAobmFtZSBpbiBkYXRhKSB7XG4gICAgICAgIGlkID0gZGF0YVtuYW1lXTtcbiAgICAgICAgaWYgKHRoaXMuc3RyZWFtc1tuYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgZGVmZXIgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICAgICAgICB0aGlzLnN0cmVhbXNbbmFtZV0gPSBkZWZlci5wcm9taXNlO1xuICAgICAgICAgIHRoaXMuX2RlZmVyc1tuYW1lXSA9IGRlZmVyO1xuICAgICAgICAgIHRoaXMuZW1pdCgnc3RyZWFtX2FkZGVkJywgbmFtZSwgZGVmZXIucHJvbWlzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2RlZmVyc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdbaWRdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHN0cmVhbSA9IHRoaXMuX3BlbmRpbmdbaWRdO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3BlbmRpbmdbaWRdO1xuICAgICAgICAgICAgdGhpcy5fZGVmZXJzW25hbWVdLnJlc29sdmUoc3RyZWFtKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9kZWZlcnNbbmFtZV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3dhaXRpbmdbaWRdID0gbmFtZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLndhaXRfZC5yZXNvbHZlKCk7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogQWRkIHN0cmVhbSB0byB0aGUgY29sbGVjdGlvbiBhbmQgcmVzb2x2ZSBwcm9taXNlcyB3YWl0aW5nIGZvciBpdFxuICAgICAqIEBtZXRob2QgcmVzb2x2ZVxuICAgICAqIEBwYXJhbSB7cnRjLlN0cmVhbX0gc3RyZWFtXG4gICAgICovXG5cbiAgICBTdHJlYW1Db2xsZWN0aW9uLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICB2YXIgaWQsIG5hbWU7XG4gICAgICBpZCA9IHN0cmVhbS5pZCgpO1xuICAgICAgaWYgKGlkID09PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuc3RyZWFtcykubGVuZ3RoID09PSAxICYmIE9iamVjdC5rZXlzKHRoaXMuX3dhaXRpbmcpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiV29ya2luZyBhcm91bmQgaW5jb21wYXRpYmlsaXR5IGJldHdlZW4gRmlyZWZveCBhbmQgQ2hyb21lIGNvbmNlcm5pbmcgc3RyZWFtIGlkZW50aWZpY2F0aW9uXCIpO1xuICAgICAgICAgIGlkID0gT2JqZWN0LmtleXModGhpcy5fd2FpdGluZylbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJVbmFibGUgdG8gd29yayBhcm91bmQgaW5jb21wYXRpYmlsaXR5IGJldHdlZW4gRmlyZWZveCBhbmQgQ2hyb21lIGNvbmNlcm5pbmcgc3RyZWFtIGlkZW50aWZpY2F0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fd2FpdGluZ1tpZF0gIT0gbnVsbCkge1xuICAgICAgICBuYW1lID0gdGhpcy5fd2FpdGluZ1tpZF07XG4gICAgICAgIGRlbGV0ZSB0aGlzLl93YWl0aW5nW2lkXTtcbiAgICAgICAgdGhpcy5fZGVmZXJzW25hbWVdLnJlc29sdmUoc3RyZWFtKTtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZSB0aGlzLl9kZWZlcnNbbmFtZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGVuZGluZ1tpZF0gPSBzdHJlYW07XG4gICAgICB9XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhIHByb21pc2UgZm9yIGEgc3RyZWFtIHdpdGggdGhlIGdpdmVuIG5hbWUuIE1pZ2h0IGJlIHJlamVjdGVkIGFmdGVyIGB1cGRhdGUoKWBcbiAgICAjXG4gICAgICogQG1ldGhvZCBnZXRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFRoZSBwcm9taXNlIGZvciB0aGUgYHJ0Yy5TdHJlYW1gXG4gICAgICovXG5cbiAgICBTdHJlYW1Db2xsZWN0aW9uLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy53YWl0X3AudGhlbigoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChfdGhpcy5zdHJlYW1zW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5zdHJlYW1zW25hbWVdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdHJlYW0gbm90IG9mZmVyZWRcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU3RyZWFtQ29sbGVjdGlvbjtcblxuICB9KShFdmVudEVtaXR0ZXIpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjkuMlxuKGZ1bmN0aW9uKCkge1xuICB2YXIgZXhwb3J0cywgZXh0ZW5kO1xuXG4gIGV4dGVuZCA9IGZ1bmN0aW9uKHJvb3QsIG9iaikge1xuICAgIHZhciBrZXksIHZhbHVlO1xuICAgIGZvciAoa2V5IGluIG9iaikge1xuICAgICAgdmFsdWUgPSBvYmpba2V5XTtcbiAgICAgIHJvb3Rba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gZXhwb3J0cztcbiAgfTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSB7XG4gICAgaW50ZXJuYWw6IHt9LFxuICAgIHNpZ25hbGluZzoge31cbiAgfTtcblxuICBleHRlbmQoZXhwb3J0cywgcmVxdWlyZSgnLi9wZWVyJykpO1xuXG4gIGV4dGVuZChleHBvcnRzLCByZXF1aXJlKCcuL3JlbW90ZV9wZWVyJykpO1xuXG4gIGV4dGVuZChleHBvcnRzLCByZXF1aXJlKCcuL2xvY2FsX3BlZXInKSk7XG5cbiAgZXh0ZW5kKGV4cG9ydHMsIHJlcXVpcmUoJy4vcGVlcl9jb25uZWN0aW9uJykpO1xuXG4gIGV4dGVuZChleHBvcnRzLCByZXF1aXJlKCcuL3N0cmVhbScpKTtcblxuICBleHRlbmQoZXhwb3J0cywgcmVxdWlyZSgnLi9jb21wYXQnKSk7XG5cbiAgZXh0ZW5kKGV4cG9ydHMsIHJlcXVpcmUoJy4vcm9vbScpKTtcblxuICBleHRlbmQoZXhwb3J0cywgcmVxdWlyZSgnLi92aWRlb19lbGVtZW50JykpO1xuXG4gIGV4dGVuZChleHBvcnRzLmludGVybmFsLCByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbV9jb2xsZWN0aW9uJykpO1xuXG4gIGV4dGVuZChleHBvcnRzLmludGVybmFsLCByZXF1aXJlKCcuL2ludGVybmFsL2NoYW5uZWxfY29sbGVjdGlvbicpKTtcblxuICBleHRlbmQoZXhwb3J0cy5pbnRlcm5hbCwgcmVxdWlyZSgnLi9pbnRlcm5hbC9wcm9taXNlJykpO1xuXG4gIGV4dGVuZChleHBvcnRzLnNpZ25hbGluZywgcmVxdWlyZSgnLi9zaWduYWxpbmcvd2ViX3NvY2tldF9jaGFubmVsJykpO1xuXG4gIGV4dGVuZChleHBvcnRzLnNpZ25hbGluZywgcmVxdWlyZSgnLi9zaWduYWxpbmcvcGFsYXZhX3NpZ25hbGluZycpKTtcblxuICBleHRlbmQoZXhwb3J0cy5zaWduYWxpbmcsIHJlcXVpcmUoJy4vc2lnbmFsaW5nL2NhbGxpbmdfc2lnbmFsaW5nJykpO1xuXG4gIGV4dGVuZChleHBvcnRzLnNpZ25hbGluZywgcmVxdWlyZSgnLi9zaWduYWxpbmcvbXVjX3NpZ25hbGluZycpKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS45LjJcbihmdW5jdGlvbigpIHtcbiAgdmFyIFBlZXIsIFN0cmVhbSxcbiAgICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG4gICAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gIFBlZXIgPSByZXF1aXJlKCcuL3BlZXInKS5QZWVyO1xuXG4gIFN0cmVhbSA9IHJlcXVpcmUoJy4vc3RyZWFtJykuU3RyZWFtO1xuXG5cbiAgLyoqXG4gICAqIEBtb2R1bGUgcnRjXG4gICAqL1xuXG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgdGhlIGxvY2FsIHVzZXIgb2YgdGhlIHJvb21cbiAgICogQGNsYXNzIHJ0Yy5Mb2NhbFBlZXJcbiAgICogQGV4dGVuZHMgcnRjLlBlZXJcbiAgI1xuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG5cbiAgZXhwb3J0cy5Mb2NhbFBlZXIgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChMb2NhbFBlZXIsIHN1cGVyQ2xhc3MpO1xuXG4gICAgZnVuY3Rpb24gTG9jYWxQZWVyKCkge1xuXG4gICAgICAvKipcbiAgICAgICAqIENvbnRhaW5zIHByb21pc2VzIG9mIHRoZSBsb2NhbCBzdHJlYW1zIG9mZmVyZWQgdG8gYWxsIHJlbW90ZSBwZWVyc1xuICAgICAgICogQHByb3BlcnR5IHN0cmVhbXNcbiAgICAgICAqIEB0eXBlIE9iamVjdFxuICAgICAgICovXG4gICAgICB0aGlzLnN0cmVhbXMgPSB7fTtcblxuICAgICAgLyoqXG4gICAgICAgKiBDb250YWlucyBhbGwgRGF0YUNoYW5uZWwgY29uZmlndXJhdGlvbnMgbmVnb3RpYXRlZCB3aXRoIGFsbCByZW1vdGUgcGVlcnNcbiAgICAgICAqIEBwcm9wZXJ0eSBjaGFubmVsc1xuICAgICAgICogQHR5cGUgT2JqZWN0XG4gICAgICAgKi9cbiAgICAgIHRoaXMuY2hhbm5lbHMgPSB7fTtcbiAgICAgIHRoaXMuX3N0YXR1cyA9IHt9O1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogR2V0IGFuIGl0ZW0gb2YgdGhlIHN0YXR1cyB0cmFuc2ZlcnJlZCB0byBhbGwgcmVtb3RlIHBlZXJzXG4gICAgICogQG1ldGhvZCBzdGF0dXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlLiBXaWxsIHJldHVyblxuICAgICAqIEByZXR1cm4gVGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUga2V5XG4gICAgICovXG5cblxuICAgIC8qKlxuICAgICAqIFNldCBhbiBpdGVtIG9mIHRoZSBzdGF0dXMgdHJhbnNmZXJyZWQgdG8gYWxsIHJlbW90ZSBwZWVyc1xuICAgICAqIEBtZXRob2Qgc3RhdHVzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZS4gV2lsbCByZXR1cm5cbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIHN0b3JlXG4gICAgICovXG5cbiAgICBMb2NhbFBlZXIucHJvdG90eXBlLnN0YXR1cyA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3N0YXR1c1trZXldID0gdmFsdWU7XG4gICAgICAgIHRoaXMuZW1pdCgnc3RhdHVzX2NoYW5nZWQnLCB0aGlzLl9zdGF0dXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXR1c1trZXldO1xuICAgICAgfVxuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIEFkZCBkYXRhIGNoYW5uZWwgd2hpY2ggd2lsbCBiZSBuZWdvdGlhdGVkIHdpdGggYWxsIHJlbW90ZSBwZWVyc1xuICAgICAqIEBtZXRob2QgYWRkRGF0YUNoYW5uZWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW25hbWU9J2RhdGEnXSBOYW1lIG9mIHRoZSBkYXRhIGNoYW5uZWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2Rlc2M9e29yZGVyZWQ6IHRydWV9XSBPcHRpb25zIHBhc3NlZCB0byBgUlRDRGF0YUNoYW5uZWwuY3JlYXRlRGF0YUNoYW5uZWwoKWBcbiAgICAgKi9cblxuICAgIExvY2FsUGVlci5wcm90b3R5cGUuYWRkRGF0YUNoYW5uZWwgPSBmdW5jdGlvbihuYW1lLCBkZXNjKSB7XG4gICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGRlc2MgPSBuYW1lO1xuICAgICAgICBuYW1lID0gdGhpcy5ERUZBVUxUX0NIQU5ORUw7XG4gICAgICB9XG4gICAgICBpZiAoZGVzYyA9PSBudWxsKSB7XG4gICAgICAgIGRlc2MgPSB7XG4gICAgICAgICAgb3JkZXJlZDogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdGhpcy5jaGFubmVsc1tuYW1lXSA9IGRlc2M7XG4gICAgICB0aGlzLmVtaXQoJ2NvbmZpZ3VyYXRpb25fY2hhbmdlZCcpO1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIEFkZCBsb2NhbCBzdHJlYW0gdG8gYmUgc2VudCB0byBhbGwgcmVtb3RlIHBlZXJzXG4gICAgICogQG1ldGhvZCBhZGRTdHJlYW1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW25hbWU9J3N0cmVhbSddIE5hbWUgb2YgdGhlIHN0cmVhbVxuICAgICAqIEBwYXJhbSB7UHJvbWlzZSAtPiBydGMuU3RyZWFtIHwgcnRjLlN0cmVhbSB8IE9iamVjdH0gc3RyZWFtIFRoZSBzdHJlYW0sIGEgcHJvbWlzZSB0byB0aGUgc3RyZWFtIG9yIHRoZSBjb25maWd1cmF0aW9uIHRvIGNyZWF0ZSBhIHN0cmVhbSB3aXRoIGBydGMuU3RyZWFtLmNyZWF0ZVN0cmVhbSgpYFxuICAgICAqIEByZXR1cm4ge1Byb21pc2UgLT4gcnRjLlN0cmVhbX0gUHJvbWlzZSBvZiB0aGUgc3RyZWFtIHdoaWNoIHdhcyBhZGRlZFxuICAgICAqL1xuXG4gICAgTG9jYWxQZWVyLnByb3RvdHlwZS5hZGRTdHJlYW0gPSBmdW5jdGlvbihuYW1lLCBvYmopIHtcbiAgICAgIHZhciBzYXZlU3RyZWFtLCBzdHJlYW1fcDtcbiAgICAgIHNhdmVTdHJlYW0gPSAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbV9wKSB7XG4gICAgICAgICAgX3RoaXMuc3RyZWFtc1tuYW1lXSA9IHN0cmVhbV9wO1xuICAgICAgICAgIF90aGlzLmVtaXQoJ2NvbmZpZ3VyYXRpb25fY2hhbmdlZCcpO1xuICAgICAgICAgIHJldHVybiBzdHJlYW1fcDtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpO1xuICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICBvYmogPSBuYW1lO1xuICAgICAgICBuYW1lID0gdGhpcy5ERUZBVUxUX1NUUkVBTTtcbiAgICAgIH1cbiAgICAgIGlmICgob2JqICE9IG51bGwgPyBvYmoudGhlbiA6IHZvaWQgMCkgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc2F2ZVN0cmVhbShvYmopO1xuICAgICAgfSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBTdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIHNhdmVTdHJlYW0oUHJvbWlzZS5yZXNvbHZlKG9iaikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyZWFtX3AgPSBTdHJlYW0uY3JlYXRlU3RyZWFtKG9iaik7XG4gICAgICAgIHJldHVybiBzYXZlU3RyZWFtKHN0cmVhbV9wKTtcbiAgICAgIH1cbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBHZXQgbG9jYWwgc3RyZWFtXG4gICAgICogQG1ldGhvZCBzdHJlYW1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW25hbWU9J3N0cmVhbSddIE5hbWUgb2YgdGhlIHN0cmVhbVxuICAgICAqIEByZXR1cm4ge1Byb21pc2UgLT4gcnRjLlN0cmVhbX0gUHJvbWlzZSBvZiB0aGUgc3RyZWFtXG4gICAgICovXG5cbiAgICBMb2NhbFBlZXIucHJvdG90eXBlLnN0cmVhbSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIGlmIChuYW1lID09IG51bGwpIHtcbiAgICAgICAgbmFtZSA9IHRoaXMuREVGQVVMVF9TVFJFQU07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5zdHJlYW1zW25hbWVdO1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBwZWVyIGlzIHRoZSBsb2NhbCBwZWVyLiBSZXR1cm5zIGFsd2F5cyBgdHJ1ZWAgb24gdGhpc1xuICAgICAqIGNsYXNzLlxuICAgICAqIEBtZXRob2QgaXNMb2NhbFxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgYHRydWVgXG4gICAgICovXG5cbiAgICBMb2NhbFBlZXIucHJvdG90eXBlLmlzTG9jYWwgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICByZXR1cm4gTG9jYWxQZWVyO1xuXG4gIH0pKFBlZXIpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjkuMlxuKGZ1bmN0aW9uKCkge1xuICB2YXIgRXZlbnRFbWl0dGVyLFxuICAgIGV4dGVuZCA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcbiAgICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cbiAgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG5cbiAgLyoqXG4gICAqIEBtb2R1bGUgcnRjXG4gICAqL1xuXG5cbiAgLyoqXG4gICAqIEEgdXNlciBpbiB0aGUgcm9vbVxuICAgKiBAY2xhc3MgcnRjLlBlZXJcbiAgICovXG5cbiAgZXhwb3J0cy5QZWVyID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoUGVlciwgc3VwZXJDbGFzcyk7XG5cbiAgICBmdW5jdGlvbiBQZWVyKCkge1xuICAgICAgcmV0dXJuIFBlZXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RhdHVzIG9mIHRoZSBwZWVyIGhhcyBjaGFuZ2VkXG4gICAgICogQGV2ZW50IHN0YXR1c19jaGFuZ2VkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0YXR1cyBUaGUgbmV3IHN0YXR1cyBvYmplY3RcbiAgICAgKi9cblxuICAgIFBlZXIucHJvdG90eXBlLkRFRkFVTFRfQ0hBTk5FTCA9ICdkYXRhJztcblxuICAgIFBlZXIucHJvdG90eXBlLkRFRkFVTFRfU1RSRUFNID0gJ3N0cmVhbSc7XG5cblxuICAgIC8qKlxuICAgICAqIEdldCBhIHZhbHVlIG9mIHRoZSBzdGF0dXMgb2JqZWN0XG4gICAgICogQG1ldGhvZCBzdGF0dXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IFRoZSBrZXkgXG4gICAgICogQHJldHVybiBUaGUgdmFsdWVcbiAgICAgKi9cblxuICAgIFBlZXIucHJvdG90eXBlLnN0YXR1cyA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICAgIH07XG5cbiAgICByZXR1cm4gUGVlcjtcblxuICB9KShFdmVudEVtaXR0ZXIpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjkuMlxuKGZ1bmN0aW9uKCkge1xuICB2YXIgRGF0YUNoYW5uZWwsIERlZmVycmVkLCBFdmVudEVtaXR0ZXIsIFByb21pc2UsIFN0cmVhbSwgY29tcGF0LCByZWYsXG4gICAgZXh0ZW5kID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuICAgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuICByZWYgPSByZXF1aXJlKCcuL2ludGVybmFsL3Byb21pc2UnKSwgRGVmZXJyZWQgPSByZWYuRGVmZXJyZWQsIFByb21pc2UgPSByZWYuUHJvbWlzZTtcblxuICBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbiAgU3RyZWFtID0gcmVxdWlyZSgnLi9zdHJlYW0nKS5TdHJlYW07XG5cbiAgRGF0YUNoYW5uZWwgPSByZXF1aXJlKCcuL2RhdGFfY2hhbm5lbCcpLkRhdGFDaGFubmVsO1xuXG4gIGNvbXBhdCA9IHJlcXVpcmUoJy4vY29tcGF0JykuY29tcGF0O1xuXG5cbiAgLyoqXG4gICAqIEBtb2R1bGUgcnRjXG4gICAqL1xuXG5cbiAgLyoqXG4gICAqIFdyYXBwZXIgYXJvdW5kIG5hdGl2ZSBSVENQZWVyQ29ubmVjdGlvblxuICAjXG4gICAqIFByb3ZpZGVzIGV2ZW50cyBmb3IgbmV3IHN0cmVhbXMgYW5kIGRhdGEgY2hhbm5lbHMuIFNpZ25hbGluZyBpbmZvcm1hdGlvbiBoYXNcbiAgICogdG8gYmUgZm9yd2FyZGVkIGZyb20gZXZlbnRzIGVtaXR0ZWQgYnkgdGhpcyBvYmplY3QgdG8gdGhlIHJlbW90ZVxuICAgKiBQZWVyQ29ubmVjdGlvbi5cbiAgI1xuICAgKiBAY2xhc3MgcnRjLlBlZXJDb25uZWN0aW9uXG4gICAqIEBleHRlbmRzIGV2ZW50cy5FdmVudEVtaXR0ZXJcbiAgI1xuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtCb29sZWFufSBvZmZlcmluZyBUcnVlIGlmIHRoZSBsb2NhbCBwZWVyIHNob3VsZCBpbml0aWF0ZSB0aGUgY29ubmVjdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdCBwYXNzZWQgb24gZnJvbSBgUm9vbWBcbiAgICovXG5cbiAgZXhwb3J0cy5QZWVyQ29ubmVjdGlvbiA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFBlZXJDb25uZWN0aW9uLCBzdXBlckNsYXNzKTtcblxuXG4gICAgLyoqXG4gICAgICogTmV3IGxvY2FsIElDRSBjYW5kaWRhdGUgd2hpY2ggc2hvdWxkIGJlIHNpZ25hbGVkIHRvIHJlbW90ZSBwZWVyXG4gICAgICogQGV2ZW50IGljZV9jYW5kaWF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjYW5kaWRhdGUgVGhlIGljZSBjYW5kaWRhdGVcbiAgICAgKi9cblxuXG4gICAgLyoqXG4gICAgICogTmV3IHJlbW90ZSBzdHJlYW0gd2FzIGFkZGVkIHRvIHRoZSBQZWVyQ29ubmVjdGlvblxuICAgICAqIEBldmVudCBzdHJlYW1fYWRkZWRcbiAgICAgKiBAcGFyYW0ge3J0Yy5TdHJlYW19IHN0cmVhbSBUaGUgc3RyZWFtXG4gICAgICovXG5cblxuICAgIC8qKlxuICAgICAqIE5ldyBEYXRhQ2hhbm5lbCB0byB0aGUgcmVtb3RlIHBlZXIgaXMgcmVhZHkgdG8gYmUgdXNlZFxuICAgICAqIEBldmVudCBkYXRhX2NoYW5uZWxfcmVhZHlcbiAgICAgKiBAcGFyYW0ge3J0Yy5EYXRhQ2hhbm5lbH0gY2hhbm5lbCBUaGUgZGF0YSBjaGFubmVsXG4gICAgICovXG5cblxuICAgIC8qKlxuICAgICAqIE5ldyBvZmZlciBvciBhbnN3ZXIgd2hpY2ggc2hvdWxkIGJlIHNpZ25hbGVkIHRvIHRoZSByZW1vdGUgcGVlclxuICAgICAqIEBldmVudCBzaWduYWxpbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBzaWduYWxpbmcgbWVzc2FnZVxuICAgICAqL1xuXG5cbiAgICAvKipcbiAgICAgKiBUaGUgUGVlckNvbm5lY3Rpb24gd2FzIGNsb3NlZFxuICAgICAqIEBldmVudCBjbG9zZWRcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFBlZXJDb25uZWN0aW9uKG9mZmVyaW5nLCBvcHRpb25zMSkge1xuICAgICAgdmFyIGljZV9zZXJ2ZXJzO1xuICAgICAgdGhpcy5vZmZlcmluZyA9IG9mZmVyaW5nO1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9uczE7XG4gICAgICBpY2Vfc2VydmVycyA9IFtdO1xuICAgICAgdGhpcy5ub19nY19idWdmaXggPSBbXTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3R1biAhPSBudWxsKSB7XG4gICAgICAgIGljZV9zZXJ2ZXJzLnB1c2goe1xuICAgICAgICAgIHVybDogdGhpcy5vcHRpb25zLnN0dW5cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnR1cm4gIT0gbnVsbCkge1xuICAgICAgICBpY2Vfc2VydmVycy5wdXNoKHRoaXMub3B0aW9ucy50dXJuKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGMgPSBuZXcgY29tcGF0LlBlZXJDb25uZWN0aW9uKHtcbiAgICAgICAgaWNlU2VydmVyczogaWNlX3NlcnZlcnNcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jb25uZWN0X2QgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmNvbm5lY3RfZC5wcm9taXNlW1wiY2F0Y2hcIl0oZnVuY3Rpb24oKSB7fSk7XG4gICAgICB0aGlzLnNpZ25hbGluZ19wZW5kaW5nID0gW107XG4gICAgICB0aGlzLnBjLm9uaWNlY2FuZGlkYXRlID0gKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5lbWl0KCdpY2VfY2FuZGlkYXRlJywgZXZlbnQuY2FuZGlkYXRlKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpO1xuICAgICAgdGhpcy5wYy5vbmFkZHN0cmVhbSA9IChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuZW1pdCgnc3RyZWFtX2FkZGVkJywgbmV3IFN0cmVhbShldmVudC5zdHJlYW0pKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpO1xuICAgICAgdGhpcy5wYy5vbmRhdGFjaGFubmVsID0gKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5lbWl0KCdkYXRhX2NoYW5uZWxfcmVhZHknLCBuZXcgRGF0YUNoYW5uZWwoZXZlbnQuY2hhbm5lbCkpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcyk7XG4gICAgICB0aGlzLnBjLm9ucmVtb3Zlc3RyZWFtID0gZnVuY3Rpb24oZXZlbnQpIHt9O1xuICAgICAgdGhpcy5wYy5vbm5lZ290aWF0aW9ubmVlZGVkID0gKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgIHJldHVybiBjb25zb2xlLmxvZygnb25uZWdvdGlhdGlvbm5lZWRlZCBjYWxsZWQnKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpO1xuICAgICAgdGhpcy5wYy5vbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHJlZjE7XG4gICAgICAgICAgaWYgKF90aGlzLnBjLmljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2ZhaWxlZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fY29ubmVjdEVycm9yKG5ldyBFcnJvcihcIlVuYWJsZSB0byBlc3RhYmxpc2ggSUNFIGNvbm5lY3Rpb25cIikpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoX3RoaXMucGMuaWNlQ29ubmVjdGlvblN0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNvbm5lY3RfZC5yZWplY3QobmV3IEVycm9yKCdDb25uZWN0aW9uIHdhcyBjbG9zZWQnKSk7XG4gICAgICAgICAgfSBlbHNlIGlmICgocmVmMSA9IF90aGlzLnBjLmljZUNvbm5lY3Rpb25TdGF0ZSkgPT09ICdjb25uZWN0ZWQnIHx8IHJlZjEgPT09ICdjb21wbGV0ZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuY29ubmVjdF9kLnJlc29sdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKTtcbiAgICAgIHRoaXMucGMub25zaWduYWxpbmdzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKGV2ZW50KSB7fTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEFkZCBuZXcgc2lnbmFsaW5nIGluZm9ybWF0aW9uIHJlY2VpdmVkIGZyb20gcmVtb3RlIHBlZXJcbiAgICAgKiBAbWV0aG9kIHNpZ25hbGluZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFRoZSBzaWduYWxpbmcgaW5mb3JtYXRpb25cbiAgICAgKi9cblxuICAgIFBlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zaWduYWxpbmcgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICB2YXIgc2RwO1xuICAgICAgc2RwID0gbmV3IGNvbXBhdC5TZXNzaW9uRGVzY3JpcHRpb24oZGF0YSk7XG4gICAgICByZXR1cm4gdGhpcy5fc2V0UmVtb3RlRGVzY3JpcHRpb24oc2RwKS50aGVuKChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ29mZmVyJyAmJiBfdGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5fYW5zd2VyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpW1wiY2F0Y2hcIl0oKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuX2Nvbm5lY3RFcnJvcihlcnIpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIEFkZCBhIHJlbW90ZSBJQ0UgY2FuZGlkYXRlXG4gICAgICogQG1ldGhvZCBhZGRJY2VDYW5kaWRhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGVzYyBUaGUgY2FuZGlkYXRlXG4gICAgICovXG5cbiAgICBQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkSWNlQ2FuZGlkYXRlID0gZnVuY3Rpb24oZGVzYykge1xuICAgICAgdmFyIGNhbmRpZGF0ZTtcbiAgICAgIGlmICgoZGVzYyAhPSBudWxsID8gZGVzYy5jYW5kaWRhdGUgOiB2b2lkIDApICE9IG51bGwpIHtcbiAgICAgICAgY2FuZGlkYXRlID0gbmV3IGNvbXBhdC5JY2VDYW5kaWRhdGUoZGVzYyk7XG4gICAgICAgIHJldHVybiB0aGlzLnBjLmFkZEljZUNhbmRpZGF0ZShjYW5kaWRhdGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvbnNvbGUubG9nKFwiSUNFIHRyaWNrbGluZyBzdG9wcGVkXCIpO1xuICAgICAgfVxuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG9wdGlvbnMgZm9yIHRoZSBvZmZlci9hbnN3ZXJcbiAgICAgKiBAbWV0aG9kIF9vYU9wdGlvbnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cblxuICAgIFBlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5fb2FPcHRpb25zID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvcHRpb25hbDogW10sXG4gICAgICAgIG1hbmRhdG9yeToge1xuICAgICAgICAgIE9mZmVyVG9SZWNlaXZlQXVkaW86IHRydWUsXG4gICAgICAgICAgT2ZmZXJUb1JlY2VpdmVWaWRlbzogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgcmVtb3RlIGRlc2NyaXB0aW9uXG4gICAgICogQG1ldGhvZCBfc2V0UmVtb3RlRGVzY3JpcHRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZHAgVGhlIHJlbW90ZSBTRFBcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBQcm9taXNlIHdoaWNoIHdpbGwgYmUgcmVzb2x2ZWQgb25jZSB0aGUgcmVtb3RlIGRlc2NyaXB0aW9uIHdhcyBzZXQgc3VjY2Vzc2Z1bGx5XG4gICAgICovXG5cbiAgICBQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuX3NldFJlbW90ZURlc2NyaXB0aW9uID0gZnVuY3Rpb24oc2RwKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICB2YXIgZGVzY3JpcHRpb247XG4gICAgICAgICAgZGVzY3JpcHRpb24gPSBuZXcgY29tcGF0LlNlc3Npb25EZXNjcmlwdGlvbihzZHApO1xuICAgICAgICAgIHJldHVybiBfdGhpcy5wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihzZHAsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSk7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIG9mZmVyLCBzZXQgaXQgb24gbG9jYWwgZGVzY3JpcHRpb24gYW5kIGVtaXQgaXRcbiAgICAgKiBAbWV0aG9kIF9vZmZlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG5cbiAgICBQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuX29mZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMucGMuY3JlYXRlT2ZmZXIocmVzb2x2ZSwgcmVqZWN0LCBfdGhpcy5fb2FPcHRpb25zKCkpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpLnRoZW4oKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihzZHApIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuX3Byb2Nlc3NMb2NhbFNkcChzZHApO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpW1wiY2F0Y2hcIl0oKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuX2Nvbm5lY3RFcnJvcihlcnIpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbnN3ZXIsIHNldCBpdCBvbiBsb2NhbCBkZXNjcmlwdGlvbiBhbmQgZW1pdCBpdFxuICAgICAqIEBtZXRob2QgX29mZmVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cblxuICAgIFBlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5fYW5zd2VyID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMucGMuY3JlYXRlQW5zd2VyKHJlc29sdmUsIHJlamVjdCwgX3RoaXMuX29hT3B0aW9ucygpKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKS50aGVuKChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oc2RwKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLl9wcm9jZXNzTG9jYWxTZHAoc2RwKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKVtcImNhdGNoXCJdKChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLl9jb25uZWN0RXJyb3IoZXJyKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBTZXQgbG9jYWwgZGVzY3JpcHRpb24gYW5kIGVtaXQgaXRcbiAgICAgKiBAbWV0aG9kIF9wcm9jZXNzTG9jYWxTZHBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzZHAgVGhlIGxvY2FsIFNEUFxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFByb21pc2Ugd2hpY2ggd2lsbCBiZSByZXNvbHZlZCBvbmNlIHRoZSBsb2NhbCBkZXNjcmlwdGlvbiB3YXMgc2V0IHN1Y2Nlc3NmdWxseVxuICAgICAqL1xuXG4gICAgUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLl9wcm9jZXNzTG9jYWxTZHAgPSBmdW5jdGlvbihzZHApIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIHZhciBzdWNjZXNzO1xuICAgICAgICAgIHN1Y2Nlc3MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBkYXRhO1xuICAgICAgICAgICAgZGF0YSA9IHtcbiAgICAgICAgICAgICAgc2RwOiBzZHAuc2RwLFxuICAgICAgICAgICAgICB0eXBlOiBzZHAudHlwZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF90aGlzLmVtaXQoJ3NpZ25hbGluZycsIGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoc2RwKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiBfdGhpcy5wYy5zZXRMb2NhbERlc2NyaXB0aW9uKHNkcCwgc3VjY2VzcywgcmVqZWN0KTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBNYXJrIGNvbm5lY3Rpb24gYXR0ZW1wdCBhcyBmYWlsZWRcbiAgICAgKiBAbWV0aG9kIF9jb25uZWN0RXJyb3JcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RXJyb3J9IGVyciBFcnJvciBjYXVzaW5nIGNvbm5lY3Rpb24gdG8gZmFpbFxuICAgICAqL1xuXG4gICAgUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLl9jb25uZWN0RXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgIHRoaXMuY29ubmVjdF9kLnJlamVjdChlcnIpO1xuICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBBZGQgbG9jYWwgc3RyZWFtXG4gICAgICogQG1ldGhvZCBhZGRTdHJlYW1cbiAgICAgKiBAcGFyYW0ge3J0Yy5TdHJlYW19IHN0cmVhbSBUaGUgbG9jYWwgc3RyZWFtXG4gICAgICovXG5cbiAgICBQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkU3RyZWFtID0gZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYy5hZGRTdHJlYW0oc3RyZWFtLnN0cmVhbSk7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGxvY2FsIHN0cmVhbVxuICAgICAqIEBtZXRob2QgcmVtb3ZlU3RyZWFtXG4gICAgICogQHBhcmFtIHtydGMuU3RyZWFtfSBzdHJlYW0gVGhlIGxvY2FsIHN0cmVhbVxuICAgICAqL1xuXG4gICAgUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVNyZWFtID0gZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYy5yZW1vdmVTdHJlYW0oc3RyZWFtLnN0cmVhbSk7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogQWRkIERhdGFDaGFubmVsLiBXaWxsIG9ubHkgYWN0dWFsbHkgZG8gc29tZXRoaW5nIGlmIGBvZmZlcmluZ2AgaXMgYHRydWVgLlxuICAgICAqIEBtZXRob2QgYWRkRGF0YUNoYW5uZWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSBkYXRhIGNoYW5uZWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGVzYyBPcHRpb25zIHBhc3NlZCB0byBgUlRDUGVlckNvbm5lY3Rpb24uY3JlYXRlRGF0YUNoYW5uZWwoKWBcbiAgICAgKi9cblxuICAgIFBlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGREYXRhQ2hhbm5lbCA9IGZ1bmN0aW9uKG5hbWUsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBjaGFubmVsO1xuICAgICAgaWYgKHRoaXMub2ZmZXJpbmcpIHtcbiAgICAgICAgY2hhbm5lbCA9IHRoaXMucGMuY3JlYXRlRGF0YUNoYW5uZWwobmFtZSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMubm9fZ2NfYnVnZml4LnB1c2goY2hhbm5lbCk7XG4gICAgICAgIHJldHVybiBjaGFubmVsLm9ub3BlbiA9IChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5lbWl0KCdkYXRhX2NoYW5uZWxfcmVhZHknLCBuZXcgRGF0YUNoYW5uZWwoY2hhbm5lbCkpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpO1xuICAgICAgfVxuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIEVzdGFibGlzaCBjb25uZWN0aW9uIHdpdGggcmVtb3RlIHBlZXIuIENvbm5lY3Rpb24gd2lsbCBiZSBlc3RhYmxpc2hlZCBvbmNlIGJvdGggcGVlcnMgaGF2ZSBjYWxsZWQgdGhpcyBmdW5jdGlvXG4gICAgICogQG1ldGhvZCBjb25uZWN0XG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSB3aGljaCB3aWxsIGJlIHJlc29sdmVkIG9uY2UgdGhlIGNvbm5lY3Rpb24gaXMgZXN0YWJsaXNoZWRcbiAgICAgKi9cblxuICAgIFBlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgIGlmICh0aGlzLm9mZmVyaW5nKSB7XG4gICAgICAgICAgdGhpcy5fb2ZmZXIoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnBjLnNpZ25hbGluZ1N0YXRlID09PSAnaGF2ZS1yZW1vdGUtb2ZmZXInKSB7XG4gICAgICAgICAgdGhpcy5fYW5zd2VyKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmNvbm5lY3RfZC5wcm9taXNlKTtcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBDbG9zZSB0aGUgY29ubmVjdGlvbiB0byB0aGUgcmVtb3RlIHBlZXJcbiAgICAgKiBAbWV0aG9kIGNsb3NlXG4gICAgICovXG5cbiAgICBQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMucGMuY2xvc2UoKTtcbiAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2Nsb3NlZCcpO1xuICAgIH07XG5cbiAgICByZXR1cm4gUGVlckNvbm5lY3Rpb247XG5cbiAgfSkoRXZlbnRFbWl0dGVyKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS45LjJcbihmdW5jdGlvbigpIHtcbiAgdmFyIENoYW5uZWxDb2xsZWN0aW9uLCBQZWVyLCBQcm9taXNlLCBTdHJlYW1Db2xsZWN0aW9uLCBtZXJnZSxcbiAgICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG4gICAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gIFByb21pc2UgPSByZXF1aXJlKCcuL2ludGVybmFsL3Byb21pc2UnKS5Qcm9taXNlO1xuXG4gIFBlZXIgPSByZXF1aXJlKCcuL3BlZXInKS5QZWVyO1xuXG4gIFN0cmVhbUNvbGxlY3Rpb24gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbV9jb2xsZWN0aW9uJykuU3RyZWFtQ29sbGVjdGlvbjtcblxuICBDaGFubmVsQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvY2hhbm5lbF9jb2xsZWN0aW9uJykuQ2hhbm5lbENvbGxlY3Rpb247XG5cbiAgbWVyZ2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJyYXksIGksIGtleSwgbGVuLCByZXMsIHZhbHVlO1xuICAgIHJlcyA9IHt9O1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgYXJyYXkgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKGtleSBpbiBhcnJheSkge1xuICAgICAgICB2YWx1ZSA9IGFycmF5W2tleV07XG4gICAgICAgIHJlc1trZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG5cblxuICAvKipcbiAgICogQG1vZHVsZSBydGNcbiAgICovXG5cblxuICAvKipcbiAgICogUmVwcmVzZW50cyBhIHJlbW90ZSB1c2VyIG9mIHRoZSByb29tXG4gICAqIEBjbGFzcyBydGMuUmVtb3RlUGVlclxuICAgKiBAZXh0ZW5kcyBydGMuUGVlclxuICAjXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge3J0Yy5QZWVyQ29ubmVjdGlvbn0gcGVlcl9jb25uZWN0aW9uIFRoZSB1bmRlcmx5aW5nIHBlZXIgY29ubmVjdGlvblxuICAgKiBAcGFyYW0ge3J0Yy5TaWduYWxpbmdQZWVyfSBzaWduYWxpbmcgVGhlIHNpZ25hbGluZyBjb25uZWN0aW9uIHRvIHRoZSBwZWVyXG4gICAqIEBwYXJhbSB7cnRjLkxvY2FsUGVlcn0gbG9jYWwgVGhlIGxvY2FsIHBlZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgb2JqZWN0IGFzIHBhc3NlZCB0byBgUm9vbWBcbiAgICovXG5cbiAgZXhwb3J0cy5SZW1vdGVQZWVyID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQoUmVtb3RlUGVlciwgc3VwZXJDbGFzcyk7XG5cblxuICAgIC8qKlxuICAgICAqIE1lc3NhZ2UgcmVjZWl2ZWQgZnJvbSBwZWVyIHRocm91Z2ggc2lnbmFsaW5nXG4gICAgICogQGV2ZW50IG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0gZGF0YSBUaGUgcGF5bG9hZCBvZiB0aGUgbWVzc2FnZVxuICAgICAqL1xuXG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVtb3RlIHBlZXIgbGVmdCBvciBzaWduYWxpbmcgY2xvc2VkXG4gICAgICogQGV2ZW50IGxlZnRcbiAgICAgKi9cblxuXG4gICAgLyoqXG4gICAgICogQSBuZXcgc3RyZWFtIGlzIGF2YWlsYWJsZSBmcm9tIHRoZSBwZWVyXG4gICAgICogQGV2ZW50IHN0cmVhbV9hZGRlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIHN0cmVhbVxuICAgICAqIEBwYXJhbSB7UHJvbWlzZSAtPiBydGMuU3RyZWFtfSBzdHJlYW0gUHJvbWlzZSBvZiB0aGUgc3RyZWFtXG4gICAgICovXG5cblxuICAgIC8qKlxuICAgICAqIEEgbmV3IGRhdGEgY2hhbm5lbCBpcyBhdmFpbGFibGUgZnJvbSB0aGUgcGVlclxuICAgICAqIEBldmVudCBkYXRhX2NoYW5uZWxfYWRkZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBOYW1lIG9mIHRoZSBjaGFubmVsXG4gICAgICogQHBhcmFtIHtQcm9taXNlIC0+IHJ0Yy5EYXRhQ2hhbm5lbH0gY2hhbm5lbCBQcm9taXNlIG9mIHRoZSBjaGFubmVsXG4gICAgICovXG5cblxuICAgIC8qKlxuICAgICAqIFRoZSBjb25uZWN0aW9uIHRvIHRoZSBwZWVyIHN1cHBsaWVkIGJ5IHRoZSBzaWduYWxpbmcgaW1wbGVtZW50YXRpb25cbiAgICAgKiBAcHJvcGVydHkgc2lnbmFsaW5nXG4gICAgICogQHR5cGUgcnRjLnNpZ25hbGluZy5TaWduYWxpbmdQZWVyXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBSZW1vdGVQZWVyKHBlZXJfY29ubmVjdGlvbiwgc2lnbmFsaW5nLCBsb2NhbCwgb3B0aW9uczEpIHtcbiAgICAgIHRoaXMucGVlcl9jb25uZWN0aW9uID0gcGVlcl9jb25uZWN0aW9uO1xuICAgICAgdGhpcy5zaWduYWxpbmcgPSBzaWduYWxpbmc7XG4gICAgICB0aGlzLmxvY2FsID0gbG9jYWw7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zMTtcbiAgICAgIHRoaXMucHJpdmF0ZV9zdHJlYW1zID0ge307XG4gICAgICB0aGlzLnByaXZhdGVfY2hhbm5lbHMgPSB7fTtcbiAgICAgIHRoaXMuc3RyZWFtX2NvbGxlY3Rpb24gPSBuZXcgU3RyZWFtQ29sbGVjdGlvbigpO1xuICAgICAgdGhpcy5zdHJlYW1zID0gdGhpcy5zdHJlYW1fY29sbGVjdGlvbi5zdHJlYW1zO1xuICAgICAgdGhpcy5zdHJlYW1zX2Rlc2MgPSB7fTtcbiAgICAgIHRoaXMuc3RyZWFtX2NvbGxlY3Rpb24ub24oJ3N0cmVhbV9hZGRlZCcsIChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24obmFtZSwgc3RyZWFtKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLmVtaXQoJ3N0cmVhbV9hZGRlZCcsIG5hbWUsIHN0cmVhbSk7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSk7XG4gICAgICB0aGlzLmNoYW5uZWxfY29sbGVjdGlvbiA9IG5ldyBDaGFubmVsQ29sbGVjdGlvbigpO1xuICAgICAgdGhpcy5jaGFubmVscyA9IHRoaXMuY2hhbm5lbF9jb2xsZWN0aW9uLmNoYW5uZWxzO1xuICAgICAgdGhpcy5jaGFubmVsc19kZXNjID0ge307XG4gICAgICB0aGlzLmNoYW5uZWxfY29sbGVjdGlvbi5vbignZGF0YV9jaGFubmVsX2FkZGVkJywgKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihuYW1lLCBjaGFubmVsKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLmVtaXQoJ2RhdGFfY2hhbm5lbF9hZGRlZCcsIG5hbWUsIGNoYW5uZWwpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgICAgdGhpcy5wZWVyX2Nvbm5lY3Rpb24ub24oJ3N0cmVhbV9hZGRlZCcsIChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLnN0cmVhbV9jb2xsZWN0aW9uLnJlc29sdmUoc3RyZWFtKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICAgIHRoaXMucGVlcl9jb25uZWN0aW9uLm9uKCdkYXRhX2NoYW5uZWxfcmVhZHknLCAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNoYW5uZWwpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuY2hhbm5lbF9jb2xsZWN0aW9uLnJlc29sdmUoY2hhbm5lbCk7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSk7XG4gICAgICB0aGlzLnBlZXJfY29ubmVjdGlvbi5vbignc2lnbmFsaW5nJywgKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgZGF0YS5zdHJlYW1zID0gX3RoaXMuc3RyZWFtc19kZXNjO1xuICAgICAgICAgIGRhdGEuY2hhbm5lbHMgPSBfdGhpcy5jaGFubmVsc19kZXNjO1xuICAgICAgICAgIHJldHVybiBfdGhpcy5zaWduYWxpbmcuc2VuZCgnc2lnbmFsaW5nJywgZGF0YSk7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSk7XG4gICAgICB0aGlzLnNpZ25hbGluZy5vbignc2lnbmFsaW5nJywgKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgX3RoaXMuc3RyZWFtX2NvbGxlY3Rpb24udXBkYXRlKGRhdGEuc3RyZWFtcyk7XG4gICAgICAgICAgX3RoaXMuY2hhbm5lbF9jb2xsZWN0aW9uLnNldFJlbW90ZShkYXRhLmNoYW5uZWxzKTtcbiAgICAgICAgICByZXR1cm4gX3RoaXMucGVlcl9jb25uZWN0aW9uLnNpZ25hbGluZyhkYXRhKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICAgIHRoaXMucGVlcl9jb25uZWN0aW9uLm9uKCdpY2VfY2FuZGlkYXRlJywgKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihjYW5kaWRhdGUpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuc2lnbmFsaW5nLnNlbmQoJ2ljZV9jYW5kaWRhdGUnLCBjYW5kaWRhdGUpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgICAgdGhpcy5zaWduYWxpbmcub24oJ2ljZV9jYW5kaWRhdGUnLCAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNhbmRpZGF0ZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5wZWVyX2Nvbm5lY3Rpb24uYWRkSWNlQ2FuZGlkYXRlKGNhbmRpZGF0ZSk7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSk7XG4gICAgICB0aGlzLnNpZ25hbGluZy5vbignc3RhdHVzX2NoYW5nZWQnLCAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0YXR1cykge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5lbWl0KCdzdGF0dXNfY2hhbmdlZCcsIHN0YXR1cyk7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSk7XG4gICAgICB0aGlzLnNpZ25hbGluZy5vbignbWVzc2FnZScsIChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5lbWl0KCdtZXNzYWdlJywgZGF0YSk7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSk7XG4gICAgICB0aGlzLnNpZ25hbGluZy5vbignbGVmdCcsIChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgX3RoaXMucGVlcl9jb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLmVtaXQoJ2xlZnQnKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICAgIHRoaXMucGVlcl9jb25uZWN0aW9uLm9uKCdjb25uZWN0ZWQnLCAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge307XG4gICAgICB9KSh0aGlzKSk7XG4gICAgICB0aGlzLnBlZXJfY29ubmVjdGlvbi5vbignY2xvc2VkJywgKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHt9O1xuICAgICAgfSkodGhpcykpO1xuICAgICAgaWYgKCh0aGlzLm9wdGlvbnMuYXV0b19jb25uZWN0ID09IG51bGwpIHx8IHRoaXMub3B0aW9ucy5hdXRvX2Nvbm5lY3QpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgUmVtb3RlUGVlci5wcm90b3R5cGUuc3RhdHVzID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5zaWduYWxpbmcuc3RhdHVzW2tleV07XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogU2VuZCBhIG1lc3NhZ2UgdG8gdGhlIHBlZXIgdGhyb3VnaCBzaWduYWxpbmdcbiAgICAgKiBAbWV0aG9kIG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0gZGF0YSBUaGUgcGF5bG9hZFxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9IFByb21pc2Ugd2hpY2ggaXMgcmVzb2x2ZWQgd2hlbiB0aGUgZGF0YSB3YXMgc2VudFxuICAgICAqL1xuXG4gICAgUmVtb3RlUGVlci5wcm90b3R5cGUubWVzc2FnZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiB0aGlzLnNpZ25hbGluZy5zZW5kKCdtZXNzYWdlJywgZGF0YSk7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogQ29ubmVjdCB0byB0aGUgcmVtb3RlIHBlZXIgdG8gZXhjaGFuZ2Ugc3RyZWFtcyBhbmQgY3JlYXRlIGRhdGEgY2hhbm5lbHNcbiAgICAgKiBAbWV0aG9kIGNvbm5lY3RcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBQcm9taXNlIHdoaWNoIHdpbGwgcmVzb2x2ZWQgd2hlbiB0aGUgY29ubmVjdGlvbiBpcyBlc3RhYmxpc2hlZFxuICAgICAqL1xuXG4gICAgUmVtb3RlUGVlci5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG5hbWUsIHByb21pc2UsIHJlZiwgc3RyZWFtLCBzdHJlYW1fcHJvbWlzZXM7XG4gICAgICBpZiAodGhpcy5jb25uZWN0X3AgPT0gbnVsbCkge1xuICAgICAgICBzdHJlYW1fcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgcmVmID0gbWVyZ2UodGhpcy5sb2NhbC5zdHJlYW1zLCB0aGlzLnByaXZhdGVfc3RyZWFtcyk7XG4gICAgICAgIGZvciAobmFtZSBpbiByZWYpIHtcbiAgICAgICAgICBzdHJlYW0gPSByZWZbbmFtZV07XG4gICAgICAgICAgcHJvbWlzZSA9IHN0cmVhbS50aGVuKGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgICAgICAgcmV0dXJuIFtuYW1lLCBzdHJlYW1dO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHN0cmVhbV9wcm9taXNlcy5wdXNoKHByb21pc2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29ubmVjdF9wID0gUHJvbWlzZS5hbGwoc3RyZWFtX3Byb21pc2VzKS50aGVuKChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbihzdHJlYW1zKSB7XG4gICAgICAgICAgICB2YXIgaSwgbGVuLCBvcHRpb25zLCByZWYxLCByZWYyO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gc3RyZWFtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICByZWYxID0gc3RyZWFtc1tpXSwgbmFtZSA9IHJlZjFbMF0sIHN0cmVhbSA9IHJlZjFbMV07XG4gICAgICAgICAgICAgIF90aGlzLnBlZXJfY29ubmVjdGlvbi5hZGRTdHJlYW0oc3RyZWFtKTtcbiAgICAgICAgICAgICAgX3RoaXMuc3RyZWFtc19kZXNjW25hbWVdID0gc3RyZWFtLmlkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWYyID0gbWVyZ2UoX3RoaXMubG9jYWwuY2hhbm5lbHMsIF90aGlzLnByaXZhdGVfY2hhbm5lbHMpO1xuICAgICAgICAgICAgZm9yIChuYW1lIGluIHJlZjIpIHtcbiAgICAgICAgICAgICAgb3B0aW9ucyA9IHJlZjJbbmFtZV07XG4gICAgICAgICAgICAgIF90aGlzLnBlZXJfY29ubmVjdGlvbi5hZGREYXRhQ2hhbm5lbChuYW1lLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgX3RoaXMuY2hhbm5lbHNfZGVzY1tuYW1lXSA9IG9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5jaGFubmVsX2NvbGxlY3Rpb24uc2V0TG9jYWwoX3RoaXMuY2hhbm5lbHNfZGVzYyk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMucGVlcl9jb25uZWN0aW9uLmNvbm5lY3QoKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5jb25uZWN0X3A7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSBjb25uZWN0aW9uIHRvIHRoZSBwZWVyXG4gICAgICogQG1ldGhvZCBjbG9zZVxuICAgICAqL1xuXG4gICAgUmVtb3RlUGVlci5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMucGVlcl9jb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogR2V0IGEgc3RyZWFtIGZyb20gdGhlIHBlZXIuIEhhcyB0byBiZSBzZW50IGJ5IHRoZSByZW1vdGUgcGVlciB0byBzdWNjZWVkLlxuICAgICAqIEBtZXRob2Qgc3RyZWFtXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtuYW1lPSdzdHJlYW0nXSBOYW1lIG9mIHRoZSBzdHJlYW1cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlIC0+IHJ0Yy5TdHJlYW19IFByb21pc2Ugb2YgdGhlIHN0cmVhbVxuICAgICAqL1xuXG4gICAgUmVtb3RlUGVlci5wcm90b3R5cGUuc3RyZWFtID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgaWYgKG5hbWUgPT0gbnVsbCkge1xuICAgICAgICBuYW1lID0gdGhpcy5ERUZBVUxUX1NUUkVBTTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnN0cmVhbV9jb2xsZWN0aW9uLmdldChuYW1lKTtcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBBZGQgbG9jYWwgc3RyZWFtIHRvIGJlIHNlbnQgdG8gdGhpcyByZW1vdGUgcGVlclxuICAgICNcbiAgICAgKiBJZiB5b3UgdXNlIHRoaXMgbWV0aG9kIHlvdSBoYXZlIHRvIHNldCBgYXV0b19jb25uZWN0YCB0byBgZmFsc2VgIGluIHRoZSBvcHRpb25zIG9iamVjdCBhbmQgY2FsbCBgY29ubmVjdCgpYCBtYW51YWxseSBvbiBhbGwgcmVtb3RlIHBlZXJzLlxuICAgICNcbiAgICAgKiBAbWV0aG9kIGFkZFN0cmVhbVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbbmFtZT0nc3RyZWFtJ10gTmFtZSBvZiB0aGUgc3RyZWFtXG4gICAgICogQHBhcmFtIHtQcm9taXNlIC0+IHJ0Yy5TdHJlYW0gfCBydGMuU3RyZWFtIHwgT2JqZWN0fSBzdHJlYW0gVGhlIHN0cmVhbSwgYSBwcm9taXNlIHRvIHRoZSBzdHJlYW0gb3IgdGhlIGNvbmZpZ3VyYXRpb24gdG8gY3JlYXRlIGEgc3RyZWFtIHdpdGggYHJ0Yy5TdHJlYW0uY3JlYXRlU3RyZWFtKClgXG4gICAgICogQHJldHVybiB7UHJvbWlzZSAtPiBydGMuU3RyZWFtfSBQcm9taXNlIG9mIHRoZSBzdHJlYW0gd2hpY2ggd2FzIGFkZGVkXG4gICAgICovXG5cbiAgICBSZW1vdGVQZWVyLnByb3RvdHlwZS5hZGRTdHJlYW0gPSBmdW5jdGlvbihuYW1lLCBvYmopIHtcbiAgICAgIHZhciBzYXZlU3RyZWFtLCBzdHJlYW1fcDtcbiAgICAgIGlmICghKHRoaXMub3B0aW9ucy5hdXRvX2Nvbm5lY3QgPT09IGZhbHNlKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJVbmFibGUgdG8gYWRkIHN0cmVhbXMgZGlyZWN0bHkgdG8gcmVtb3RlIHBlZXJzIHdpdGhvdXQgJ2F1dG9fY29ubmVjdCcgb3B0aW9uIHNldCB0byAnZmFsc2UnXCIpO1xuICAgICAgfVxuICAgICAgc2F2ZVN0cmVhbSA9IChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtX3ApIHtcbiAgICAgICAgICBfdGhpcy5wcml2YXRlX3N0cmVhbXNbbmFtZV0gPSBzdHJlYW1fcDtcbiAgICAgICAgICByZXR1cm4gc3RyZWFtX3A7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKTtcbiAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgb2JqID0gbmFtZTtcbiAgICAgICAgbmFtZSA9IHRoaXMuREVGQVVMVF9TVFJFQU07XG4gICAgICB9XG4gICAgICBpZiAoKG9iaiAhPSBudWxsID8gb2JqLnRoZW4gOiB2b2lkIDApICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHNhdmVTdHJlYW0ob2JqKTtcbiAgICAgIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgU3RyZWFtKSB7XG4gICAgICAgIHJldHVybiBzYXZlU3RyZWFtKFByb21pc2UucmVzb2x2ZShvYmopKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cmVhbV9wID0gU3RyZWFtLmNyZWF0ZVN0cmVhbShvYmopO1xuICAgICAgICByZXR1cm4gc2F2ZVN0cmVhbShzdHJlYW1fcCk7XG4gICAgICB9XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogR2V0IGEgZGF0YSBjaGFubmVsIHRvIHRoZSByZW1vdGUgcGVlci4gSGFzIHRvIGJlIGFkZGVkIGJ5IGxvY2FsIGFuZCByZW1vdGUgc2lkZSB0byBzdWNjZWVkLlxuICAgICAqIEBtZXRob2QgY2hhbm5lbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbbmFtZT0nZGF0YSddIE5hbWUgb2YgdGhlIGRhdGEgY2hhbm5lbFxuICAgICAqIEByZXR1cm4ge1Byb21pc2UgLT4gcnRjLkRhdGFDaGFubmVsfSBQcm9taXNlIG9mIHRoZSBkYXRhIGNoYW5uZWxcbiAgICAgKi9cblxuICAgIFJlbW90ZVBlZXIucHJvdG90eXBlLmNoYW5uZWwgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICBpZiAobmFtZSA9PSBudWxsKSB7XG4gICAgICAgIG5hbWUgPSB0aGlzLkRFRkFVTFRfQ0hBTk5FTDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmNoYW5uZWxfY29sbGVjdGlvbi5nZXQobmFtZSk7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogQWRkIGRhdGEgY2hhbm5lbCB3aGljaCB3aWxsIGJlIG5lZ290aWF0ZWQgd2l0aCB0aGlzIHJlbW90ZSBwZWVyXG4gICAgI1xuICAgICAqIElmIHlvdSB1c2UgdGhpcyBtZXRob2QgeW91IGhhdmUgdG8gc2V0IGBhdXRvX2Nvbm5lY3RgIHRvIGBmYWxzZWAgaW4gdGhlIG9wdGlvbnMgb2JqZWN0IGFuZCBjYWxsIGBjb25uZWN0KClgIG1hbnVhbGx5IG9uIGFsbCByZW1vdGUgcGVlcnMuXG4gICAgI1xuICAgICAqIEBtZXRob2QgYWRkRGF0YUNoYW5uZWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW25hbWU9J2RhdGEnXSBOYW1lIG9mIHRoZSBkYXRhIGNoYW5uZWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2Rlc2M9e29yZGVyZWQ6IHRydWV9XSBPcHRpb25zIHBhc3NlZCB0byBgUlRDRGF0YUNoYW5uZWwuY3JlYXRlRGF0YUNoYW5uZWwoKWBcbiAgICAgKi9cblxuICAgIFJlbW90ZVBlZXIucHJvdG90eXBlLmFkZERhdGFDaGFubmVsID0gZnVuY3Rpb24obmFtZSwgZGVzYykge1xuICAgICAgaWYgKCEodGhpcy5vcHRpb25zLmF1dG9fY29ubmVjdCA9PT0gZmFsc2UpKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcIlVuYWJsZSB0byBhZGQgY2hhbm5lbHMgZGlyZWN0bHkgdG8gcmVtb3RlIHBlZXJzIHdpdGhvdXQgJ2F1dG9fY29ubmVjdCcgb3B0aW9uIHNldCB0byAnZmFsc2UnXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICBkZXNjID0gbmFtZTtcbiAgICAgICAgbmFtZSA9IHRoaXMuREVGQVVMVF9DSEFOTkVMO1xuICAgICAgfVxuICAgICAgaWYgKGRlc2MgPT0gbnVsbCkge1xuICAgICAgICBkZXNjID0ge1xuICAgICAgICAgIG9yZGVyZWQ6IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHRoaXMucHJpdmF0ZV9jaGFubmVsc1tuYW1lXSA9IGRlc2M7XG4gICAgICByZXR1cm4gdGhpcy5jaGFubmVsKG5hbWUpO1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBwZWVyIGlzIHRoZSBsb2NhbCBwZWVyLiBSZXR1cm5zIGFsd2F5cyBgZmFsc2VgIG9uIHRoaXNcbiAgICAgKiBjbGFzcy5cbiAgICAgKiBAbWV0aG9kIGlzTG9jYWxcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBSZXR1cm5zIGBmYWxzZWBcbiAgICAgKi9cblxuICAgIFJlbW90ZVBlZXIucHJvdG90eXBlLmlzTG9jYWwgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFJlbW90ZVBlZXI7XG5cbiAgfSkoUGVlcik7XG5cbn0pLmNhbGwodGhpcyk7XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuOS4yXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBFdmVudEVtaXR0ZXIsIExvY2FsUGVlciwgTXVjU2lnbmFsaW5nLCBQZWVyQ29ubmVjdGlvbiwgUmVtb3RlUGVlciwgV2ViU29ja2V0Q2hhbm5lbCxcbiAgICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG4gICAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxuICBXZWJTb2NrZXRDaGFubmVsID0gcmVxdWlyZSgnLi9zaWduYWxpbmcvd2ViX3NvY2tldF9jaGFubmVsJykuV2ViU29ja2V0Q2hhbm5lbDtcblxuICBNdWNTaWduYWxpbmcgPSByZXF1aXJlKCcuL3NpZ25hbGluZy9tdWNfc2lnbmFsaW5nJykuTXVjU2lnbmFsaW5nO1xuXG4gIFJlbW90ZVBlZXIgPSByZXF1aXJlKCcuL3JlbW90ZV9wZWVyJykuUmVtb3RlUGVlcjtcblxuICBMb2NhbFBlZXIgPSByZXF1aXJlKCcuL2xvY2FsX3BlZXInKS5Mb2NhbFBlZXI7XG5cbiAgUGVlckNvbm5lY3Rpb24gPSByZXF1aXJlKCcuL3BlZXJfY29ubmVjdGlvbicpLlBlZXJDb25uZWN0aW9uO1xuXG5cbiAgLyoqXG4gICAqIEBtb2R1bGUgcnRjXG4gICAqL1xuXG5cbiAgLyoqXG4gICAqIEEgdmlydHVhbCByb29tIHdoaWNoIGNvbm5lY3RzIG11bHRpcGxlIFBlZXJzXG4gICAqIEBjbGFzcyBydGMuUm9vbVxuICAjXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcm9vbS4gV2lsbCBiZSBwYXNzZWQgb24gdG8gc2lnbmFsaW5nXG4gICAqIEBwYXJhbSB7cnRjLlNpZ25hbGluZyB8IFN0cmluZ30gc2lnbmFsaW5nIFRoZSBzaWduYWxpbmcgdG8gYmUgdXNlZC4gSWYgeW91IHBhc3MgYSBzdHJpbmcgaXQgd2lsbCBiZSBpbnRlcnByZXRlZCBhcyBhIHdlYnNvY2tldCBhZGRyZXNzIGFuZCBhIHBhbGF2YSBzaWduYWxpbmcgY29ubmVjdGlvbiB3aWxsIGJlIGVzdGFibGlzaGVkIHdpdGggaXQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVmFyaW91cyBvcHRpb25zIHRvIGJlIHVzZWQgaW4gY29ubmVjdGlvbnMgY3JlYXRlZCBieSB0aGlzIHJvb21cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hdXRvX2Nvbm5lY3Q9dHJ1ZV0gV2hldGhlciByZW1vdGUgcGVlcnMgYXJlIGNvbm5lY3RlZCBhdXRvbWF0aWNhbGx5IG9yIGFuIGV4cGxpY2l0IGBSZW1vdGVQZWVyLmNvbm5lY3QoKWAgY2FsbCBpcyBuZWVkZWRcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnN0dW5dIFRoZSBVUkkgb2YgdGhlIFNUVU4gc2VydmVyIHRvIHVzZVxuICAgKiBAcGFyYW0ge3J0Yy5Mb2NhbFBlZXJ9IFtvcHRpb25zLmxvY2FsXSBUaGUgbG9jYWwgdXNlclxuICAgKi9cblxuICBleHBvcnRzLlJvb20gPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChSb29tLCBzdXBlckNsYXNzKTtcblxuXG4gICAgLyoqXG4gICAgICogQSBuZXcgcGVlciBpcyBlbmNvdW50ZXJlZCBpbiB0aGUgcm9vbS4gRmlyZXMgb24gbmV3IHJlbW90ZSBwZWVycyBhZnRlciBqb2luaW5nIGFuZCBmb3IgYWxsIHBlZXJzIGluIHRoZSByb29tIHdoZW4gam9pbmluZy5cbiAgICAgKiBAZXZlbnQgcGVlcl9qb3BpbmVkXG4gICAgICogQHBhcmFtIHtydGMuUmVtb3RlUGVlcn0gcGVlciBUaGUgbmV3IHBlZXJcbiAgICAgKi9cblxuXG4gICAgLyoqXG4gICAgICogQSBwZWVyIGxlZnQgdGhlIHJvb20uXG4gICAgICogQGV2ZW50IHBlZXJfbGVmdFxuICAgICAqIEBwYXJhbSB7cnRjLlJlbW90ZVBlZXJ9IHBlZXIgVGhlIHBlZXIgd2hpY2ggbGVmdFxuICAgICAqL1xuXG5cbiAgICAvKipcbiAgICAgKiBBIHBlZXIgY2hhbmdlZCBpdHMgc3RhdHVzLlxuICAgICAqIEBldmVudCBwZWVyX3N0YXR1c19jaGFuZ2VkXG4gICAgICogQHBhcmFtIHtydGMuUmVtb3RlUGVlcn0gcGVlciBUaGUgcGVlciB3aGljaCBjaGFuZ2VkIGl0cyBzdGF0dXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3RhdHVzIFRoZSBuZXcgc3RhdHVzXG4gICAgICovXG5cblxuICAgIC8qKlxuICAgICAqIFRoZSBjb25uZWN0aW9uIHRvIHRoZSByb29tIHdhcyBjbG9zZWRcbiAgICAgKiBAZXZlbnQgY2xvc2VkXG4gICAgICovXG5cblxuICAgIC8qKlxuICAgICAqIFRoZSB1bmRlcmx5aW5nIHNpZ25hbGluZyBpbXBsZW1lbnRhdGlvbiBhcyBwcm92aWRlZCBpbiBjb25zdHJ1Y3RvclxuICAgICAqIEBwcm9wZXJ0eSBzaWduYWxpbmdcbiAgICAgKiBAdHlwZSBydGMuc2lnbmFsaW5nLlNpZ25hbGluZ1xuICAgICAqL1xuXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbG9jYWwgcGVlclxuICAgICAqIEBwcm9wZXJ0eSBsb2NhbFxuICAgICAqIEB0eXBlIHJ0Yy5Mb2NhbFBlZXJcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFJvb20oc2lnbmFsaW5nLCBvcHRpb25zKSB7XG4gICAgICB2YXIgY2hhbm5lbDtcbiAgICAgIHRoaXMuc2lnbmFsaW5nID0gc2lnbmFsaW5nO1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyAhPSBudWxsID8gb3B0aW9ucyA6IHt9O1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLnNpZ25hbGluZyA9PT0gJ3N0cmluZycgfHwgdGhpcy5zaWduYWxpbmcgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgICAgY2hhbm5lbCA9IG5ldyBXZWJTb2NrZXRDaGFubmVsKHRoaXMuc2lnbmFsaW5nKTtcbiAgICAgICAgdGhpcy5zaWduYWxpbmcgPSBuZXcgTXVjU2lnbmFsaW5nKGNoYW5uZWwpO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2NhbCA9IHRoaXMub3B0aW9ucy5sb2NhbCB8fCBuZXcgTG9jYWxQZWVyKCk7XG4gICAgICB0aGlzLnNpZ25hbGluZy5zZXRTdGF0dXModGhpcy5sb2NhbC5fc3RhdHVzKTtcbiAgICAgIHRoaXMubG9jYWwub24oJ3N0YXR1c19jaGFuZ2VkJywgKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuc2lnbmFsaW5nLnNldFN0YXR1cyhfdGhpcy5sb2NhbC5fc3RhdHVzKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICAgIHRoaXMuc2lnbmFsaW5nLm9uKCdwZWVyX2pvaW5lZCcsIChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oc2lnbmFsaW5nX3BlZXIpIHtcbiAgICAgICAgICB2YXIgcGMsIHBlZXI7XG4gICAgICAgICAgcGMgPSBuZXcgUGVlckNvbm5lY3Rpb24oc2lnbmFsaW5nX3BlZXIuZmlyc3QsIF90aGlzLm9wdGlvbnMpO1xuICAgICAgICAgIHBlZXIgPSBfdGhpcy5jcmVhdGVQZWVyKHBjLCBzaWduYWxpbmdfcGVlcik7XG4gICAgICAgICAgcGVlci5vbignc3RhdHVzX2NoYW5nZWQnLCBmdW5jdGlvbihzdGF0dXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5lbWl0KCdwZWVyX3N0YXR1c19jaGFuZ2VkJywgcGVlciwgc3RhdHVzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwZWVyLm9uKCdsZWZ0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkZWxldGUgX3RoaXMucGVlcnNbc2lnbmFsaW5nX3BlZXIuaWRdO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmVtaXQoJ3BlZXJfbGVmdCcsIHBlZXIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIF90aGlzLnBlZXJzW3NpZ25hbGluZ19wZWVyLmlkXSA9IHBlZXI7XG4gICAgICAgICAgX3RoaXMuZW1pdCgncGVlcl9qb2luZWQnLCBwZWVyKTtcbiAgICAgICAgICByZXR1cm4gcGVlci5vbignY2xvc2VkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVsZXRlIF90aGlzLnBlZXJzW3NpZ25hbGluZ19wZWVyLmlkXTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICAgIHRoaXMucGVlcnMgPSB7fTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEpvaW5zIHRoZSByb29tLiBJbml0aWF0ZXMgY29ubmVjdGlvbiB0byBzaWduYWxpbmcgc2VydmVyIGlmIG5vdCBkb25lIGJlZm9yZS5cbiAgICAgKiBAbWV0aG9kIGpvaW5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBBIHByb21pc2Ugd2hpY2ggd2lsbCBiZSByZXNvbHZlZCBvbmNlIHRoZSByb29tIHdhcyBqb2luZWRcbiAgICAgKi9cblxuICAgIFJvb20ucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmpvaW5fcCA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuam9pbl9wID0gdGhpcy5zaWduYWxpbmcuY29ubmVjdCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuam9pbl9wO1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIExlYXZlcyB0aGUgcm9vbSBhbmQgY2xvc2VzIGFsbCBlc3RhYmxpc2hlZCBwZWVyIGNvbm5lY3Rpb25zXG4gICAgICogQG1ldGhvZCBsZWF2ZVxuICAgICAqL1xuXG4gICAgUm9vbS5wcm90b3R5cGUubGVhdmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNpZ25hbGluZy5sZWF2ZSgpO1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIENsZWFucyB1cCBhbGwgcmVzb3VyY2VzIHVzZWQgYnkgdGhlIHJvb20uXG4gICAgICogQG1ldGhvZCBsZWF2ZVxuICAgICAqL1xuXG4gICAgUm9vbS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2lnbmFsaW5nLmxlYXZlKCk7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHJlbW90ZSBwZWVyLiBPdmVyd3JpdGUgdG8gdXNlIHlvdXIgb3duIGNsYXNzIGZvciBwZWVycy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBtZXRob2QgY3JlYXRlX3BlZXJcbiAgICAgKiBAcGFyYW0ge3J0Yy5QZWVyQ29ubmVjdGlvbn0gcGMgVGhlIFBlZXJDb25uZWN0aW9uIHRvIHRoZSBwZWVyXG4gICAgICogQHBhcmFtIHtydGMuU2lnbmFsaW5nUGVlcn0gc2lnbmFsaW5nX3BlZXIgVGhlIHNpZ25hbGluZyBjb25uZWN0aW9uIHRvIHRoZSBwZWVyXG4gICAgICovXG5cbiAgICBSb29tLnByb3RvdHlwZS5jcmVhdGVQZWVyID0gZnVuY3Rpb24ocGMsIHNpZ25hbGluZ19wZWVyKSB7XG4gICAgICByZXR1cm4gbmV3IFJlbW90ZVBlZXIocGMsIHNpZ25hbGluZ19wZWVyLCB0aGlzLmxvY2FsLCB0aGlzLm9wdGlvbnMpO1xuICAgIH07XG5cbiAgICByZXR1cm4gUm9vbTtcblxuICB9KShFdmVudEVtaXR0ZXIpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjkuMlxuKGZ1bmN0aW9uKCkge1xuICB2YXIgQ2FsbGluZywgQ2FsbGluZ0luSW52aXRhdGlvbiwgQ2FsbGluZ0ludml0YXRpb25Sb29tLCBDYWxsaW5nTmFtZXNwYWNlLCBDYWxsaW5nTmFtZXNwYWNlUm9vbSwgQ2FsbGluZ05hbWVzcGFjZVJvb21QZWVyLCBDYWxsaW5nTmFtZXNwYWNlVXNlciwgQ2FsbGluZ091dEludml0YXRpb24sIENhbGxpbmdQZWVyLCBDYWxsaW5nUm9vbSwgQ2FsbGluZ1NpZ25hbGluZywgQ2FsbGluZ1NpZ25hbGluZ1BlZXIsIERlZmVycmVkLCBFdmVudEVtaXR0ZXIsIFByb21pc2UsIFJlbW90ZVBlZXIsIFJvb20sIGV4dGVuZCwgcmVmLFxuICAgIGV4dGVuZDEgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG4gICAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxuICByZWYgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9wcm9taXNlJyksIFByb21pc2UgPSByZWYuUHJvbWlzZSwgRGVmZXJyZWQgPSByZWYuRGVmZXJyZWQ7XG5cbiAgZXh0ZW5kID0gcmVxdWlyZSgnZXh0ZW5kJyk7XG5cbiAgUm9vbSA9IHJlcXVpcmUoJy4uL3Jvb20nKS5Sb29tO1xuXG4gIFJlbW90ZVBlZXIgPSByZXF1aXJlKCcuLi9yZW1vdGVfcGVlcicpLlJlbW90ZVBlZXI7XG5cbiAgQ2FsbGluZyA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kMShDYWxsaW5nLCBzdXBlckNsYXNzKTtcblxuICAgIGZ1bmN0aW9uIENhbGxpbmcoY2hhbm5lbCwgcm9vbV9vcHRpb25zKSB7XG4gICAgICB2YXIgaGVsbG9fZDtcbiAgICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgICB0aGlzLnJvb21fb3B0aW9ucyA9IHJvb21fb3B0aW9ucztcbiAgICAgIHRoaXMubmV4dF90aWQgPSAwO1xuICAgICAgdGhpcy5hbnN3ZXJzID0ge307XG4gICAgICBoZWxsb19kID0gbmV3IERlZmVycmVkKCk7XG4gICAgICB0aGlzLmhlbGxvX3AgPSBoZWxsb19kLnByb21pc2U7XG4gICAgICB0aGlzLmNoYW5uZWwub24oJ21lc3NhZ2UnLCAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG1zZykge1xuICAgICAgICAgIHZhciBhbnN3ZXIsIGludml0YXRpb24sIHJvb207XG4gICAgICAgICAgX3RoaXMucmVzZXRQaW5nKCk7XG4gICAgICAgICAgc3dpdGNoIChtc2cudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnaGVsbG8nOlxuICAgICAgICAgICAgICBfdGhpcy5pZCA9IG1zZy5pZDtcbiAgICAgICAgICAgICAgcmV0dXJuIGhlbGxvX2QucmVzb2x2ZShtc2cuc2VydmVyKTtcbiAgICAgICAgICAgIGNhc2UgJ2Fuc3dlcic6XG4gICAgICAgICAgICAgIGlmIChtc2cudGlkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnTWlzc2luZyB0cmFuc2FjdGlvbiBpZCBpbiBhbnN3ZXInKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYW5zd2VyID0gX3RoaXMuYW5zd2Vyc1ttc2cudGlkXTtcbiAgICAgICAgICAgICAgZGVsZXRlIF90aGlzLmFuc3dlcnNbbXNnLnRpZF07XG4gICAgICAgICAgICAgIGlmIChhbnN3ZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdBbnN3ZXIgd2l0aG91dCBleHBlY3RpbmcgaXQnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGFuc3dlci5yZXNvbHZlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobXNnLmVycm9yICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBhbnN3ZXIucmVqZWN0KG5ldyBFcnJvcihtc2cuZXJyb3IpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGFuc3dlci5yZXNvbHZlKG1zZy5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG1zZy5lcnJvciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gYW5zd2VyKG5ldyBFcnJvcihtc2cuZXJyb3IpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGFuc3dlcih2b2lkIDAsIG1zZy5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpbnZpdGVfaW5jb21pbmcnOlxuICAgICAgICAgICAgICBpZiAoKG1zZy5oYW5kbGUgPT0gbnVsbCkgfHwgKG1zZy5zZW5kZXIgPT0gbnVsbCkgfHwgIW1zZy5yb29tIHx8IChtc2cuc3RhdHVzID09IG51bGwpIHx8IChtc2cucGVlcnMgPT0gbnVsbCkgfHwgKG1zZy5kYXRhID09IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJJbnZhbGlkIG1lc3NhZ2VcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGludml0YXRpb24gPSBuZXcgQ2FsbGluZ0luSW52aXRhdGlvbihfdGhpcywgbXNnLmhhbmRsZSk7XG4gICAgICAgICAgICAgIHJvb20gPSBuZXcgQ2FsbGluZ0ludml0YXRpb25Sb29tKGludml0YXRpb24sIF90aGlzLnJvb21fb3B0aW9ucywgbXNnLnNlbmRlciwgbXNnLmRhdGEpO1xuICAgICAgICAgICAgICByb29tLnNpZ25hbGluZy5pbml0KG1zZyk7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy5lbWl0KCdpbnZpdGF0aW9uJywgcm9vbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgICAgdGhpcy5jaGFubmVsLm9uKCdjbG9zZWQnLCAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIF90aGlzLmVtaXQoJ2Nsb3NlZCcpO1xuICAgICAgICAgIGlmIChfdGhpcy5waW5nX2ludGVydmFsKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKF90aGlzLnBpbmdfaW50ZXJ2YWwpO1xuICAgICAgICAgICAgcmV0dXJuIGRlbGV0ZSBfdGhpcy5waW5nX2ludGVydmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICB9XG5cbiAgICBDYWxsaW5nLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGFubmVsLmNvbm5lY3QoKS50aGVuKChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgX3RoaXMucmVzZXRQaW5nKCk7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLmhlbGxvX3A7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSk7XG4gICAgfTtcblxuICAgIENhbGxpbmcucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbihtc2csIGNiKSB7XG4gICAgICB2YXIgZGVmZXI7XG4gICAgICBtc2cudGlkID0gdGhpcy5uZXh0X3RpZCsrO1xuICAgICAgdGhpcy5jaGFubmVsLnNlbmQobXNnKTtcbiAgICAgIHRoaXMucmVzZXRQaW5nKCk7XG4gICAgICBpZiAoY2IgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLmFuc3dlcnNbbXNnLnRpZF0gPSBjYjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmVyID0gbmV3IERlZmVycmVkKCk7XG4gICAgICAgIHRoaXMuYW5zd2Vyc1ttc2cudGlkXSA9IGRlZmVyO1xuICAgICAgICByZXR1cm4gZGVmZXIucHJvbWlzZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2FsbGluZy5wcm90b3R5cGUucGluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdCh7XG4gICAgICAgIHR5cGU6ICdwaW5nJ1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIENhbGxpbmcucHJvdG90eXBlLnJlc2V0UGluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMucGluZ190aW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnBpbmdfdGltZW91dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5waW5nX3RpbWVvdXQgPSBzZXRUaW1lb3V0KChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgX3RoaXMucGluZygpO1xuICAgICAgICAgIHJldHVybiBfdGhpcy5yZXNldFBpbmcoKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpLCAyICogNjAgKiAxMDAwKTtcbiAgICB9O1xuXG4gICAgQ2FsbGluZy5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24obnNpZCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgdHlwZTogJ25zX3N1YnNjcmliZScsXG4gICAgICAgICAgICBuYW1lc3BhY2U6IG5zaWRcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBpZCwgbmFtZXNwYWNlLCByZWYxLCByZWYyLCByb29tLCBzdGF0dXM7XG4gICAgICAgICAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmFtZXNwYWNlID0gbmV3IENhbGxpbmdOYW1lc3BhY2UoX3RoaXMsIG5zaWQpO1xuICAgICAgICAgICAgICByZWYxID0gZGF0YS51c2VycztcbiAgICAgICAgICAgICAgZm9yIChpZCBpbiByZWYxKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzID0gcmVmMVtpZF07XG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlLmFkZFVzZXIoaWQsIHN0YXR1cyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVmMiA9IGRhdGEucm9vbXM7XG4gICAgICAgICAgICAgIGZvciAoaWQgaW4gcmVmMikge1xuICAgICAgICAgICAgICAgIHJvb20gPSByZWYyW2lkXTtcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2UuYWRkUm9vbShpZCwgcm9vbS5zdGF0dXMsIHJvb20ucGVlcnMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKG5hbWVzcGFjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSk7XG4gICAgfTtcblxuICAgIENhbGxpbmcucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24obmFtZXNwYWNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgdHlwZTogJ25zX3VzZXJfcmVnaXN0ZXInLFxuICAgICAgICBuYW1lc3BhY2U6IG5hbWVzcGFjZVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIENhbGxpbmcucHJvdG90eXBlLnVucmVnaXN0ZXIgPSBmdW5jdGlvbihuYW1lc3BhY2UpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICB0eXBlOiAnbnNfdXNlcl91bnJlZ2lzdGVyJyxcbiAgICAgICAgbmFtZXNwYWNlOiBuYW1lc3BhY2VcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBDYWxsaW5nLnByb3RvdHlwZS5yb29tID0gZnVuY3Rpb24ocm9vbSwgb3B0aW9ucykge1xuICAgICAgdmFyIHNpZ25hbGluZztcbiAgICAgIHNpZ25hbGluZyA9IHRoaXMucm9vbV9zaWduYWxpbmcocm9vbSk7XG4gICAgICByZXR1cm4gbmV3IENhbGxpbmdSb29tKHNpZ25hbGluZywgb3B0aW9ucyB8fCB0aGlzLnJvb21fb3B0aW9ucyk7XG4gICAgfTtcblxuICAgIENhbGxpbmcucHJvdG90eXBlLnJvb21fc2lnbmFsaW5nID0gZnVuY3Rpb24ocm9vbSkge1xuICAgICAgcmV0dXJuIG5ldyBDYWxsaW5nU2lnbmFsaW5nKHRoaXMsIChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oc3RhdHVzLCBjYikge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgIHR5cGU6ICdyb29tX2pvaW4nLFxuICAgICAgICAgICAgcm9vbTogcm9vbSxcbiAgICAgICAgICAgIHN0YXR1czogc3RhdHVzXG4gICAgICAgICAgfSwgY2IpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgIH07XG5cbiAgICBDYWxsaW5nLnByb3RvdHlwZS5zZXRTdGF0dXMgPSBmdW5jdGlvbihzdGF0dXMpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICB0eXBlOiAnc3RhdHVzJyxcbiAgICAgICAgc3RhdHVzOiBzdGF0dXNcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBDYWxsaW5nLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5jbG9zZSgpO1xuICAgIH07XG5cbiAgICByZXR1cm4gQ2FsbGluZztcblxuICB9KShFdmVudEVtaXR0ZXIpO1xuXG4gIENhbGxpbmdOYW1lc3BhY2UgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZDEoQ2FsbGluZ05hbWVzcGFjZSwgc3VwZXJDbGFzcyk7XG5cbiAgICBmdW5jdGlvbiBDYWxsaW5nTmFtZXNwYWNlKGNhbGxpbmcsIGlkMSkge1xuICAgICAgdmFyIG1lc3NhZ2VfaGFuZGxlcjtcbiAgICAgIHRoaXMuY2FsbGluZyA9IGNhbGxpbmc7XG4gICAgICB0aGlzLmlkID0gaWQxO1xuICAgICAgdGhpcy51c2VycyA9IHt9O1xuICAgICAgdGhpcy5yb29tcyA9IHt9O1xuICAgICAgbWVzc2FnZV9oYW5kbGVyID0gKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihtc2cpIHtcbiAgICAgICAgICB2YXIgcGVlciwgcm9vbSwgdXNlcjtcbiAgICAgICAgICBpZiAobXNnLm5hbWVzcGFjZSAhPT0gX3RoaXMuaWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3dpdGNoIChtc2cudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnbnNfdXNlcl9hZGQnOlxuICAgICAgICAgICAgICBpZiAoKG1zZy51c2VyID09IG51bGwpIHx8IChtc2cuc3RhdHVzID09IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0ludmFsaWQgbWVzc2FnZScpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuYWRkVXNlcihtc2cudXNlciwgbXNnLnN0YXR1cyk7XG4gICAgICAgICAgICBjYXNlICduc191c2VyX3VwZGF0ZSc6XG4gICAgICAgICAgICAgIGlmICgobXNnLnVzZXIgPT0gbnVsbCkgfHwgKG1zZy5zdGF0dXMgPT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnSW52YWxpZCBtZXNzYWdlJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHVzZXIgPSBfdGhpcy51c2Vyc1ttc2cudXNlcl07XG4gICAgICAgICAgICAgIGlmICh1c2VyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVW5rbm93biB1c2VyIGluIHN0YXR1cyBjaGFuZ2UnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdXNlci5zdGF0dXMgPSBtc2cuc3RhdHVzO1xuICAgICAgICAgICAgICBfdGhpcy5lbWl0KCd1c2VyX2NoYW5nZWQnLCB1c2VyKTtcbiAgICAgICAgICAgICAgX3RoaXMuZW1pdCgndXNlcl9zdGF0dXNfY2hhbmdlZCcsIHVzZXIsIHVzZXIuc3RhdHVzKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHVzZXIuZW1pdCgnc3RhdHVzX2NoYW5nZWQnLCB1c2VyLnN0YXR1cyk7XG4gICAgICAgICAgICBjYXNlICduc191c2VyX3JtJzpcbiAgICAgICAgICAgICAgaWYgKG1zZy51c2VyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnSW52YWxpZCBtZXNzYWdlJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHVzZXIgPSBfdGhpcy51c2Vyc1ttc2cudXNlcl07XG4gICAgICAgICAgICAgIGlmICh1c2VyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVW5rbm93biB1c2VyIGxlYXZpbmcnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVsZXRlIF90aGlzLnVzZXJzW21zZy51c2VyXTtcbiAgICAgICAgICAgICAgX3RoaXMuZW1pdCgndXNlcl9jaGFuZ2VkJywgdXNlcik7XG4gICAgICAgICAgICAgIF90aGlzLmVtaXQoJ3VzZXJfbGVmdCcsIHVzZXIpO1xuICAgICAgICAgICAgICByZXR1cm4gdXNlci5lbWl0KCdsZWZ0Jyk7XG4gICAgICAgICAgICBjYXNlICduc19yb29tX2FkZCc6XG4gICAgICAgICAgICAgIGlmICgobXNnLnJvb20gPT0gbnVsbCkgfHwgKG1zZy5zdGF0dXMgPT0gbnVsbCkgfHwgKG1zZy5wZWVycyA9PSBudWxsKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdJbnZhbGlkIG1lc3NhZ2UnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmFkZFJvb20obXNnLnJvb20sIG1zZy5zdGF0dXMsIG1zZy5wZWVycyk7XG4gICAgICAgICAgICBjYXNlICduc19yb29tX3VwZGF0ZSc6XG4gICAgICAgICAgICAgIGlmICgobXNnLnJvb20gPT0gbnVsbCkgfHwgKG1zZy5zdGF0dXMgPT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnSW52YWxpZCBtZXNzYWdlJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJvb20gPSBfdGhpcy5yb29tc1ttc2cucm9vbV07XG4gICAgICAgICAgICAgIGlmIChyb29tID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnSW52YWxpZCByb29tJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJvb20uc3RhdHVzID0gbXNnLnN0YXR1cztcbiAgICAgICAgICAgICAgX3RoaXMuZW1pdCgncm9vbV9jaGFuZ2VkJywgcm9vbSk7XG4gICAgICAgICAgICAgIF90aGlzLmVtaXQoJ3Jvb21fc3RhdHVzX2NoYW5nZWQnLCByb29tLCByb29tLnN0YXR1cyk7XG4gICAgICAgICAgICAgIHJldHVybiByb29tLmVtaXQoJ3N0YXR1c19jaGFuZ2VkJywgcm9vbS5zdGF0dXMpO1xuICAgICAgICAgICAgY2FzZSAnbnNfcm9vbV9ybSc6XG4gICAgICAgICAgICAgIGlmIChtc2cucm9vbSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0ludmFsaWQgbWVzc2FnZScpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByb29tID0gX3RoaXMucm9vbXNbbXNnLnJvb21dO1xuICAgICAgICAgICAgICBpZiAocm9vbSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0ludmFsaWQgcm9vbScpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkZWxldGUgX3RoaXMucm9vbXNbbXNnLnJvb21dO1xuICAgICAgICAgICAgICBfdGhpcy5lbWl0KCdyb29tX2NoYW5nZWQnLCByb29tKTtcbiAgICAgICAgICAgICAgX3RoaXMuZW1pdCgncm9vbV9jbG9zZWQnKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJvb20uZW1pdCgnY2xvc2VkJyk7XG4gICAgICAgICAgICBjYXNlICduc19yb29tX3BlZXJfYWRkJzpcbiAgICAgICAgICAgICAgaWYgKChtc2cucm9vbSA9PSBudWxsKSB8fCAobXNnLnVzZXIgPT0gbnVsbCkgfHwgKG1zZy5zdGF0dXMgPT0gbnVsbCkgfHwgKG1zZy5wZW5kaW5nID09IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0ludmFsaWQgbWVzc2FnZScpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByb29tID0gX3RoaXMucm9vbXNbbXNnLnJvb21dO1xuICAgICAgICAgICAgICBpZiAocm9vbSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0ludmFsaWQgcm9vbScpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwZWVyID0gcm9vbS5hZGRQZWVyKG1zZy51c2VyLCBtc2cuc3RhdHVzLCBtc2cucGVuZGluZyk7XG4gICAgICAgICAgICAgIF90aGlzLmVtaXQoJ3Jvb21fY2hhbmdlZCcsIHJvb20pO1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZW1pdCgncm9vbV9wZWVyX2pvaW5lZCcsIHJvb20sIHBlZXIpO1xuICAgICAgICAgICAgY2FzZSAnbnNfcm9vbV9wZWVyX3VwZGF0ZSc6XG4gICAgICAgICAgICAgIGlmICgobXNnLnJvb20gPT0gbnVsbCkgfHwgKG1zZy51c2VyID09IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0ludmFsaWQgbWVzc2FnZScpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByb29tID0gX3RoaXMucm9vbXNbbXNnLnJvb21dO1xuICAgICAgICAgICAgICBwZWVyID0gcm9vbSAhPSBudWxsID8gcm9vbS5wZWVyc1ttc2cudXNlcl0gOiB2b2lkIDA7XG4gICAgICAgICAgICAgIGlmIChwZWVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnSW52YWxpZCBwZWVyJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChtc2cuc3RhdHVzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwZWVyLnN0YXR1cyA9IG1zZy5zdGF0dXM7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdCgncm9vbV9jaGFuZ2VkJywgcm9vbSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdCgncm9vbV9wZWVyX3N0YXR1c19jaGFuZ2VkJywgcm9vbSwgcGVlciwgcGVlci5zdGF0dXMpO1xuICAgICAgICAgICAgICAgIHBlZXIuZW1pdCgnc3RhdHVzX2NoYW5nZWQnLCBwZWVyLnN0YXR1cyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKChtc2cucGVuZGluZyAhPSBudWxsKSAmJiBtc2cucGVuZGluZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBwZWVyLnBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBwZWVyLmFjY2VwdGVkX2QucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoJ3Jvb21fY2hhbmdlZCcsIHJvb20pO1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoJ3BlZXJfYWNjZXB0ZWQnLCBwZWVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGVlci5lbWl0KCdhY2NlcHRlZCcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbnNfcm9vbV9wZWVyX3JtJzpcbiAgICAgICAgICAgICAgaWYgKChtc2cucm9vbSA9PSBudWxsKSB8fCAobXNnLnVzZXIgPT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnSW52YWxpZCBtZXNzYWdlJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJvb20gPSBfdGhpcy5yb29tc1ttc2cucm9vbV07XG4gICAgICAgICAgICAgIHBlZXIgPSByb29tICE9IG51bGwgPyByb29tLnBlZXJzW21zZy51c2VyXSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgaWYgKHBlZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdJbnZhbGlkIHBlZXInKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVsZXRlIF90aGlzLnJvb21zW21zZy5yb29tXS5wZWVyc1ttc2cudXNlcl07XG4gICAgICAgICAgICAgIF90aGlzLmVtaXQoJ3Jvb21fY2hhbmdlZCcsIHJvb20pO1xuICAgICAgICAgICAgICBfdGhpcy5lbWl0KCdyb29tX3BlZXJfbGVmdCcsIHJvb20sIHBlZXIpO1xuICAgICAgICAgICAgICByZXR1cm4gcGVlci5lbWl0KCdsZWZ0Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSkodGhpcyk7XG4gICAgICB0aGlzLmNhbGxpbmcuY2hhbm5lbC5vbignbWVzc2FnZScsIG1lc3NhZ2VfaGFuZGxlcik7XG4gICAgICB0aGlzLm9uKCd1bnN1YnNjcmliZWQnLCAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5jYWxsaW5nLmNoYW5uZWwucmVtb3ZlTGlzdGVuZXIoJ21lc3NhZ2UnLCBtZXNzYWdlX2hhbmRsZXIpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgIH1cblxuICAgIENhbGxpbmdOYW1lc3BhY2UucHJvdG90eXBlLmFkZFVzZXIgPSBmdW5jdGlvbihpZCwgc3RhdHVzKSB7XG4gICAgICB2YXIgdXNlcjtcbiAgICAgIHVzZXIgPSBuZXcgQ2FsbGluZ05hbWVzcGFjZVVzZXIoaWQsIHN0YXR1cyk7XG4gICAgICB0aGlzLnVzZXJzW2lkXSA9IHVzZXI7XG4gICAgICB0aGlzLmVtaXQoJ3VzZXJfY2hhbmdlZCcsIHVzZXIpO1xuICAgICAgdGhpcy5lbWl0KCd1c2VyX3JlZ2lzdGVyZWQnLCB1c2VyKTtcbiAgICAgIHJldHVybiB1c2VyO1xuICAgIH07XG5cbiAgICBDYWxsaW5nTmFtZXNwYWNlLnByb3RvdHlwZS5hZGRSb29tID0gZnVuY3Rpb24oaWQsIHN0YXR1cywgcGVlcnMpIHtcbiAgICAgIHZhciBwZWVyLCBwZWVyX2lkLCByb29tO1xuICAgICAgcm9vbSA9IG5ldyBDYWxsaW5nTmFtZXNwYWNlUm9vbShpZCwgc3RhdHVzKTtcbiAgICAgIGZvciAocGVlcl9pZCBpbiBwZWVycykge1xuICAgICAgICBwZWVyID0gcGVlcnNbcGVlcl9pZF07XG4gICAgICAgIHJvb20uYWRkUGVlcihwZWVyX2lkLCBwZWVyLnN0YXR1cywgcGVlci5wZW5kaW5nKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucm9vbXNbaWRdID0gcm9vbTtcbiAgICAgIHRoaXMuZW1pdCgncm9vbV9jaGFuZ2VkJywgcm9vbSk7XG4gICAgICB0aGlzLmVtaXQoJ3Jvb21fcmVnaXN0ZXJlZCcsIHJvb20pO1xuICAgICAgcmV0dXJuIHJvb207XG4gICAgfTtcblxuICAgIENhbGxpbmdOYW1lc3BhY2UucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuY2FsbGluZy5yZXF1ZXN0KHtcbiAgICAgICAgICAgIHR5cGU6ICduc191bnN1YnNjcmliZScsXG4gICAgICAgICAgICBuYW1lc3BhY2U6IF90aGlzLmlkXG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICB2YXIgXywgcmVmMSwgdXNlcjtcbiAgICAgICAgICAgIGlmIChlcnIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWYxID0gX3RoaXMudXNlcnM7XG4gICAgICAgICAgICAgIGZvciAoXyBpbiByZWYxKSB7XG4gICAgICAgICAgICAgICAgdXNlciA9IHJlZjFbX107XG4gICAgICAgICAgICAgICAgdXNlci5lbWl0KCdsZWZ0Jyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgX3RoaXMudXNlcnMgPSB7fTtcbiAgICAgICAgICAgICAgX3RoaXMuZW1pdCgndW5zdWJzY3JpYmVkJyk7XG4gICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBDYWxsaW5nTmFtZXNwYWNlO1xuXG4gIH0pKEV2ZW50RW1pdHRlcik7XG5cbiAgQ2FsbGluZ05hbWVzcGFjZVVzZXIgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZDEoQ2FsbGluZ05hbWVzcGFjZVVzZXIsIHN1cGVyQ2xhc3MpO1xuXG4gICAgZnVuY3Rpb24gQ2FsbGluZ05hbWVzcGFjZVVzZXIoaWQxLCBzdGF0dXMxLCBwZW5kaW5nMSkge1xuICAgICAgdGhpcy5pZCA9IGlkMTtcbiAgICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzMTtcbiAgICAgIHRoaXMucGVuZGluZyA9IHBlbmRpbmcxO1xuICAgIH1cblxuICAgIHJldHVybiBDYWxsaW5nTmFtZXNwYWNlVXNlcjtcblxuICB9KShFdmVudEVtaXR0ZXIpO1xuXG4gIENhbGxpbmdOYW1lc3BhY2VSb29tID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQxKENhbGxpbmdOYW1lc3BhY2VSb29tLCBzdXBlckNsYXNzKTtcblxuICAgIGZ1bmN0aW9uIENhbGxpbmdOYW1lc3BhY2VSb29tKGlkMSwgc3RhdHVzMSkge1xuICAgICAgdGhpcy5pZCA9IGlkMTtcbiAgICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzMTtcbiAgICAgIHRoaXMucGVlcnMgPSB7fTtcbiAgICB9XG5cbiAgICBDYWxsaW5nTmFtZXNwYWNlUm9vbS5wcm90b3R5cGUuYWRkUGVlciA9IGZ1bmN0aW9uKGlkLCBzdGF0dXMsIHBlbmRpbmcpIHtcbiAgICAgIHZhciBwZWVyO1xuICAgICAgcGVlciA9IG5ldyBDYWxsaW5nTmFtZXNwYWNlUm9vbVBlZXIoaWQsIHN0YXR1cywgcGVuZGluZyk7XG4gICAgICB0aGlzLnBlZXJzW2lkXSA9IHBlZXI7XG4gICAgICB0aGlzLmVtaXQoJ3BlZXJfam9pbmVkJywgcGVlcik7XG4gICAgICByZXR1cm4gcGVlcjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIENhbGxpbmdOYW1lc3BhY2VSb29tO1xuXG4gIH0pKEV2ZW50RW1pdHRlcik7XG5cbiAgQ2FsbGluZ05hbWVzcGFjZVJvb21QZWVyID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQxKENhbGxpbmdOYW1lc3BhY2VSb29tUGVlciwgc3VwZXJDbGFzcyk7XG5cbiAgICBmdW5jdGlvbiBDYWxsaW5nTmFtZXNwYWNlUm9vbVBlZXIoaWQxLCBzdGF0dXMxLCBwZW5kaW5nMSkge1xuICAgICAgdGhpcy5pZCA9IGlkMTtcbiAgICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzMTtcbiAgICAgIHRoaXMucGVuZGluZyA9IHBlbmRpbmcxO1xuICAgICAgdGhpcy5hY2NlcHRlZF9kID0gbmV3IERlZmVycmVkKCk7XG4gICAgICBpZiAoIXRoaXMucGVuZGluZykge1xuICAgICAgICB0aGlzLmFjY2VwdGVkX2QucmVzb2x2ZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5vbignbGVmdCcsIChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLmFjY2VwdGVkX2QucmVqZWN0KFwiUGVlciBsZWZ0XCIpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgIH1cblxuICAgIENhbGxpbmdOYW1lc3BhY2VSb29tUGVlci5wcm90b3R5cGUuYWNjZXB0ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmFjY2VwdGVkX2QucHJvbWlzZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIENhbGxpbmdOYW1lc3BhY2VSb29tUGVlcjtcblxuICB9KShFdmVudEVtaXR0ZXIpO1xuXG4gIENhbGxpbmdTaWduYWxpbmcgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZDEoQ2FsbGluZ1NpZ25hbGluZywgc3VwZXJDbGFzcyk7XG5cbiAgICBmdW5jdGlvbiBDYWxsaW5nU2lnbmFsaW5nKGNhbGxpbmcsIGNvbm5lY3RfZnVuKSB7XG4gICAgICB2YXIgbWVzc2FnZV9oYW5kbGVyO1xuICAgICAgdGhpcy5jYWxsaW5nID0gY2FsbGluZztcbiAgICAgIHRoaXMuY29ubmVjdF9mdW4gPSBjb25uZWN0X2Z1bjtcbiAgICAgIHRoaXMucGVlcl9zdGF0dXMgPSB7fTtcbiAgICAgIHRoaXMucGVlcnMgPSB7fTtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgIG1lc3NhZ2VfaGFuZGxlciA9IChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24obXNnKSB7XG4gICAgICAgICAgdmFyIHBlZXI7XG4gICAgICAgICAgaWYgKG1zZy5yb29tICE9PSBfdGhpcy5pZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzd2l0Y2ggKG1zZy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdyb29tX3VwZGF0ZSc6XG4gICAgICAgICAgICAgIGlmIChtc2cuc3RhdHVzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkludmFsaWQgbWVzc2FnZVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgX3RoaXMuc3RhdHVzID0gbXNnLnN0YXR1cztcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmVtaXQoJ3N0YXR1c19jaGFuZ2VkJywgX3RoaXMuc3RhdHVzKTtcbiAgICAgICAgICAgIGNhc2UgJ3Jvb21fcGVlcl9hZGQnOlxuICAgICAgICAgICAgICBpZiAoKG1zZy51c2VyID09IG51bGwpIHx8IChtc2cucGVuZGluZyA9PSBudWxsKSB8fCAobXNnLnN0YXR1cyA9PSBudWxsKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiSW52YWxpZCBtZXNzYWdlXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuYWRkUGVlcihtc2cudXNlciwgbXNnLnN0YXR1cywgbXNnLnBlbmRpbmcsIHRydWUpO1xuICAgICAgICAgICAgY2FzZSAncm9vbV9wZWVyX3JtJzpcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3JlbW92aW5nJyk7XG4gICAgICAgICAgICAgIGlmIChtc2cudXNlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJJbnZhbGlkIG1lc3NhZ2VcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHBlZXIgPSBfdGhpcy5wZWVyc1ttc2cudXNlcl07XG4gICAgICAgICAgICAgIGlmIChwZWVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlVua25vd24gcGVlciBhY2NlcHRlZFwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVsZXRlIF90aGlzLnBlZXJzW21zZy51c2VyXTtcbiAgICAgICAgICAgICAgcGVlci5hY2NlcHRlZF9kLnJlamVjdChcIlVzZXIgbGVmdFwiKTtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3JlbW92ZWQnLCBfdGhpcy5wZWVycyk7XG4gICAgICAgICAgICAgIF90aGlzLmVtaXQoJ3BlZXJfbGVmdCcsIHBlZXIpO1xuICAgICAgICAgICAgICByZXR1cm4gcGVlci5lbWl0KCdsZWZ0Jyk7XG4gICAgICAgICAgICBjYXNlICdyb29tX3BlZXJfdXBkYXRlJzpcbiAgICAgICAgICAgICAgaWYgKG1zZy51c2VyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkludmFsaWQgbWVzc2FnZVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcGVlciA9IF90aGlzLnBlZXJzW21zZy51c2VyXTtcbiAgICAgICAgICAgICAgaWYgKHBlZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVW5rbm93biBwZWVyIGFjY2VwdGVkXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobXNnLnN0YXR1cyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcGVlci5zdGF0dXMgPSBtc2cuc3RhdHVzO1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoJ3BlZXJfc3RhdHVzX2NoYW5nZWQnLCBwZWVyLCBwZWVyLnN0YXR1cyk7XG4gICAgICAgICAgICAgICAgcGVlci5lbWl0KCdzdGF0dXNfY2hhbmdlZCcsIHBlZXIuc3RhdHVzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoKG1zZy5wZW5kaW5nICE9IG51bGwpICYmIG1zZy5wZW5kaW5nID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHBlZXIucGVuZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHBlZXIuYWNjZXB0ZWRfZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdCgncGVlcl9hY2NlcHRlZCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwZWVyLmVtaXQoJ2FjY2VwdGVkJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyb29tX3BlZXJfZnJvbSc6XG4gICAgICAgICAgICAgIGlmICgobXNnLnVzZXIgPT0gbnVsbCkgfHwgKG1zZy5ldmVudCA9PSBudWxsKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiSW52YWxpZCBtZXNzYWdlXCIsIG1zZyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHBlZXIgPSBfdGhpcy5wZWVyc1ttc2cudXNlcl07XG4gICAgICAgICAgICAgIGlmIChwZWVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlVua25vd24gcGVlciBhY2NlcHRlZFwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgX3RoaXMuZW1pdCgncGVlcl9sZWZ0Jyk7XG4gICAgICAgICAgICAgIHJldHVybiBwZWVyLmVtaXQobXNnLmV2ZW50LCBtc2cuZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSkodGhpcyk7XG4gICAgICB0aGlzLmNhbGxpbmcuY2hhbm5lbC5vbignbWVzc2FnZScsIG1lc3NhZ2VfaGFuZGxlcik7XG4gICAgICB0aGlzLm9uKCdsZWZ0JywgKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuY2FsbGluZy5jaGFubmVsLnJlbW92ZUxpc3RlbmVyKCdtZXNzYWdlJywgbWVzc2FnZV9oYW5kbGVyKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICB9XG5cbiAgICBDYWxsaW5nU2lnbmFsaW5nLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgdmFyIGVudHJ5LCByZWYxLCB1c2VyO1xuICAgICAgaWYgKHRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUm9vbSBpcyBhbHJlYWR5IGluaXRpYWxpemVkXCIpO1xuICAgICAgfVxuICAgICAgaWYgKChkYXRhLnJvb20gPT0gbnVsbCkgfHwgKGRhdGEucGVlcnMgPT0gbnVsbCkgfHwgKGRhdGEuc3RhdHVzID09IG51bGwpKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGRhdGEpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGluaXRpYWxpemF0aW9uIGRhdGFcIik7XG4gICAgICB9XG4gICAgICB0aGlzLmlkID0gZGF0YS5yb29tO1xuICAgICAgdGhpcy5zdGF0dXMgPSBkYXRhLnN0YXR1cztcbiAgICAgIHJlZjEgPSBkYXRhLnBlZXJzO1xuICAgICAgZm9yICh1c2VyIGluIHJlZjEpIHtcbiAgICAgICAgZW50cnkgPSByZWYxW3VzZXJdO1xuICAgICAgICB0aGlzLmFkZFBlZXIodXNlciwgZW50cnkuc3RhdHVzLCBlbnRyeS5wZW5kaW5nLCBmYWxzZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgfTtcblxuICAgIENhbGxpbmdTaWduYWxpbmcucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmNvbm5lY3RfcCA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdF9wID0gbmV3IFByb21pc2UoKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNvbm5lY3RfZnVuKF90aGlzLnBlZXJfc3RhdHVzLCBmdW5jdGlvbihlcnIsIHJlcykge1xuICAgICAgICAgICAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBfdGhpcy5pbml0KHJlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghX3RoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJNaXNzaW5nIGluZm9ybWF0aW9uIGZyb20gY29ubmVjdCByZXNwb25zZVwiKSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmNvbm5lY3RfcDtcbiAgICB9O1xuXG4gICAgQ2FsbGluZ1NpZ25hbGluZy5wcm90b3R5cGUuYWRkUGVlciA9IGZ1bmN0aW9uKGlkLCBzdGF0dXMsIHBlbmRpbmcsIGZpcnN0KSB7XG4gICAgICB2YXIgcGVlcjtcbiAgICAgIHBlZXIgPSBuZXcgQ2FsbGluZ1NpZ25hbGluZ1BlZXIodGhpcywgaWQsIHN0YXR1cywgcGVuZGluZywgZmlyc3QpO1xuICAgICAgdGhpcy5wZWVyc1tpZF0gPSBwZWVyO1xuICAgICAgdGhpcy5lbWl0KCdwZWVyX2pvaW5lZCcsIHBlZXIpO1xuICAgICAgcmV0dXJuIHBlZXI7XG4gICAgfTtcblxuICAgIENhbGxpbmdTaWduYWxpbmcucHJvdG90eXBlLmxlYXZlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuY2FsbGluZy5yZXF1ZXN0KHtcbiAgICAgICAgICAgIHR5cGU6ICdyb29tX2xlYXZlJyxcbiAgICAgICAgICAgIHJvb206IF90aGlzLmlkXG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICB2YXIgXywgcGVlciwgcmVmMTtcbiAgICAgICAgICAgIF90aGlzLmVtaXQoJ2xlZnQnKTtcbiAgICAgICAgICAgIHJlZjEgPSBfdGhpcy5wZWVycztcbiAgICAgICAgICAgIGZvciAoXyBpbiByZWYxKSB7XG4gICAgICAgICAgICAgIHBlZXIgPSByZWYxW19dO1xuICAgICAgICAgICAgICBwZWVyLmVtaXQoJ2xlZnQnKTtcbiAgICAgICAgICAgICAgcGVlci5hY2NlcHRlZF9kLnJlamVjdChcIllvdSBsZWZ0IHRoZSByb29tXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICB9O1xuXG4gICAgQ2FsbGluZ1NpZ25hbGluZy5wcm90b3R5cGUuc2V0U3RhdHVzID0gZnVuY3Rpb24oc3RhdHVzKSB7XG4gICAgICB0aGlzLnBlZXJfc3RhdHVzID0gc3RhdHVzO1xuICAgICAgaWYgKHRoaXMuY29ubmVjdF9wICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbGluZy5yZXF1ZXN0KHtcbiAgICAgICAgICB0eXBlOiAncm9vbV9wZWVyX3N0YXR1cycsXG4gICAgICAgICAgcm9vbTogdGhpcy5pZCxcbiAgICAgICAgICBzdGF0dXM6IHN0YXR1c1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2FsbGluZ1NpZ25hbGluZy5wcm90b3R5cGUuaW52aXRlID0gZnVuY3Rpb24odXNlciwgZGF0YSkge1xuICAgICAgaWYgKGRhdGEgPT0gbnVsbCkge1xuICAgICAgICBkYXRhID0ge307XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuY2FsbGluZy5yZXF1ZXN0KHtcbiAgICAgICAgICAgIHR5cGU6ICdpbnZpdGVfc2VuZCcsXG4gICAgICAgICAgICByb29tOiBfdGhpcy5pZCxcbiAgICAgICAgICAgIHVzZXI6IHVzZXIuaWQsXG4gICAgICAgICAgICBkYXRhOiBkYXRhXG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyLCByZXMpIHtcbiAgICAgICAgICAgIHZhciBpbnZpdGF0aW9uO1xuICAgICAgICAgICAgaWYgKGVyciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChyZXMuaGFuZGxlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiSW52YWxpZCByZXNwb25zZVwiKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGludml0YXRpb24gPSBuZXcgQ2FsbGluZ091dEludml0YXRpb24oX3RoaXMuY2FsbGluZywgcmVzLmhhbmRsZSwgdXNlcik7XG4gICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGludml0YXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgIH07XG5cbiAgICBDYWxsaW5nU2lnbmFsaW5nLnByb3RvdHlwZS5zZXRSb29tU3RhdHVzU2FmZSA9IGZ1bmN0aW9uKGtleSwgdmFsdWUsIHByZXZpb3VzKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuY2FsbGluZy5yZXF1ZXN0KHtcbiAgICAgICAgICAgIHR5cGU6ICdyb29tX3N0YXR1cycsXG4gICAgICAgICAgICByb29tOiBfdGhpcy5pZCxcbiAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgY2hlY2s6IHRydWUsXG4gICAgICAgICAgICBwcmV2aW91czogcHJldmlvdXNcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLnN0YXR1c1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICBfdGhpcy5lbWl0KCdzdGF0dXNfY2hhbmdlZCcsIF90aGlzLnN0YXR1cyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgIH07XG5cbiAgICBDYWxsaW5nU2lnbmFsaW5nLnByb3RvdHlwZS5zZXRSb29tU3RhdHVzID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLmNhbGxpbmcucmVxdWVzdCh7XG4gICAgICAgICAgICB0eXBlOiAncm9vbV9zdGF0dXMnLFxuICAgICAgICAgICAgcm9vbTogX3RoaXMuaWQsXG4gICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuc3RhdHVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIF90aGlzLmVtaXQoJ3N0YXR1c19jaGFuZ2VkJywgX3RoaXMuc3RhdHVzKTtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSk7XG4gICAgfTtcblxuICAgIENhbGxpbmdTaWduYWxpbmcucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24obmFtZXNwYWNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYWxsaW5nLnJlcXVlc3Qoe1xuICAgICAgICB0eXBlOiAnbnNfcm9vbV9yZWdpc3RlcicsXG4gICAgICAgIG5hbWVzcGFjZTogbmFtZXNwYWNlLFxuICAgICAgICByb29tOiB0aGlzLmlkXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgQ2FsbGluZ1NpZ25hbGluZy5wcm90b3R5cGUudW5yZWdpc3RlciA9IGZ1bmN0aW9uKG5hbWVzcGFjZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FsbGluZy5yZXF1ZXN0KHtcbiAgICAgICAgdHlwZTogJ25zX3Jvb21fdW5yZWdpc3RlcicsXG4gICAgICAgIG5hbWVzcGFjZTogbmFtZXNwYWNlLFxuICAgICAgICByb29tOiB0aGlzLmlkXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIENhbGxpbmdTaWduYWxpbmc7XG5cbiAgfSkoRXZlbnRFbWl0dGVyKTtcblxuICBDYWxsaW5nU2lnbmFsaW5nUGVlciA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kMShDYWxsaW5nU2lnbmFsaW5nUGVlciwgc3VwZXJDbGFzcyk7XG5cbiAgICBmdW5jdGlvbiBDYWxsaW5nU2lnbmFsaW5nUGVlcihyb29tMSwgaWQxLCBzdGF0dXMxLCBwZW5kaW5nMSwgZmlyc3QxKSB7XG4gICAgICB0aGlzLnJvb20gPSByb29tMTtcbiAgICAgIHRoaXMuaWQgPSBpZDE7XG4gICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1czE7XG4gICAgICB0aGlzLnBlbmRpbmcgPSBwZW5kaW5nMTtcbiAgICAgIHRoaXMuZmlyc3QgPSBmaXJzdDE7XG4gICAgICB0aGlzLmFjY2VwdGVkX2QgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICAgIGlmICghdGhpcy5wZW5kaW5nKSB7XG4gICAgICAgIHRoaXMuYWNjZXB0ZWRfZC5yZXNvbHZlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgQ2FsbGluZ1NpZ25hbGluZ1BlZXIucHJvdG90eXBlLmFjY2VwdGVkID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5hY2NlcHRlZF9kLnByb21pc2U7XG4gICAgfTtcblxuICAgIENhbGxpbmdTaWduYWxpbmdQZWVyLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oZXZlbnQsIGRhdGEpIHtcbiAgICAgIHJldHVybiB0aGlzLnJvb20uY2FsbGluZy5yZXF1ZXN0KHtcbiAgICAgICAgdHlwZTogJ3Jvb21fcGVlcl90bycsXG4gICAgICAgIHJvb206IHRoaXMucm9vbS5pZCxcbiAgICAgICAgdXNlcjogdGhpcy5pZCxcbiAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICBkYXRhOiBkYXRhXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIENhbGxpbmdTaWduYWxpbmdQZWVyO1xuXG4gIH0pKEV2ZW50RW1pdHRlcik7XG5cbiAgQ2FsbGluZ0luSW52aXRhdGlvbiA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kMShDYWxsaW5nSW5JbnZpdGF0aW9uLCBzdXBlckNsYXNzKTtcblxuICAgIGZ1bmN0aW9uIENhbGxpbmdJbkludml0YXRpb24oY2FsbGluZywgaGFuZGxlLCBzZW5kZXIsIGRhdGExKSB7XG4gICAgICB2YXIgbWVzc2FnZV9oYW5kbGVyO1xuICAgICAgdGhpcy5jYWxsaW5nID0gY2FsbGluZztcbiAgICAgIHRoaXMuaGFuZGxlID0gaGFuZGxlO1xuICAgICAgdGhpcy5zZW5kZXIgPSBzZW5kZXI7XG4gICAgICB0aGlzLmRhdGEgPSBkYXRhMTtcbiAgICAgIHRoaXMuY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICBtZXNzYWdlX2hhbmRsZXIgPSAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG1zZykge1xuICAgICAgICAgIGlmIChtc2cuaGFuZGxlICE9PSBfdGhpcy5oYW5kbGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3dpdGNoIChtc2cudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnaW52aXRlX2NhbmNlbGxlZCc6XG4gICAgICAgICAgICAgIF90aGlzLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgIF90aGlzLmVtaXQoJ2NhbmNlbGxlZCcpO1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZW1pdCgnaGFuZGxlZCcsIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKTtcbiAgICAgIHRoaXMuY2FsbGluZy5jaGFubmVsLm9uKCdtZXNzYWdlJywgbWVzc2FnZV9oYW5kbGVyKTtcbiAgICAgIHRoaXMub24oJ2hhbmRsZWQnLCAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5jYWxsaW5nLmNoYW5uZWwucmVtb3ZlTGlzdGVuZXIoJ21lc3NhZ2UnLCBtZXNzYWdlX2hhbmRsZXIpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIENhbGxpbmdJbkludml0YXRpb24ucHJvdG90eXBlLnNpZ25hbGluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBDYWxsaW5nU2lnbmFsaW5nKHRoaXMuY2FsbGluZywgKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihzdGF0dXMsIGNiKSB7XG4gICAgICAgICAgX3RoaXMuZW1pdCgnaGFuZGxlZCcsIHRydWUpO1xuICAgICAgICAgIHJldHVybiBfdGhpcy5jYWxsaW5nLnJlcXVlc3Qoe1xuICAgICAgICAgICAgdHlwZTogJ2ludml0ZV9hY2NlcHQnLFxuICAgICAgICAgICAgaGFuZGxlOiBfdGhpcy5oYW5kbGUsXG4gICAgICAgICAgICBzdGF0dXM6IHN0YXR1c1xuICAgICAgICAgIH0sIGNiKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICB9O1xuXG4gICAgQ2FsbGluZ0luSW52aXRhdGlvbi5wcm90b3R5cGUuZGVueSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5lbWl0KCdoYW5kbGVkJywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHRoaXMuY2FsbGluZy5yZXF1ZXN0KHtcbiAgICAgICAgdHlwZTogJ2ludml0ZV9kZW55JyxcbiAgICAgICAgaGFuZGxlOiB0aGlzLmhhbmRsZVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBDYWxsaW5nSW5JbnZpdGF0aW9uO1xuXG4gIH0pKEV2ZW50RW1pdHRlcik7XG5cbiAgQ2FsbGluZ091dEludml0YXRpb24gPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gQ2FsbGluZ091dEludml0YXRpb24oY2FsbGluZywgaGFuZGxlLCB1c2VyMSkge1xuICAgICAgdmFyIGNsZWFudXAsIG1lc3NhZ2VfaGFuZGxlcjtcbiAgICAgIHRoaXMuY2FsbGluZyA9IGNhbGxpbmc7XG4gICAgICB0aGlzLmhhbmRsZSA9IGhhbmRsZTtcbiAgICAgIHRoaXMudXNlciA9IHVzZXIxO1xuICAgICAgdGhpcy5kZWZlciA9IG5ldyBEZWZlcnJlZCgpO1xuICAgICAgdGhpcy5wZW5kaW5nID0gdHJ1ZTtcbiAgICAgIG1lc3NhZ2VfaGFuZGxlciA9IChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24obXNnKSB7XG4gICAgICAgICAgaWYgKG1zZy5oYW5kbGUgIT09IF90aGlzLmhhbmRsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzd2l0Y2ggKG1zZy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdpbnZpdGVfcmVzcG9uc2UnOlxuICAgICAgICAgICAgICBpZiAobXNnLmFjY2VwdGVkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkludmFsaWQgbWVzc2FnZVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgX3RoaXMucGVuZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZGVmZXIucmVzb2x2ZShtc2cuYWNjZXB0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpO1xuICAgICAgdGhpcy5jYWxsaW5nLmNoYW5uZWwub24oJ21lc3NhZ2UnLCBtZXNzYWdlX2hhbmRsZXIpO1xuICAgICAgY2xlYW51cCA9IChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLmNhbGxpbmcuY2hhbm5lbC5yZW1vdmVMaXN0ZW5lcignbWVzc2FnZScsIG1lc3NhZ2VfaGFuZGxlcik7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKTtcbiAgICAgIHRoaXMuZGVmZXIucHJvbWlzZS50aGVuKGNsZWFudXAsIGNsZWFudXApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIENhbGxpbmdPdXRJbnZpdGF0aW9uLnByb3RvdHlwZS5yZXNwb25zZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVmZXIucHJvbWlzZTtcbiAgICB9O1xuXG4gICAgQ2FsbGluZ091dEludml0YXRpb24ucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5wZW5kaW5nID0gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcy5jYWxsaW5nLnJlcXVlc3Qoe1xuICAgICAgICB0eXBlOiAnaW52aXRlX2NhbmNlbCcsXG4gICAgICAgIGhhbmRsZTogdGhpcy5oYW5kbGVcbiAgICAgIH0pLnRoZW4oKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBfdGhpcy5kZWZlci5yZWplY3QobmV3IEVycm9yKFwiSW52aXRhdGlvbiBjYW5jZWxsZWRcIikpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgIH07XG5cbiAgICByZXR1cm4gQ2FsbGluZ091dEludml0YXRpb247XG5cbiAgfSkoKTtcblxuICBDYWxsaW5nUm9vbSA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kMShDYWxsaW5nUm9vbSwgc3VwZXJDbGFzcyk7XG5cbiAgICBmdW5jdGlvbiBDYWxsaW5nUm9vbShzaWduYWxpbmcsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBleHRlbmQoe1xuICAgICAgICBhdXRvX2Nvbm5lY3Q6IGZhbHNlXG4gICAgICB9LCBvcHRpb25zKTtcbiAgICAgIENhbGxpbmdSb29tLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIHNpZ25hbGluZywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgQ2FsbGluZ1Jvb20ucHJvdG90eXBlLmNyZWF0ZVBlZXIgPSBmdW5jdGlvbihwYywgc2lnbmFsaW5nKSB7XG4gICAgICByZXR1cm4gbmV3IENhbGxpbmdQZWVyKHBjLCBzaWduYWxpbmcsIHRoaXMubG9jYWwsIHRoaXMub3B0aW9ucyk7XG4gICAgfTtcblxuICAgIENhbGxpbmdSb29tLnByb3RvdHlwZS5pbnZpdGUgPSBmdW5jdGlvbih1c2VyKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaWduYWxpbmcuaW52aXRlKHVzZXIpO1xuICAgIH07XG5cbiAgICBDYWxsaW5nUm9vbS5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbihuc2lkKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaWduYWxpbmcucmVnaXN0ZXIobnNpZCk7XG4gICAgfTtcblxuICAgIENhbGxpbmdSb29tLnByb3RvdHlwZS51bnJlZ2lzdGVyID0gZnVuY3Rpb24obnNpZCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2lnbmFsaW5nLnVucmVnaXN0ZXIobnNpZCk7XG4gICAgfTtcblxuICAgIHJldHVybiBDYWxsaW5nUm9vbTtcblxuICB9KShSb29tKTtcblxuICBDYWxsaW5nSW52aXRhdGlvblJvb20gPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZDEoQ2FsbGluZ0ludml0YXRpb25Sb29tLCBzdXBlckNsYXNzKTtcblxuICAgIGZ1bmN0aW9uIENhbGxpbmdJbnZpdGF0aW9uUm9vbShpbnZpdGF0aW9uMSwgb3B0aW9ucywgc2VuZGVyX2lkLCBkYXRhMSkge1xuICAgICAgdGhpcy5pbnZpdGF0aW9uID0gaW52aXRhdGlvbjE7XG4gICAgICB0aGlzLnNlbmRlcl9pZCA9IHNlbmRlcl9pZDtcbiAgICAgIHRoaXMuZGF0YSA9IGRhdGExO1xuICAgICAgQ2FsbGluZ0ludml0YXRpb25Sb29tLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIHRoaXMuaW52aXRhdGlvbi5zaWduYWxpbmcoKSwgb3B0aW9ucyk7XG4gICAgICB0aGlzLmludml0YXRpb24ub24oJ2NhbmNlbGxlZCcsIChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLmVtaXQoJ2NhbmNlbGxlZCcpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgICAgdGhpcy5pbnZpdGF0aW9uLm9uKCdoYW5kbGVkJywgKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihhY2NlcHRlZCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5lbWl0KCdoYW5kbGVkJywgYWNjZXB0ZWQpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgIH1cblxuICAgIENhbGxpbmdJbnZpdGF0aW9uUm9vbS5wcm90b3R5cGUuc2VuZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5wZWVyc1t0aGlzLnNlbmRlcl9pZF07XG4gICAgfTtcblxuICAgIENhbGxpbmdJbnZpdGF0aW9uUm9vbS5wcm90b3R5cGUuZGVueSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW52aXRhdGlvbi5kZW55KCk7XG4gICAgfTtcblxuICAgIHJldHVybiBDYWxsaW5nSW52aXRhdGlvblJvb207XG5cbiAgfSkoQ2FsbGluZ1Jvb20pO1xuXG4gIENhbGxpbmdQZWVyID0gKGZ1bmN0aW9uKHN1cGVyQ2xhc3MpIHtcbiAgICBleHRlbmQxKENhbGxpbmdQZWVyLCBzdXBlckNsYXNzKTtcblxuICAgIGZ1bmN0aW9uIENhbGxpbmdQZWVyKHBjLCBzaWduYWxpbmcsIGxvY2FsLCBvcHRpb25zKSB7XG4gICAgICBDYWxsaW5nUGVlci5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzLCBwYywgc2lnbmFsaW5nLCBsb2NhbCwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgQ2FsbGluZ1BlZXIucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnNpZ25hbGluZy5hY2NlcHRlZCgpLnRoZW4oKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gQ2FsbGluZ1BlZXIuX19zdXBlcl9fLmNvbm5lY3QuY2FsbChfdGhpcyk7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBDYWxsaW5nUGVlcjtcblxuICB9KShSZW1vdGVQZWVyKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBDYWxsaW5nOiBDYWxsaW5nLFxuICAgIENhbGxpbmdOYW1lc3BhY2U6IENhbGxpbmdOYW1lc3BhY2UsXG4gICAgQ2FsbGluZ05hbWVzcGFjZVVzZXI6IENhbGxpbmdOYW1lc3BhY2VVc2VyLFxuICAgIENhbGxpbmdOYW1lc3BhY2VSb29tOiBDYWxsaW5nTmFtZXNwYWNlUm9vbSxcbiAgICBDYWxsaW5nTmFtZXNwYWNlUm9vbVBlZXI6IENhbGxpbmdOYW1lc3BhY2VSb29tUGVlcixcbiAgICBDYWxsaW5nU2lnbmFsaW5nOiBDYWxsaW5nU2lnbmFsaW5nLFxuICAgIENhbGxpbmdTaWduYWxpbmdQZWVyOiBDYWxsaW5nU2lnbmFsaW5nUGVlcixcbiAgICBDYWxsaW5nSW5JbnZpdGF0aW9uOiBDYWxsaW5nSW5JbnZpdGF0aW9uLFxuICAgIENhbGxpbmdPdXRJbnZpdGF0aW9uOiBDYWxsaW5nT3V0SW52aXRhdGlvblxuICB9O1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjkuMlxuKGZ1bmN0aW9uKCkge1xuICB2YXIgRGVmZXJyZWQsIEV2ZW50RW1pdHRlciwgU2lnbmFsaW5nLCBTaWduYWxpbmdQZWVyLCByZWYsXG4gICAgZXh0ZW5kID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuICAgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuICBEZWZlcnJlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3Byb21pc2UnKS5EZWZlcnJlZDtcblxuICByZWYgPSByZXF1aXJlKCcuL3NpZ25hbGluZycpLCBTaWduYWxpbmcgPSByZWYuU2lnbmFsaW5nLCBTaWduYWxpbmdQZWVyID0gcmVmLlNpZ25hbGluZ1BlZXI7XG5cbiAgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG5cbiAgLyoqXG4gICAqIEBtb2R1bGUgcnRjLnNpZ25hbGluZ1xuICAgKi9cblxuXG4gIC8qKlxuICAgKiBTaWduYWxpbmcgcGVlciBmb3IgbXVsdGkgdXNlciBjaGF0cy5cbiAgI1xuICAgKiBGb3IgYSBkZXRhaWxlZCBkZXNjcmlwdGlvbiBvZiB0aGUgc2lnbmFsaW5nIHByb3RvY29sIHNlZSBgcnRjLnNpZ25hbGluZy5NdWNTaWduYWxpbmdgXG4gICNcbiAgICogQGV4dGVuZHMgcnRjLnNpZ25hbGluZy5TaWduYWxpbmdQZWVyXG4gICAqIEBjbGFzcyBydGMuc2lnbmFsaW5nLk11Y1NpZ25hbGluZ1BlZXJcbiAgI1xuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtydGMuc2lnbmFsaW5nLkNoYW5uZWx9IGNoYW5uZWwgVGhlIGNoYW5uZWwgdG8gdGhlIHNpZ2FubGluZyBzZXJ2ZXJcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBlZXJfaWQgVGhlIGlkIG9mIHRoZSByZW1vdGUgcGVlclxuICAgKiBAcGFyYW0ge09iamVjdH0gc3RhdHVzIFRoZSBzdGF0dXMgb2YgdGhlIHJlbW90ZSBwZWVyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmlyc3QgV2hldGhlciB0aGUgbG9jYWwgcGVlciB3YXMgaW4gdGhlIHJvb20gYmVmb3JlIHRoZSByZW1vdGUgcGVlclxuICAgKi9cblxuICBleHBvcnRzLk11Y1NpZ25hbGluZ1BlZXIgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChNdWNTaWduYWxpbmdQZWVyLCBzdXBlckNsYXNzKTtcblxuXG4gICAgLyoqXG4gICAgICogVGhlIGlkIG9mIHRoZSByZW1vdGUgcGVlclxuICAgICAqIEBwcm9wZXJ0eSBpZFxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gTXVjU2lnbmFsaW5nUGVlcihjaGFubmVsLCBpZCwgc3RhdHVzMSwgZmlyc3QpIHtcbiAgICAgIHZhciByZWN2X21zZztcbiAgICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1czE7XG4gICAgICB0aGlzLmZpcnN0ID0gZmlyc3Q7XG4gICAgICByZWN2X21zZyA9IChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgIGlmIChkYXRhLnBlZXIgIT09IF90aGlzLmlkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkYXRhLnR5cGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzd2l0Y2ggKGRhdGEudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnZnJvbSc6XG4gICAgICAgICAgICAgIGlmICgoZGF0YS5ldmVudCA9PSBudWxsKSB8fCAoZGF0YS5kYXRhID09IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy5lbWl0KGRhdGEuZXZlbnQsIGRhdGEuZGF0YSk7XG4gICAgICAgICAgICBjYXNlICdwZWVyX2xlZnQnOlxuICAgICAgICAgICAgICBfdGhpcy5lbWl0KCdsZWZ0Jyk7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy5jaGFubmVsLnJlbW92ZUxpc3RlbmVyKCdtZXNzYWdlJywgcmVjdl9tc2cpO1xuICAgICAgICAgICAgY2FzZSAncGVlcl9zdGF0dXMnOlxuICAgICAgICAgICAgICBfdGhpcy5zdGF0dXMgPSBkYXRhLnN0YXR1cztcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmVtaXQoJ3N0YXR1c19jaGFuZ2VkJywgX3RoaXMuc3RhdHVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKTtcbiAgICAgIHRoaXMuY2hhbm5lbC5vbignbWVzc2FnZScsIHJlY3ZfbXNnKTtcbiAgICB9XG5cbiAgICBNdWNTaWduYWxpbmdQZWVyLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oZXZlbnQsIGRhdGEpIHtcbiAgICAgIGlmIChkYXRhID09IG51bGwpIHtcbiAgICAgICAgZGF0YSA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5zZW5kKHtcbiAgICAgICAgdHlwZTogJ3RvJyxcbiAgICAgICAgcGVlcjogdGhpcy5pZCxcbiAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICBkYXRhOiBkYXRhXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIE11Y1NpZ25hbGluZ1BlZXI7XG5cbiAgfSkoU2lnbmFsaW5nUGVlcik7XG5cblxuICAvKipcbiAgICogU2lnbmFsaW5nIGZvciBtdWx0aSB1c2VyIGNoYXRzXG4gICNcbiAgICogVGhlIGZvbGxvd2luZyBtZXNzYWdlcyBhcmUgc2VudCB0byB0aGUgc2VydmVyOlxuICAjXG4gICAqICAgICAvLyBqb2luIHRoZSByb29tLiBoYXMgdG8gYmUgc2VudCBiZWZvcmUgYW55IG90aGVyIG1lc3NhZ2UuXG4gICAqICAgICAvLyByZXNwb25zZSB3aWxsIGJlICdqb2luZWQnIG9uIHN1Y2Nlc3NcbiAgICogICAgIC8vIG90aGVyIHBlZXJzIGluIHRoZSByb29tIHdpbGwgZ2V0ICdwZWVyX2pvaW5lZCdcbiAgICogICAgIHtcbiAgICogICAgICAgXCJ0eXBlXCI6IFwiam9pblwiLFxuICAgKiAgICAgICBcInN0YXR1c1wiOiB7IC4uIHN0YXR1cyAuLiB9XG4gICAqICAgICB9XG4gICNcbiAgICogICAgIC8vIGxlYXZlIHRoZSByb29tLiBzZXJ2ZXIgd2lsbCBjbG9zZSB0aGUgY29ubmVjdGluby5cbiAgICogICAgIHtcbiAgICogICAgICAgXCJ0eXBlXCI6IFwibGVhdmVcIlxuICAgKiAgICAgfVxuICAjXG4gICAqICAgICAvLyB1cGRhdGUgc3RhdHVzIG9iamVjdFxuICAgKiAgICAgLy8gb3RoZXIgcGVlcnMgd2lsbCBnZXQgJ3BlZXJfc3RhdHVzJ1xuICAgKiAgICAge1xuICAgKiAgICAgICBcInR5cGVcIjogXCJzdGF0dXNcIixcbiAgICogICAgICAgXCJzdGF0dXNcIjogeyAuLiBzdGF0dXMgLi4gfVxuICAgKiAgICAgfVxuICAjXG4gICAqICAgICAvLyBzZW5kIG1lc3NhZ2UgdG8gYSBwZWVyLiB3aWxsIGJlIHJlY2VpdmVkIGFzICdmcm9tJ1xuICAgKiAgICAge1xuICAgKiAgICAgICBcInR5cGVcIjogXCJ0b1wiLFxuICAgKiAgICAgICBcInBlZXJcIjogXCJwZWVyX2lkXCIsXG4gICAqICAgICAgIFwiZXZlbnRcIjogXCJldmVudF9pZFwiLFxuICAgKiAgICAgICBcImRhdGFcIjogeyAuLiBjdXN0b20gZGF0YSAuLiB9XG4gICAqICAgICB9XG4gICNcbiAgICogVGhlIGZvbGxvd2luZyBtZXNzYWdlcyBhcmUgcmVjZWl2ZWQgZm9ybSB0aGUgc2VydmVyOlxuICAjXG4gICAqICAgICAvLyBqb2luZWQgdGhlIHJvb20uIGlzIHRoZSByZXNwb25zZSB0byAnam9pbidcbiAgICogICAgIHtcbiAgICogICAgICAgXCJ0eXBlXCI6IFwiam9pbmVkXCIsXG4gICAqICAgICAgIFwiaWRcIjogXCJvd25faWRcIixcbiAgICogICAgICAgXCJwZWVyc1wiOiB7XG4gICAqICAgICAgICAgXCJwZWVyX2lkXCI6IHsgLi4gc3RhdHVzIC4uIH1cbiAgICogICAgICAgfVxuICAgKiAgICAgfVxuICAjXG4gICAqICAgICAvLyBhbm90aGVyIHBlZXIgam9pbmVkIHRoZSByb29tLlxuICAgKiAgICAge1xuICAgKiAgICAgICBcInR5cGVcIjogXCJwZWVyX2pvaW5lZFwiLFxuICAgKiAgICAgICBcInBlZXJcIjogXCJwZWVyX2lkXCIsXG4gICAqICAgICAgIFwic3RhdHVzXCI6IHsgLi4gc3RhdHVzIC4uIH1cbiAgICogICAgIH1cbiAgI1xuICAgKiAgICAgLy8gYW5vc3RoZXIgcGVlciB1cGRhdGVkIGl0cyBzdGF0dXMgb2JqZWN0IHVzaW5nICdzdGF0dXMnXG4gICAqICAgICB7XG4gICAqICAgICAgIFwidHlwZVwiOiBcInBlZXJfc3RhdHVzXCIsXG4gICAqICAgICAgIFwicGVlclwiOiBcInBlZXJfaWRcIixcbiAgICogICAgICAgXCJzdGF0dXNcIjogeyAuLiBzdGF0dXMgLi4gfVxuICAgKiAgICAgfVxuICAjXG4gICAqICAgICAvLyBhbm90aGVyIHBlZXIgbGVmdCB0aGUgcm9vbVxuICAgKiAgICAge1xuICAgKiAgICAgICBcInR5cGVcIjogXCJwZWVyX2xlZnRcIixcbiAgICogICAgICAgXCJwZWVyXCI6IFwicGVlcl9pZFwiXG4gICAqICAgICB9XG4gICNcbiAgICogICAgIC8vIG1lc3NhZ2UgZnJvbSBhbm90aGVyIHBlZXIgc2VudCBieSAndG8nXG4gICAqICAgICB7XG4gICAqICAgICAgIFwidHlwZVwiOiBcImZyb21cIixcbiAgICogICAgICAgXCJwZWVyXCI6IFwicGVlcl9pZFwiLFxuICAgKiAgICAgICBcImV2ZW50XCI6IFwiZXZlbnRfaWRcIixcbiAgICogICAgICAgXCJkYXRhXCI6IHsgLi4gY3VzdG9tIGRhdGEgLi4gfVxuICAgKiAgICAgfVxuICAjXG4gICAqIFRoZSBtZXNzYWdlcyB0cmFuc21pdHRlZCBpbiB0aGUgYHRvYC9gZnJvbWAgbWVzc2FnZXMgYXJlIGVtaXR0ZWQgYXMgZXZlbnRzIGluIGBNdWNTaWduYWxpbmdQZWVyYFxuICAjXG4gICAqIEBleHRlbmRzIHJ0Yy5zaWduYWxpbmcuU2lnbmFsaW5nXG4gICAqIEBjbGFzcyBydGMuc2lnbmFsaW5nLk11Y1NpZ25hbGluZ1xuICAjXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge3J0Yy5zaWduYWxpbmcuQ2hhbm5lbH0gY2hhbm5lbCBUaGUgY2hhbm5lbCB0byB0aGUgc2lnbmFsaW5nIHNlcnZlclxuICAgKi9cblxuICBleHBvcnRzLk11Y1NpZ25hbGluZyA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKE11Y1NpZ25hbGluZywgc3VwZXJDbGFzcyk7XG5cblxuICAgIC8qKlxuICAgICAqIFRoZSBpZCBvZiB0aGUgbG9jYWwgcGVlci4gT25seSBhdmFpbGFibGUgYWZ0ZXIgam9pbmluZy5cbiAgICAgKiBAcHJvcGVydHkgaWRcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIE11Y1NpZ25hbGluZyhjaGFubmVsKSB7XG4gICAgICB2YXIgam9pbl9kO1xuICAgICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbDtcbiAgICAgIHRoaXMuc3RhdHVzID0ge307XG4gICAgICBqb2luX2QgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICAgIHRoaXMuam9pbl9wID0gam9pbl9kLnByb21pc2U7XG4gICAgICB0aGlzLmNoYW5uZWwub24oJ2Nsb3NlZCcsIChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLmVtaXQoJ2Nsb3NlZCcpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgICAgdGhpcy5jaGFubmVsLm9uKCdtZXNzYWdlJywgKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgdmFyIHBlZXIsIHBlZXJfaWQsIHJlZjEsIHN0YXR1cztcbiAgICAgICAgICBpZiAoZGF0YS50eXBlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3dpdGNoIChkYXRhLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2pvaW5lZCc6XG4gICAgICAgICAgICAgIGlmIChkYXRhLnBlZXJzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVmMSA9IGRhdGEucGVlcnM7XG4gICAgICAgICAgICAgIGZvciAocGVlcl9pZCBpbiByZWYxKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzID0gcmVmMVtwZWVyX2lkXTtcbiAgICAgICAgICAgICAgICBwZWVyID0gbmV3IGV4cG9ydHMuTXVjU2lnbmFsaW5nUGVlcihfdGhpcy5jaGFubmVsLCBwZWVyX2lkLCBzdGF0dXMsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KCdwZWVyX2pvaW5lZCcsIHBlZXIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF90aGlzLmlkID0gZGF0YS5pZDtcbiAgICAgICAgICAgICAgcmV0dXJuIGpvaW5fZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICBjYXNlICdwZWVyX2pvaW5lZCc6XG4gICAgICAgICAgICAgIGlmIChkYXRhLnBlZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwZWVyID0gbmV3IGV4cG9ydHMuTXVjU2lnbmFsaW5nUGVlcihfdGhpcy5jaGFubmVsLCBkYXRhLnBlZXIsIGRhdGEuc3RhdHVzLCB0cnVlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmVtaXQoJ3BlZXJfam9pbmVkJywgcGVlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgIH1cblxuICAgIE11Y1NpZ25hbGluZy5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuY29ubmVjdF9wID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0X3AgPSB0aGlzLmNoYW5uZWwuY29ubmVjdCgpLnRoZW4oKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNoYW5uZWwuc2VuZCh7XG4gICAgICAgICAgICAgIHR5cGU6ICdqb2luJyxcbiAgICAgICAgICAgICAgc3RhdHVzOiBfdGhpcy5zdGF0dXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpKS50aGVuKChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5qb2luX2Q7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdF9wO1xuICAgIH07XG5cbiAgICBNdWNTaWduYWxpbmcucHJvdG90eXBlLnNldFN0YXR1cyA9IGZ1bmN0aW9uKHN0YXR1cykge1xuICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICBpZiAodGhpcy5jb25uZWN0X3ApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdF9wLnRoZW4oKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNoYW5uZWwuc2VuZCh7XG4gICAgICAgICAgICAgIHR5cGU6ICdzdGF0dXMnLFxuICAgICAgICAgICAgICBzdGF0dXM6IHN0YXR1c1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcykpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBNdWNTaWduYWxpbmcucHJvdG90eXBlLmxlYXZlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGFubmVsLnNlbmQoe1xuICAgICAgICB0eXBlOiAnbGVhdmUnXG4gICAgICB9KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVsLmNsb3NlKCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIE11Y1NpZ25hbGluZztcblxuICB9KShTaWduYWxpbmcpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjkuMlxuKGZ1bmN0aW9uKCkge1xuICB2YXIgRGVmZXJyZWQsIFNpZ25hbGluZywgU2lnbmFsaW5nUGVlciwgcmVmLFxuICAgIGV4dGVuZCA9IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHsgZm9yICh2YXIga2V5IGluIHBhcmVudCkgeyBpZiAoaGFzUHJvcC5jYWxsKHBhcmVudCwga2V5KSkgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldOyB9IGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfSBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7IGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7IGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7IHJldHVybiBjaGlsZDsgfSxcbiAgICBoYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHk7XG5cbiAgRGVmZXJyZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbC9wcm9taXNlJykuRGVmZXJyZWQ7XG5cbiAgcmVmID0gcmVxdWlyZSgnLi9zaWduYWxpbmcnKSwgU2lnbmFsaW5nID0gcmVmLlNpZ25hbGluZywgU2lnbmFsaW5nUGVlciA9IHJlZi5TaWduYWxpbmdQZWVyO1xuXG5cbiAgLyoqXG4gICAqIEBtb2R1bGUgcnRjLnNpZ25hbGluZ1xuICAgKi9cblxuXG4gIC8qKlxuICAgKiBTaWduYWxpbmcgcGVlciBjb21wYXRpYmxlIHdpdGggdGhlIGZyYW1pbmcgb2YgcGFsYXZhIHNpZ25hbGluZ1xuICAgKiBAY2xhc3MgcnRjLnNpZ25hbGluZy5QYWxhdmFTaWduYWxpbmdQZWVyXG4gICAqIEBleHRlbmRzIHJ0Yy5zaWduYWxpbmcuU2lnbmFsaW5nUGVlclxuICAgKi9cblxuICBleHBvcnRzLlBhbGF2YVNpZ25hbGluZ1BlZXIgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChQYWxhdmFTaWduYWxpbmdQZWVyLCBzdXBlckNsYXNzKTtcblxuICAgIGZ1bmN0aW9uIFBhbGF2YVNpZ25hbGluZ1BlZXIoY2hhbm5lbCwgaWQsIHN0YXR1czEsIGZpcnN0KSB7XG4gICAgICB2YXIgcmVjdl9tc2c7XG4gICAgICB0aGlzLmNoYW5uZWwgPSBjaGFubmVsO1xuICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXMxO1xuICAgICAgdGhpcy5maXJzdCA9IGZpcnN0O1xuICAgICAgcmVjdl9tc2cgPSAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICBpZiAoZGF0YS5zZW5kZXJfaWQgIT09IF90aGlzLmlkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkYXRhLmV2ZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgIF90aGlzLnNlbmQoJ2Vycm9yJywgXCJJbnZhbGlkIG1lc3NhZ2VcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBfdGhpcy5lbWl0KGRhdGEuZXZlbnQsIGRhdGEuZGF0YSk7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKTtcbiAgICAgIHRoaXMuY2hhbm5lbC5vbignbWVzc2FnZScsIHJlY3ZfbXNnKTtcbiAgICAgIHRoaXMub24oJ3BlZXJfdXBkYXRlZF9zdGF0dXMnLCAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0YXR1cykge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5lbWl0KCdzdGF0dXNfY2hhbmdlZCcsIHN0YXR1cyk7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSk7XG4gICAgICB0aGlzLm9uKCdwZWVyX2xlZnQnLCAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIF90aGlzLmVtaXQoJ2Nsb3NlZCcpO1xuICAgICAgICAgIHJldHVybiBfdGhpcy5jaGFubmVsLnJlbW92ZUxpc3RlbmVyKCdtZXNzYWdlJywgcmVjdl9tc2cpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgIH1cblxuICAgIFBhbGF2YVNpZ25hbGluZ1BlZXIucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihldmVudCwgZGF0YSkge1xuICAgICAgaWYgKGRhdGEgPT0gbnVsbCkge1xuICAgICAgICBkYXRhID0ge307XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5jaGFubmVsLnNlbmQoe1xuICAgICAgICBldmVudDogJ3NlbmRfdG9fcGVlcicsXG4gICAgICAgIHBlZXJfaWQ6IHRoaXMuaWQsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFBhbGF2YVNpZ25hbGluZ1BlZXI7XG5cbiAgfSkoU2lnbmFsaW5nUGVlcik7XG5cblxuICAvKipcbiAgICogU2lnbmFsaW5nIGltcGxlbWVudGF0aW9uIGNvbXBhdGlibGUgd2l0aCB0aGUgZnJhbWluZyBvZiBwYWxhdmEgc2lnbmFsaW5nXG4gICAqIEBjbGFzcyBydGMuc2lnbmFsaW5nLlBhbGF2YVNpZ25hbGluZ1xuICAgKiBAZXh0ZW5kcyBydGMuc2lnbmFsaW5nLlNpZ25hbGluZ1xuICAgKi9cblxuICBleHBvcnRzLlBhbGF2YVNpZ25hbGluZyA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFBhbGF2YVNpZ25hbGluZywgc3VwZXJDbGFzcyk7XG5cbiAgICBmdW5jdGlvbiBQYWxhdmFTaWduYWxpbmcoY2hhbm5lbCwgcm9vbTEsIHN0YXR1czEpIHtcbiAgICAgIHZhciBqb2luX2Q7XG4gICAgICB0aGlzLmNoYW5uZWwgPSBjaGFubmVsO1xuICAgICAgdGhpcy5yb29tID0gcm9vbTE7XG4gICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1czE7XG4gICAgICB0aGlzLnBlZXJzID0ge307XG4gICAgICB0aGlzLmpvaW5lZCA9IGZhbHNlO1xuICAgICAgam9pbl9kID0gbmV3IERlZmVycmVkKCk7XG4gICAgICB0aGlzLmpvaW5fcCA9IGpvaW5fZC5wcm9taXNlO1xuICAgICAgdGhpcy5jaGFubmVsLm9uKCdjbG9zZWQnLCAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5lbWl0KCdjbG9zZWQnKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICAgIHRoaXMuY2hhbm5lbC5vbignbWVzc2FnZScsIChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgIHZhciBpLCBwZWVyLCByZWYxO1xuICAgICAgICAgIGlmIChkYXRhLmV2ZW50ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3dpdGNoIChkYXRhLmV2ZW50KSB7XG4gICAgICAgICAgICBjYXNlICdqb2luZWRfcm9vbSc6XG4gICAgICAgICAgICAgIGlmICgoZGF0YS5wZWVycyA9PSBudWxsKSB8fCAoZGF0YS5vd25faWQgPT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVmMSA9IGRhdGEucGVlcnM7XG4gICAgICAgICAgICAgIGZvciAoaSBpbiByZWYxKSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHJlZjFbaV07XG4gICAgICAgICAgICAgICAgcGVlciA9IG5ldyBleHBvcnRzLlBhbGF2YVNpZ25hbGluZ1BlZXIoX3RoaXMuY2hhbm5lbCwgZGF0YS5wZWVyX2lkLCBkYXRhLnN0YXR1cywgZmFsc2UpO1xuICAgICAgICAgICAgICAgIF90aGlzLnBlZXJzW2RhdGEucGVlcl9pZF0gPSBwZWVyO1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoJ3BlZXJfam9pbmVkJywgcGVlcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGpvaW5fZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICBjYXNlICduZXdfcGVlcic6XG4gICAgICAgICAgICAgIGlmIChkYXRhLnBlZXJfaWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwZWVyID0gbmV3IGV4cG9ydHMuUGFsYXZhU2lnbmFsaW5nUGVlcihfdGhpcy5jaGFubmVsLCBkYXRhLnBlZXJfaWQsIGRhdGEuc3RhdHVzLCB0cnVlKTtcbiAgICAgICAgICAgICAgX3RoaXMucGVlcnNbZGF0YS5wZWVyXSA9IHBlZXI7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy5lbWl0KCdwZWVyX2pvaW5lZCcsIHBlZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICB9XG5cbiAgICBQYWxhdmFTaWduYWxpbmcucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmNvbm5lY3RfcCA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdF9wID0gdGhpcy5jaGFubmVsLmNvbm5lY3QoKS50aGVuKChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5jaGFubmVsLnNlbmQoe1xuICAgICAgICAgICAgICBldmVudDogJ2pvaW5fcm9vbScsXG4gICAgICAgICAgICAgIHJvb21faWQ6IHJvb20sXG4gICAgICAgICAgICAgIHN0YXR1czogc3RhdHVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5jb25uZWN0X3A7XG4gICAgfTtcblxuICAgIFBhbGF2YVNpZ25hbGluZy5wcm90b3R5cGUuc2V0X3N0YXR1cyA9IGZ1bmN0aW9uKHN0YXR1cykge1xuICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbC5zZW5kKHtcbiAgICAgICAgZXZlbnQ6ICd1cGRhdGVfc3RhdHVzJyxcbiAgICAgICAgc3RhdHVzOiBzdGF0dXNcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBQYWxhdmFTaWduYWxpbmcucHJvdG90eXBlLmxlYXZlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGFubmVsLmNsb3NlKCk7XG4gICAgfTtcblxuICAgIHJldHVybiBQYWxhdmFTaWduYWxpbmc7XG5cbiAgfSkoU2lnbmFsaW5nKTtcblxufSkuY2FsbCh0aGlzKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS45LjJcbihmdW5jdGlvbigpIHtcbiAgdmFyIEV2ZW50RW1pdHRlcixcbiAgICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG4gICAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxuXG4gIC8qKlxuICAgKiBAbW9kdWxlIHJ0Yy5zaWduYWxpbmdcbiAgICovXG5cblxuICAvKipcbiAgICogQ29uY2VwdCBvZiBhIGNsYXNzIGltcGxlbWVudGluZyBzaWduYWxpbmcuIE1pZ2h0IHVzZSBhIGBydGMuc2lnbmFsaW5nLkNoYW5uZWxgIHRvIGFic3RyYWN0IHRoZSBjb25uZWN0aW9uIHRvIHRoZSBzZXJ2ZXIuXG4gICNcbiAgICogWW91IGRvIG5vdCBoYXZlIHRvIGV4dGVuZCB0aGlzIGNsYWFzcywganVzdCBpbXBsZW1lbnQgdGhlIGZ1bmN0aW9uYWxpdHkuXG4gICNcbiAgICogQGV4dGVuZHMgZXZlbnRzLkV2ZW50RW1pdHRlclxuICAgKiBAY2xhc3MgcnRjLnNpZ25hbGluZy5TaWduYWxpbmdcbiAgICovXG5cbiAgZXhwb3J0cy5TaWduYWxpbmcgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChTaWduYWxpbmcsIHN1cGVyQ2xhc3MpO1xuXG4gICAgZnVuY3Rpb24gU2lnbmFsaW5nKCkge1xuICAgICAgcmV0dXJuIFNpZ25hbGluZy5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEEgbmV3IHBlZXIgam9pbmVkIHRoZSByb29tXG4gICAgICogQGV2ZW50IHBlZXJfam9pbmVkXG4gICAgICogQHBhcmFtIHtydGMuc2lnbmFsaW5nLlNpZ25hbGluZ1BlZXJ9IHBlZXIgVGhlIG5ldyBwZWVyXG4gICAgICovXG5cblxuICAgIC8qKlxuICAgICAqIFRoZSBjb25uZWN0aW9uIHRvIHRoZSBzaWduYWxpbmcgc2VydmVyIHdhcyBjbG9zZWRcbiAgICAgKiBAZXZlbnQgY2xvc2VkXG4gICAgICovXG5cblxuICAgIC8qKlxuICAgICAqIEVzdGFibGlzaGVzIHRoZSBjb25uZWN0aW9uIHdpdGggdGhlIHNpZ25hbGluZyBzZXJ2ZXJcbiAgICAgKiBAbWV0aG9kIGNvbm5lY3RcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBQcm9taXNlIHdoaWNoIGlzIHJlc29sdmVkIHdoZW4gdGhlIGNvbm5lY3Rpb24gaXMgZXN0YWJsaXNoZWRcbiAgICAgKi9cblxuICAgIFNpZ25hbGluZy5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgY29ubmVjdGlvbiB0byB0aGUgc2lnbmFsaW5nIHNlcnZlclxuICAgICAqIEBtZXRob2QgY2xvc2VcbiAgICAgKi9cblxuICAgIFNpZ25hbGluZy5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBsb2NhbCBzdGF0dXMgb2JqZWN0IGFuZCBicm9hZGNhc3RzIHRoZSBjaGFuZ2UgdG8gdGhlIHBlZXJzXG4gICAgICogQG1ldGhvZCBzZXRTdGF0dXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIE5ldyBzdGF0dXMgb2JqZWN0XG4gICAgICovXG5cbiAgICBTaWduYWxpbmcucHJvdG90eXBlLnNldFN0YXR1cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2lnbmFsaW5nO1xuXG4gIH0pKEV2ZW50RW1pdHRlcik7XG5cblxuICAvKipcbiAgICogQ29uY2VwdCBvZiBhIGNsYXNzIGltcGxlbWVudGluZyBhIHNpZ25hbGluZyBjb25uZWN0aW9uIHRvIGEgcGVlci5cbiAgI1xuICAgKiBZb3UgZG8gbm90IGhhdmUgdG8gZXh0ZW5kIHRoaXMgY2xhc3MsIGp1c3QgaW1wbGVtZW50IHRoZSBmdW5jdGlvbmFsaXR5LlxuICAjXG4gICAqIEBleHRlbmRzIGV2ZW50cy5FdmVudEVtaXR0ZXJcbiAgICogQGNsYXNzIHJ0Yy5zaWduYWxpbmcuU2lnbmFsaW5nUGVlclxuICAgKi9cblxuICBleHBvcnRzLlNpZ25hbGluZ1BlZXIgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChTaWduYWxpbmdQZWVyLCBzdXBlckNsYXNzKTtcblxuICAgIGZ1bmN0aW9uIFNpZ25hbGluZ1BlZXIoKSB7XG4gICAgICByZXR1cm4gU2lnbmFsaW5nUGVlci5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFRoZSByZW1vdGUgcGVlciBsZWZ0IHRoZSByb29tXG4gICAgICogQGV2ZW50IGxlZnRcbiAgICAgKi9cblxuXG4gICAgLyoqXG4gICAgICogUmVjZWl2ZWQgYSBtZXNzYWdlIGZyb20gdGhlIHJlbW90ZSBwZWVyXG4gICAgICogQGV2ZW50IG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgSUQgb2YgdGhlIGV2ZW50XG4gICAgICogQHBhcmFtIHtPYmVqY3R9IGRhdGEgUGF5bG9hZCBvZiB0aGUgZXZlbnRcbiAgICAgKi9cblxuXG4gICAgLyoqXG4gICAgICogVGhlIHN0YXR1cyBvYmplY3Qgb2YgdGhlIHJlbW90ZSBwZWVyIHdhcyB1cGRhdGVkXG4gICAgICogQGV2ZW50IHN0YXR1c19jaGFuZ2VkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0YXR1cyBUaGUgbmV3IHN0YXR1c1xuICAgICAqL1xuXG5cbiAgICAvKipcbiAgICAgKiBUaGUgc3RhdHVzIG9iamVjdCBvZiB0aGUgcmVtb3RlIHBlZXJcbiAgICAgKiBAcHJvcGVydHkgc3RhdHVzXG4gICAgICogQHR5cGUgT2JqZWN0XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG5cblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGxvY2FsIHVzZXIgd2FzIGluIHRoZSByb29tIGJlZm9yZSB0aGUgcmVtb3RlIHVzZXIgKHVzZWQgdG8gZGV0ZXJtaW5lIHdoaWNoIHBlZXIgd2lsbCBpbml0aWF0ZSB0aGUgY29ubmVjdGlvbilcbiAgICAgKiBAcHJvcGVydHkgZmlyc3RcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG5cblxuICAgIC8qKlxuICAgICAqIFNlbmRzIHRoZSBldmVudCB3aXRoIHRoZSBnaXZlbiBwYXlsb2FkIHRvIHRoZSByZW1vdGUgcGVlclxuICAgICAqIEBtZXRob2Qgc2VuZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBUaGUgaWQgb2YgdGhlIGV2ZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgVGhlIHBheWxvYWQgb2YgdGhlIGV2ZW50XG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSB3aGljaCB3aWxsIGJlIHJlc29sdmVkIG9uY2UgdGhlIG1lc3NhZ2UgaXMgc2VudFxuICAgICAqL1xuXG4gICAgU2lnbmFsaW5nUGVlci5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKGV2ZW50LCBkYXRhKSB7XG4gICAgICBpZiAoZGF0YSA9PSBudWxsKSB7XG4gICAgICAgIGRhdGEgPSB7fTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNpZ25hbGluZ1BlZXI7XG5cbiAgfSkoRXZlbnRFbWl0dGVyKTtcblxuXG4gIC8qKlxuICAgKiBDb25jZXB0IG9mIGEgY2xhc3MgaW1wbGVtZW50aW5nIGEgc2lnbmFsaW5nIGNoYW5uZWwuIE1pZ2h0IGJlIHVzZWQgYnkgc2lnbmFsaW5nIGltcGxlbWVudGF0aW9ucyB0byBjb25uZWN0IHRvIGEgc2lnbmFsaW5nIHNlcnZlci5cbiAgI1xuICAgKiBZb3UgZG8gbm90IGhhdmUgdG8gZXh0ZW5kIHRoaXMgY2xhc3MsIGp1c3QgaW1wbGVtZW50IHRoZSBmdW5jdGlvbmFsaXR5LlxuICAjXG4gICAqIEBleHRlbmRzIGV2ZW50cy5FdmVudEVtaXR0ZXJcbiAgICogQGNsYXNzIHJ0Yy5zaWduYWxpbmcuQ2hhbm5lbFxuICAgKi9cblxuICBleHBvcnRzLkNoYW5uZWwgPSAoZnVuY3Rpb24oc3VwZXJDbGFzcykge1xuICAgIGV4dGVuZChDaGFubmVsLCBzdXBlckNsYXNzKTtcblxuICAgIGZ1bmN0aW9uIENoYW5uZWwoKSB7XG4gICAgICByZXR1cm4gQ2hhbm5lbC5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEEgbWVzc2FnZSB3YXMgcmVjZWl2ZWQgZnJvbSB0aGUgc2lnbmFsaW5nIHNlcnZlclxuICAgICAqIEBldmVudCBtZXNzYWdlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1zZyBUaGUgcmVjZWl2ZWQgbWVzc2FnZVxuICAgICAqL1xuXG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29ubmVjdGlvbiB0byB0aGUgc2lnbmFsaW5nIHNlcnZlciB3YXMgY2xvc2VkXG4gICAgICogQGV2ZW50IGNsb3NlZFxuICAgICAqL1xuXG5cbiAgICAvKipcbiAgICAgKiBFc3RhYmxpc2hlcyB0aGUgY29ubmVjdGlvbiB3aXRoIHRoZSBzaWduYWxpbmcgc2VydmVyXG4gICAgICogQG1ldGhvZCBjb25uZWN0XG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSB3aGljaCBpcyByZXNvbHZlZCB3aGVuIHRoZSBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkXG4gICAgICovXG5cbiAgICBDaGFubmVsLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBtZXNzYWdlIHRvIHRoZSBzaWduYWxpbmcgc2VydmVyXG4gICAgICogQG1ldGhvZCBzZW5kXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1zZyBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gUHJvbWlzZSB3aGljaCBpcyByZXNvbHZlZCB3aGVuIHRoZSBtZXNzYWdlIGlzIHNlbnRcbiAgICAgKi9cblxuICAgIENoYW5uZWwucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihtc2cpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9O1xuXG5cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIGNvbm5lY3Rpb24gdG8gdGhlIHNpZ25hbGluZyBzZXJ2ZXJcbiAgICAgKiBAbWV0aG9kIGNsb3NlXG4gICAgICovXG5cbiAgICBDaGFubmVsLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICAgIH07XG5cbiAgICByZXR1cm4gQ2hhbm5lbDtcblxuICB9KShFdmVudEVtaXR0ZXIpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjkuMlxuKGZ1bmN0aW9uKCkge1xuICB2YXIgQ2hhbm5lbCwgUHJvbWlzZSxcbiAgICBleHRlbmQgPSBmdW5jdGlvbihjaGlsZCwgcGFyZW50KSB7IGZvciAodmFyIGtleSBpbiBwYXJlbnQpIHsgaWYgKGhhc1Byb3AuY2FsbChwYXJlbnQsIGtleSkpIGNoaWxkW2tleV0gPSBwYXJlbnRba2V5XTsgfSBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH0gY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlOyBjaGlsZC5wcm90b3R5cGUgPSBuZXcgY3RvcigpOyBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlOyByZXR1cm4gY2hpbGQ7IH0sXG4gICAgaGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LFxuICAgIHNsaWNlID0gW10uc2xpY2U7XG5cbiAgUHJvbWlzZSA9IHJlcXVpcmUoJy4uL2ludGVybmFsL3Byb21pc2UnKS5Qcm9taXNlO1xuXG4gIENoYW5uZWwgPSByZXF1aXJlKCcuL3NpZ25hbGluZycpLkNoYW5uZWw7XG5cblxuICAvKipcbiAgICogQG1vZHVsZSBydGMuc2lnbmFsaW5nXG4gICAqL1xuXG5cbiAgLyoqXG4gICAqIEBjbGFzcyBydGMuc2lnbmFsaW5nLldlYlNvY2tldENoYW5uZWxcbiAgICogQGV4dGVuZHMgcnRjLnNpZ25hbGluZy5DaGFubmVsXG4gICAqL1xuXG4gIGV4cG9ydHMuV2ViU29ja2V0Q2hhbm5lbCA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFdlYlNvY2tldENoYW5uZWwsIHN1cGVyQ2xhc3MpO1xuXG4gICAgZnVuY3Rpb24gV2ViU29ja2V0Q2hhbm5lbCgpIHtcbiAgICAgIHZhciBhZGRyZXNzLCBpLCBsZW4sIHBhcnQsIHBhcnRzO1xuICAgICAgYWRkcmVzcyA9IGFyZ3VtZW50c1swXSwgcGFydHMgPSAyIDw9IGFyZ3VtZW50cy5sZW5ndGggPyBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkgOiBbXTtcbiAgICAgIHRoaXMuYWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgICBpZiAocGFydHMubGVuZ3RoID4gMCkge1xuICAgICAgICB3aGlsZSAodGhpcy5hZGRyZXNzLmVuZHNXaXRoKCcvJykpIHtcbiAgICAgICAgICB0aGlzLmFkZHJlc3MgPSB0aGlzLmFkZHJlc3Muc3Vic3RyKDAsIHRoaXMuYWRkcmVzcy5sZW5ndGggLSAxKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBwYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgICAgICB0aGlzLmFkZHJlc3MgKz0gJy8nICsgZW5jb2RlVXJpQ29tcG9uZW50KHBhcnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgV2ViU29ja2V0Q2hhbm5lbC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuY29ubmVjdF9wID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0X3AgPSBuZXcgUHJvbWlzZSgoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgc29ja2V0O1xuICAgICAgICAgICAgc29ja2V0ID0gbmV3IFdlYlNvY2tldChfdGhpcy5hZGRyZXNzKTtcbiAgICAgICAgICAgIHNvY2tldC5vbm9wZW4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgX3RoaXMuc29ja2V0ID0gc29ja2V0O1xuICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNvY2tldC5vbmVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy5zb2NrZXQ7XG4gICAgICAgICAgICAgIF90aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoXCJVbmFibGUgdG8gY29ubmVjdCB0byBzb2NrZXRcIikpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNvY2tldC5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShldmVudC5kYXRhKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdCgnZXJyb3InLCBcIlVuYWJsZSB0byBwYXJzZSBpbmNvbWluZyBtZXNzYWdlXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZW1pdCgnbWVzc2FnZScsIGRhdGEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBzb2NrZXQub25jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZW1pdCgnY2xvc2VkJyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmNvbm5lY3RfcDtcbiAgICB9O1xuXG4gICAgV2ViU29ja2V0Q2hhbm5lbC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKG1zZykge1xuICAgICAgdmFyIGVycjtcbiAgICAgIGlmICh0aGlzLnNvY2tldCAhPSBudWxsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5zb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeShtc2cpKTtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICAgIGVyciA9IF9lcnJvcjtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIlRyeWluZyB0byBzZW5kIG9uIFdlYlNvY2tldCB3aXRob3V0IGJlaW5nIGNvbm5lY3RlZFwiKSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFdlYlNvY2tldENoYW5uZWwucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZXJyO1xuICAgICAgaWYgKHRoaXMuc29ja2V0ICE9IG51bGwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLnNvY2tldC5jbG9zZSgpO1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgZXJyID0gX2Vycm9yO1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiVHJ5aW5nIHRvIGNsb3NlIFdlYlNvY2tldCB3aXRob3V0IGJlaW5nIGNvbm5lY3RlZFwiKSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBXZWJTb2NrZXRDaGFubmVsO1xuXG4gIH0pKENoYW5uZWwpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjkuMlxuKGZ1bmN0aW9uKCkge1xuICB2YXIgRXZlbnRFbWl0dGVyLCBjb21wYXQsXG4gICAgZXh0ZW5kID0gZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkgeyBmb3IgKHZhciBrZXkgaW4gcGFyZW50KSB7IGlmIChoYXNQcm9wLmNhbGwocGFyZW50LCBrZXkpKSBjaGlsZFtrZXldID0gcGFyZW50W2tleV07IH0gZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9IGN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTsgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTsgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTsgcmV0dXJuIGNoaWxkOyB9LFxuICAgIGhhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuICBjb21wYXQgPSByZXF1aXJlKCcuL2NvbXBhdCcpLmNvbXBhdDtcblxuICBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cblxuICAvKipcbiAgICogQG1vZHVsZSBydGNcbiAgICovXG5cblxuICAvKipcbiAgICogQSB3cmFwcGVyIGFyb3VuZCBhbiBIVE1MNSBNZWRpYVN0cmVhbVxuICAgKiBAY2xhc3MgcnRjLlN0cmVhbVxuICAjXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge1JUQ0RhdGFTdHJlYW19IHN0cmVhbSBUaGUgbmF0aXZlIHN0cmVhbVxuICAgKi9cblxuICBleHBvcnRzLlN0cmVhbSA9IChmdW5jdGlvbihzdXBlckNsYXNzKSB7XG4gICAgZXh0ZW5kKFN0cmVhbSwgc3VwZXJDbGFzcyk7XG5cblxuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbiB0cmFja3MgYXJlIG11dGVkIG9yIHVubXV0ZWQuIE9ubHkgdHJpZ2dlcmVkIHdoZW4gY2hhbmdlcyBhcmVcbiAgICAgKiBtYWRlIHRocm91Z2ggdGhpcyBvYmplY3RzIG11dGUgZnVuY3Rpb25zLlxuICAgICAqIEBldmVudCBtdXRlX2NoYW5nZWRcbiAgICAgKiBAcGFyYW0geydhdWRpbycgfCAndmlkZW8nIHwgJ2JvdGgnfSB0eXBlIFRoZSB0eXBlIG9mIHRyYWNrcyB3aGljaCBjaGFuZ2VkXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBtdXRlZCBgdHJ1ZWAgaWYgdHJhY2tzIHdlcmUgbXV0ZWQsIGBmYWxzZWAgaWYgdGhleSB3ZXJlIHVubXV0ZWRcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFN0cmVhbShzdHJlYW0pIHtcbiAgICAgIHRoaXMuc3RyZWFtID0gc3RyZWFtO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBpZCBvZiB0aGUgc3RyZWFtLiBUaGlzIGlzIG5laXRoZXIgdXNlciBkZWZpbmVkIG5vciBodW1hbiByZWFkYWJsZS5cbiAgICAgKiBAbWV0aG9kIGlkXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgaWQgb2YgdGhlIHVuZGVybHlpbmcgc3RyZWFtXG4gICAgICovXG5cbiAgICBTdHJlYW0ucHJvdG90eXBlLmlkID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdHJlYW0uaWQ7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIHN0cmVhbSBoYXMgYW55IHRyYWNrcyBvZiB0aGUgZ2l2ZW4gdHlwZVxuICAgICAqIEBtZXRob2QgaGFzVHJhY2tzXG4gICAgICogQHBhcmFtIHsnYXVkaW8nIHwgJ3ZpZGVvJyB8ICdib3RoJ30gW3R5cGU9J2JvdGgnXSBUaGUgdHlwZSBvZiB0cmFjayB0byBjaGVjayBmb3JcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBhbW91bnQgb2YgdHJhY2tzIG9mIHRoZSBnaXZlbiB0eXBlXG4gICAgICovXG5cbiAgICBTdHJlYW0ucHJvdG90eXBlLmhhc1RyYWNrcyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFRyYWNrcyh0eXBlKS5sZW5ndGg7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdHJhY2tzIG9mIHRoZSBnaXZlbiB0eXBlXG4gICAgICogQG1ldGhvZCBnZXRUcmFja3NcbiAgICAgKiBAcGFyYW0geydhdWRpbycgfCAndmlkZW8nIHwgJ2JvdGgnfSBbdHlwZT0nYm90aCddIFRoZSB0eXBlIG9mIHRyYWNrcyB0byBnZXRcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gQW4gQXJyYXkgb2YgdGhlIHRyYWNrc1xuICAgICAqL1xuXG4gICAgU3RyZWFtLnByb3RvdHlwZS5nZXRUcmFja3MgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgICB2YXIgdmF1ZGlvLCB2aWRlbztcbiAgICAgIHR5cGUgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAodHlwZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW0uZ2V0QXVkaW9UcmFja3MoKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdHJlYW0uZ2V0VmlkZW9UcmFja3MoKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2JvdGgnKSB7XG4gICAgICAgIHZpZGVvID0gdGhpcy5zdHJlYW0uZ2V0VmlkZW9UcmFja3MoKTtcbiAgICAgICAgdmF1ZGlvID0gdGhpcy5zdHJlYW0uZ2V0QXVkaW9UcmFja3MoKTtcbiAgICAgICAgcmV0dXJuIHZpZGVvLmNvbmNhdChhdWRpbyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0cmVhbSBwYXJ0ICdcIiArIHR5cGUgKyBcIidcIik7XG4gICAgICB9XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgYSB0eXBlIG9mIHRyYWNrIGlzIG11dGVkLiBJZiB0aGVyZSBhcmUgbm8gdHJhY2tzIG9mIHRoZVxuICAgICAqIHNwZWNpZmllZCB0eXBlIHRoZXkgd2lsbCBiZSBjb25zaWRlcmVkIG11dGVkXG4gICAgICogQHBhcmFtIHsnYXVkaW8nIHwgJ3ZpZGVvJyB8ICdib3RoJ30gW3R5cGU9J2F1ZGlvJ10gVGhlIHR5cGUgb2YgdHJhY2tzXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciB0aGUgdHJhY2tzIGFyZSBtdXRlZFxuICAgICAqL1xuXG4gICAgU3RyZWFtLnByb3RvdHlwZS5tdXRlZCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIHZhciByZWYsIHRyYWNrcztcbiAgICAgIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAgICAgdHlwZSA9ICdhdWRpbyc7XG4gICAgICB9XG4gICAgICB0cmFja3MgPSB0aGlzLmdldFRyYWNrcyh0eXBlKTtcbiAgICAgIGlmICh0cmFja3MubGVuZ3RoIDwgMSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhKChyZWYgPSB0cmFja3NbMF0pICE9IG51bGwgPyByZWYuZW5hYmxlZCA6IHZvaWQgMCk7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogTXV0ZXMgb3IgdW5tdXRlcyB0cmFja3Mgb2YgdGhlIHN0cmVhbVxuICAgICAqIEBtZXRob2QgbXV0ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW211dGVkPXRydWVdIE11dGUgb24gYHRydWVgIGFuZCB1bm11dGUgb24gYGZhbHNlYFxuICAgICAqIEBwYXJhbSB7J2F1ZGlvJyB8ICd2aWRlbycgfCAnYm90aCd9IFt0eXBlPSdhdWRpbyddIFRoZSB0eXBlIG9mIHRyYWNrcyB0byBtdXRlIG9yIHVubXV0ZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgdGhlIHRyYWNrcyB3ZXJlIG11dGVkIG9yIHVubXV0ZWRcbiAgICAgKi9cblxuICAgIFN0cmVhbS5wcm90b3R5cGUubXV0ZSA9IGZ1bmN0aW9uKG11dGVkLCB0eXBlKSB7XG4gICAgICB2YXIgaSwgbGVuLCByZWYsIHRyYWNrO1xuICAgICAgaWYgKG11dGVkID09IG51bGwpIHtcbiAgICAgICAgbXV0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgICAgICB0eXBlID0gJ2F1ZGlvJztcbiAgICAgIH1cbiAgICAgIHJlZiA9IHRoaXMuZ2V0VHJhY2tzKHR5cGUpO1xuICAgICAgZm9yIChpID0gMCwgbGVuID0gcmVmLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRyYWNrID0gcmVmW2ldO1xuICAgICAgICB0cmFjay5lbmFibGVkID0gIW11dGVkO1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KCdtdXRlX2NoYW5nZWQnLCB0eXBlLCBtdXRlZCk7XG4gICAgICByZXR1cm4gbXV0ZWQ7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGUgbXV0ZSBzdGF0ZSBvZiB0cmFja3Mgb2YgdGhlIHN0cmVhbVxuICAgICAqIEBtZXRob2QgdG9nZ2xlTXV0ZVxuICAgICAqIEBwYXJhbSB7J2F1ZGlvJyB8ICd2aWRlbycgfCAnYm90aCd9IFt0eXBlPSdhdWRpbyddIFRoZSB0eXBlIG9mIHRyYWNrcyB0byBtdXRlIG9yIHVubXV0ZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgdGhlIHRyYWNrcyB3ZXJlIG11dGVkIG9yIHVubXV0ZWRcbiAgICAgKi9cblxuICAgIFN0cmVhbS5wcm90b3R5cGUudG9nZ2xlTXV0ZSA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIHZhciBpLCBsZW4sIG11dGVkLCByZWYsIHRyYWNrLCB0cmFja3M7XG4gICAgICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgICAgIHR5cGUgPSAnYXVkaW8nO1xuICAgICAgfVxuICAgICAgdHJhY2tzID0gdGhpcy5nZXRUcmFja3ModHlwZSk7XG4gICAgICBpZiAodHJhY2tzLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBtdXRlZCA9ICEoKHJlZiA9IHRyYWNrc1swXSkgIT0gbnVsbCA/IHJlZi5lbmFibGVkIDogdm9pZCAwKTtcbiAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHRyYWNrcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB0cmFjayA9IHRyYWNrc1tpXTtcbiAgICAgICAgdHJhY2suZW5hYmxlZCA9ICFtdXRlZDtcbiAgICAgIH1cbiAgICAgIHRoaXMuZW1pdCgnbXV0ZV9jaGFuZ2VkJywgdHlwZSwgbXV0ZWQpO1xuICAgICAgcmV0dXJuIG11dGVkO1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIFN0b3BzIHRoZSBzdHJlYW1cbiAgICAgKiBAbWV0aG9kIHN0b3BcbiAgICAgKi9cblxuICAgIFN0cmVhbS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGksIGxlbiwgcmVmLCByZXN1bHRzLCB0cmFjaztcbiAgICAgIGlmICh0aGlzLnN0cmVhbS5nZXRUcmFja3MgIT0gbnVsbCkge1xuICAgICAgICByZWYgPSB0aGlzLnN0cmVhbS5nZXRUcmFja3MoKTtcbiAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSByZWYubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICB0cmFjayA9IHJlZltpXTtcbiAgICAgICAgICByZXN1bHRzLnB1c2godHJhY2suc3RvcCgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbS5zdG9wKCk7XG4gICAgICB9XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogQ2xvbmVzIHRoZSBzdHJlYW0uIFlvdSBjYW4gY2hhbmdlIGJvdGggc3RyZWFtcyBpbmRlcGVuZGVudGx5LCBmb3IgZXhhbXBsZVxuICAgICAqIG11dGUgdHJhY2tzLiBZb3Ugd2lsbCBoYXZlIHRvIGBzdG9wKClgIGJvdGggc3RyZWFtcyBpbmRpdmlkdWFsbHkgd2hlbiB5b3VcbiAgICAgKiBhcmUgZG9uZS5cbiAgICAjXG4gICAgICogVGhpcyBpcyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZCBpbiBGaXJlZm94IGFuZCBleHBlY3RlZCB0byBiZSBpbXBsZW1lbnRlZFxuICAgICAqIGluIHZlcnNpb24gNDcuIFVzZSBgU3RyZWFtLmNhbkNsb25lKClgIHRvIGNoZWNrIHdoZXRoZXIgY2xvbmluZyBpcyBzdXBwb3J0ZWQgYnlcbiAgICAgKiB5b3VyIGJyb3dzZXIuXG4gICAgI1xuICAgICAqIEBtZXRob2QgY2xvbmVcbiAgICAgKiBAcmV0dXJuIHtydGMuU3RyZWFtfSBBIGNsb25lIG9mIHRoZSBzdHJlYW1cbiAgICAgKi9cblxuICAgIFN0cmVhbS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnN0cmVhbS5jbG9uZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdXIgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHN0cmVhbSBjbG9uaW5nLiBGaXJlZm94IGlzIGV4cGVjdGVkIHRvIGltcGxlbWVudCBpdCBpbiB2ZXJzaW9uIDQ3LlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgU3RyZWFtKHRoaXMuc3RyZWFtLmNsb25lKCkpO1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIGNsb25pbmcgc3RyZWFtIGlzIHN1cHBvcnRlZCBieSB0aGUgYnJvd3Nlci4gU2VlIGBjbG9uZSgpYFxuICAgICAqIGZvciBkZXRhaWxzXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZXRob2QgY2FuQ2xvbmVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgY2xvbmluZyBpcyBzdXBwb3J0ZWQsIGBmYWxzZWAgb3RoZXJ3aXNlXG4gICAgICovXG5cbiAgICBTdHJlYW0uY2FuQ2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBjb21wYXQuTWVkaWFTdHJlYW0ucHJvdG90eXBlLmNsb25lICE9IG51bGw7XG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHN0cmVhbSB1c2luZyBgZ2V0VXNlck1lZGlhKClgXG4gICAgICogQG1ldGhvZCBjcmVhdGVTdHJlYW1cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWc9e2F1ZGlvOiB0cnVlLCB2aWRlbzogdHJ1ZX1dIFRoZSBjb25maWd1cmF0aW9uIHRvIHBhc3MgdG8gYGdldFVzZXJNZWRpYSgpYFxuICAgICAqIEByZXR1cm4ge1Byb21pc2UgLT4gcnRjLlN0cmVhbX0gUHJvbWlzZSB0byB0aGUgc3RyZWFtXG4gICAgI1xuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgIHZhciBzdHJlYW0gPSBydGMuU3RyZWFtLmNyZWF0ZVN0cmVhbSh7YXVkaW86IHRydWUsIHZpZGVvOiBmYWxzZX0pO1xuICAgICAqICAgICBydGMuTWVkaWFEb21FbGVtZW50KCQoJ3ZpZGVvJyksIHN0cmVhbSk7XG4gICAgICovXG5cbiAgICBTdHJlYW0uY3JlYXRlU3RyZWFtID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICBpZiAoY29uZmlnID09IG51bGwpIHtcbiAgICAgICAgY29uZmlnID0ge1xuICAgICAgICAgIGF1ZGlvOiB0cnVlLFxuICAgICAgICAgIHZpZGVvOiB0cnVlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciBzdWNjZXNzO1xuICAgICAgICBzdWNjZXNzID0gZnVuY3Rpb24obmF0aXZlX3N0cmVhbSkge1xuICAgICAgICAgIHJldHVybiByZXNvbHZlKG5ldyBTdHJlYW0obmF0aXZlX3N0cmVhbSkpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY29tcGF0LmdldFVzZXJNZWRpYShjb25maWcsIHN1Y2Nlc3MsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFN0cmVhbTtcblxuICB9KShFdmVudEVtaXR0ZXIpO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjkuMlxuKGZ1bmN0aW9uKCkge1xuICB2YXIgUGVlciwgU3RyZWFtO1xuXG4gIFN0cmVhbSA9IHJlcXVpcmUoJy4vc3RyZWFtJykuU3RyZWFtO1xuXG4gIFBlZXIgPSByZXF1aXJlKCcuL3BlZXInKS5QZWVyO1xuXG5cbiAgLyoqXG4gICAqIEBtb2R1bGUgcnRjXG4gICAqL1xuXG5cbiAgLyoqXG4gICAqIEBjbGFzcyBydGMuTWVkaWFEb21FbGVtZW50XG4gICAqL1xuXG4gIGV4cG9ydHMuTWVkaWFEb21FbGVtZW50ID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIE1lZGlhRG9tRWxlbWVudChkb20sIGRhdGEpIHtcbiAgICAgIHRoaXMuZG9tID0gZG9tO1xuICAgICAgaWYgKHRoaXMuZG9tLmpxdWVyeSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuZG9tID0gdGhpcy5kb21bMF07XG4gICAgICB9XG4gICAgICB0aGlzLmF0dGFjaChkYXRhKTtcbiAgICB9XG5cbiAgICBNZWRpYURvbUVsZW1lbnQucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIGlmIChkYXRhID09IG51bGwpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuc3RyZWFtO1xuICAgICAgICB0aGlzLmRvbS5wYXVzZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5kb20uc3JjID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIFN0cmVhbSkge1xuICAgICAgICB0aGlzLnN0cmVhbSA9IGRhdGE7XG4gICAgICAgIGlmICh0eXBlb2YgbW96R2V0VXNlck1lZGlhICE9PSBcInVuZGVmaW5lZFwiICYmIG1vekdldFVzZXJNZWRpYSAhPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuZG9tLm1velNyY09iamVjdCA9IGRhdGEuc3RyZWFtO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZG9tLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwoZGF0YS5zdHJlYW0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRvbS5wbGF5KCk7XG4gICAgICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBQZWVyKSB7XG4gICAgICAgIGlmIChkYXRhLmlzTG9jYWwoKSkge1xuICAgICAgICAgIHRoaXMubXV0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmF0dGFjaChkYXRhLnN0cmVhbSgpKTtcbiAgICAgIH0gZWxzZSBpZiAoKGRhdGEgIT0gbnVsbCA/IGRhdGEudGhlbiA6IHZvaWQgMCkgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZGF0YS50aGVuKChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5hdHRhY2gocmVzKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSlbXCJjYXRjaFwiXSgoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuZXJyb3IoZXJyKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5lcnJvcihcIlRyaWVkIHRvIGF0dGFjaCBpbnZhbGlkIGRhdGFcIik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIE1lZGlhRG9tRWxlbWVudC5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLmxvZyhlcnIpO1xuICAgIH07XG5cbiAgICBNZWRpYURvbUVsZW1lbnQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRhY2goKTtcbiAgICB9O1xuXG4gICAgTWVkaWFEb21FbGVtZW50LnByb3RvdHlwZS5tdXRlID0gZnVuY3Rpb24obXV0ZWQpIHtcbiAgICAgIGlmIChtdXRlZCA9PSBudWxsKSB7XG4gICAgICAgIG11dGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmRvbS5tdXRlZCA9IG11dGVkO1xuICAgIH07XG5cbiAgICBNZWRpYURvbUVsZW1lbnQucHJvdG90eXBlLnRvZ2dsZU11dGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmRvbS5tdXRlZCA9ICF0aGlzLmRvbS5tdXRlZDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIE1lZGlhRG9tRWxlbWVudDtcblxuICB9KSgpO1xuXG59KS5jYWxsKHRoaXMpO1xuIl19
